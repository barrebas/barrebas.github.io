<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Binary, | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/binary/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2014-12-02T22:07:47+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[9447 CTF: Rolling]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/02/9447-ctf-rolling/"/>
    <updated>2014-12-02T20:43:25+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/02/9447-ctf-rolling</id>
    <content type="html"><![CDATA[<p>The last flag for 9447 CTF that I got was this binary reversing challenge. Let&rsquo;s get <code>rolling</code>!</p>

<!--more-->


<p>Identifying the binary with file showed that it was a 64-bit ELF, dynamically linked. Unfortunately for me, it was linked against a higher <code>libc</code> version:</p>

<pre><code class="bash">bas@tritonal:~/tmp/9447$ ./rolling 
./rolling: /lib/x86_64-linux-gnu/libc.so.6: version 'GLIBC_2.14' not found (required by ./rolling)
</code></pre>

<p>To solve this issue, I needed a way to get the program to use a newer version of libc. One way to do this is using <code>LD_PRELOAD</code>. I downloaded a <a href="http://pkgs.org/ubuntu-14.10/ubuntu-main-amd64/libc6_2.19-10ubuntu2_amd64.deb.html">newer libc deb</a>, that ought to be binary compatible with my debian box. After unpacking <code>ld-2.19.so</code> and <code>libc-2.19.so</code>, I could start the binary like this:</p>

<pre><code class="bash">bas@tritonal:~/tmp/9447$ LD_PRELOAD=./libc-2.19.so ./ld-2.19.so ./rolling
Fynd i mewn i cyfrinair
</code></pre>

<p>And in <code>gdb</code>:</p>

<pre><code class="bash">gdb-peda$ set environment LD_PRELOAD=./libc-2.19.so ./ld-2.19.so
gdb-peda$ r
Fynd i mewn i cyfrinair

Program received signal SIGSEGV, Segmentation fault.
&lt;snip&gt;
</code></pre>

<p>The program would still segfault, but at least it ran. Okay, let&rsquo;s get to work. The strange string meant nothing to me, but it&rsquo;s Welsh for &ldquo;Enter a password&rdquo;. Of course, the description on 9447 mentioned that the binary would take an input. The flag is the input which the binary accepts. I ran the binary with an argument, which resulted in another Welsh string. <code>strings</code> identified the last Welsh string. I looked up their meaning via Google Translate and their address in <code>gdb</code>:</p>

<pre><code class="bash">Nac oes. Ceisiwch eto. == No. Try again. // rolling : 0x600865 ("Nac oes. Ceisiwch eto.")
Llongyfarchiadau == Congratulations // rolling : 0x600854 ("Llongyfarchiadau")
</code></pre>

<p>These strings look like the &ldquo;Good&rdquo;/&ldquo;Bad&rdquo; output that we expect for this input-checking binary! Switching over to the output of <code>objdump</code>, I looked up where these strings are referenced:</p>

<pre><code class="bash">  400771:   48 8b 55 f0             mov    -0x10(%rbp),%rdx
  400775:   48 83 c2 08             add    $0x8,%rdx
  400779:   48 8b 12                mov    (%rdx),%rdx
  40077c:   48 89 d7                mov    %rdx,%rdi
  40077f:   ff d0                   callq  *%rax        # interesting function
  400781:   85 c0                   test   %eax,%eax    # if eax == 1 -&gt; success
  400783:   74 0c                   je     400791 &lt;memcpy@plt+0x2b1&gt;
  400785:   bf 54 08 40 00          mov    $0x400854,%edi               # Llong...
  40078a:   e8 11 fd ff ff          callq  4004a0 &lt;puts@plt&gt;
  40078f:   eb 16                   jmp    4007a7 &lt;memcpy@plt+0x2c7&gt;
  400791:   bf 65 08 40 00          mov    $0x400865,%edi               # Nac oes... 
  400796:   e8 05 fd ff ff          callq  4004a0 &lt;puts@plt&gt;
  40079b:   eb 0a                   jmp    4007a7 &lt;memcpy@plt+0x2c7&gt;
  40079d:   bf 7c 08 40 00          mov    $0x40087c,%edi
  4007a2:   e8 f9 fc ff ff          callq  4004a0 &lt;puts@plt&gt;
  4007a7:   b8 00 00 00 00          mov    $0x0,%eax
  4007ac:   c9                      leaveq 
  4007ad:   c3                      retq  
</code></pre>

<p>The <code>test eax, eax</code> at <code>0x400781</code> controls which path is taken: either OK (&ldquo;Llong&hellip;&rdquo;) or not OK (&ldquo;Nac oes&hellip;&rdquo;). The value of <code>eax</code> is probably set by the function that is called at <code>0x40077f: callq  *%rax</code>. Switching back to <code>gdb</code>, I set a breakpoint on <code>0x40077f</code> and prepared to trace that function.</p>

<pre><code class="bash">gdb-peda$ b *0x40077f
Breakpoint 1 at 0x40077f
gdb-peda$ r bleh
...
[-------------------------------------code-------------------------------------]
   0x400775:    add    rdx,0x8
   0x400779:    mov    rdx,QWORD PTR [rdx]
   0x40077c:    mov    rdi,rdx
=&gt; 0x40077f:    call   rax
   0x400781:    test   eax,eax
   0x400783:    je     0x400791
...
Breakpoint 1, 0x000000000040077f in ?? ()
</code></pre>

<p>The binary was halted at the <code>call eax</code> instruction. I entered <code>ni</code> to step into the function. This is where the fun really starts, it is where our string is checked for validity. There&rsquo;s a red herring in there too. The function starts like this:</p>

<pre><code>gdb-peda$ x/40i $rip
=&gt; 0x7ffff7ff5000:  push   rbp
   0x7ffff7ff5001:  mov    rbp,rsp
   0x7ffff7ff5004:  sub    rsp,0x10
   0x7ffff7ff5008:  mov    QWORD PTR [rbp-0x8],rdi
   0x7ffff7ff500c:  mov    rax,QWORD PTR [rbp-0x8]
   # grab first byte of input
   0x7ffff7ff5010:  movzx  eax,BYTE PTR [rax]   
   # is it '9'?
   0x7ffff7ff5013:  cmp    al,0x39
   # if so, jump away
   0x7ffff7ff5015:  je     0x7ffff7ff5143   
   # else:
   0x7ffff7ff501b:  mov    rax,QWORD PTR [rbp-0x8] 
   # grab first byte of input
   0x7ffff7ff501f:  movzx  eax,BYTE PTR [rax]   
   # is it 'f'?
   0x7ffff7ff5022:  cmp    al,0x66          
   # if not, jump away
   0x7ffff7ff5024:  jne    0x7ffff7ff5139   
   0x7ffff7ff502a:  mov    rax,QWORD PTR [rbp-0x8]
   # second byte of input
   0x7ffff7ff502e:  add    rax,0x1      
   0x7ffff7ff5032:  movzx  eax,BYTE PTR [rax]
   # is it 'l'?
   0x7ffff7ff5035:  cmp    al,0x6c  
   0x7ffff7ff5037:  jne    0x7ffff7ff5139
   0x7ffff7ff503d:  mov    rax,QWORD PTR [rbp-0x8]
   # third byte of input
   0x7ffff7ff5041:  add    rax,0x2
   0x7ffff7ff5045:  movzx  eax,BYTE PTR [rax]
   # is it 'a'?
   0x7ffff7ff5048:  cmp    al,0x61
</code></pre>

<p>I was all super excited and started to trace the path that started spelling out <code>flag</code>, each time adjusting <code>al</code> to the value that it was being compared to (in <code>gdb</code>, this can be done by executing <code>set $al=0x66</code>). However, this path spelled out <code>flagstartswith9</code>. In other words, I fell for the red herring. D&#8217;oh! The other code path started comparing the input to <code>9</code>, so I restarted the binary and entered <code>9447</code> as the input. Re-tracing the check-input function, I noticed that the code had changed!</p>

<pre><code># Input 'bleh':
   0x7ffff7ff5022:  cmp    al,0x66  
# Input '9447'
   0x7ffff7ff5022:  cmp    al,0x34
</code></pre>

<p>Very fancy. I traced the function further, ending up here:</p>

<pre><code>gdb-peda$ 
[----------------------------------registers-----------------------------------]
RAX: 0x72 ('r')
...
[-------------------------------------code-------------------------------------]
   0x7ffff7ff5062:  movzx  eax,BYTE PTR [rax]
   0x7ffff7ff5065:  movsx  eax,al
   0x7ffff7ff5068:  add    eax,0x39
=&gt; 0x7ffff7ff506b:  cmp    edx,eax
</code></pre>

<p>This is the fifth character of the password and seems to be <code>r</code>. I did a quick <code>set $edx=$eax</code> and moved on. The next bytes were <code>oll</code>, so I expected the following check to be for <code>i</code>. However, the password function borked, because it was using the first four characters to generate the next four! I had only entered four in total. The name of the binary, <code>rolling</code>, makes a bit more sense now :)</p>

<pre><code># grab eight input byte
   0x7ffff7ff50c1:  mov    rax,QWORD PTR [rbp-0x8]
   0x7ffff7ff50c5:  add    rax,0x7
   0x7ffff7ff50c9:  movzx  eax,BYTE PTR [rax]
=&gt; 0x7ffff7ff50cc:  movsx  eax,al
# grab third input byte...
   0x7ffff7ff50cf:  mov    rdx,QWORD PTR [rbp-0x8]
   0x7ffff7ff50d3:  add    rdx,0x3
   0x7ffff7ff50d7:  movzx  edx,BYTE PTR [rdx]
   0x7ffff7ff50da:  movsx  edx,dl
# ... and add 0x35 to that third byte!
   0x7ffff7ff50dd:  add    edx,0x35
# compare [3]+0x35 to [7]:
   0x7ffff7ff50e0:  cmp    eax,edx
</code></pre>

<p>This meant I just had to re-run the binary once I had four more characters. No problem! Eventually, at each <code>cmp</code> execution, I noted the proper byte and the correct input turned out to be <code>9447rollingisfun</code>.</p>

<p>The flag was <code>9447{9447rollingisfun}</code>.</p>
]]></content>
  </entry>
  
</feed>
