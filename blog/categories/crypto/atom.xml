<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Crypto | staring into /dev/null]]></title>
  <link href="http://barrebas.github.io/blog/categories/crypto/atom.xml" rel="self"/>
  <link href="http://barrebas.github.io/"/>
  <updated>2015-08-18T21:42:50+02:00</updated>
  <id>http://barrebas.github.io/</id>
  <author>
    <name><![CDATA[barrebas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PoliCTF 2015 - and the Prophet Said]]></title>
    <link href="http://barrebas.github.io/blog/2015/07/12/polictf-2015-and-the-prophet-said/"/>
    <updated>2015-07-12T11:47:44+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/07/12/polictf-2015-and-the-prophet-said</id>
    <content type="html"><![CDATA[<p>After solving the first crypto challenge of PoliCTF 2015, I moved onto the 100 point challenge.</p>

<!--more-->


<p>The download contains a text file with base64-encoded data, which becomes a .gz archive. After decompressing, I obtained a text file with biblical text. Not my cup of tea, but I immediately saw that certain sentences were duplicated. I wrote a python script to count the occurences of lines:</p>

<pre><code class="python">d = {}

with open('text-file') as f:
    lines = f.readlines()
    for l in lines:
        if l in d:
            d[l] += 1
        else:
            d[l] = 1

for w in sorted(d, key=d.get):
    print w, d[w]
</code></pre>

<p>Which gave me these frequencies:</p>

<pre><code class="bash">...snip...
Ye shall not eat anything with the blood: neither shall ye use enchantments, nor practise augury.
21
And ye shall keep my statutes, and do them: I am Jehovah who sanctifieth you.
23
And if a man lie with a beast, he shall surely be put to death: and ye shall slay the beast.
26
And when he hath made an end of atoning for the holy place, and the tent of meeting, and the altar, he shall present the live goat:
47
</code></pre>

<p>A total of 30 distinct strings were found. I guessed these strings represented letters, so I extended the python script a bit and started puzzling:</p>

<pre><code class="python">d = {}

with open('text-file') as f:
    lines = f.readlines()
    for l in lines:
        if l in d:
            d[l] += 1
        else:
            d[l] = 1

for w in sorted(d, key=d.get):
    print w, d[w]

print len(d)    
x = dict(zip(sorted(d, key=d.get, reverse=True), ' etaoinsrhldcubkfgjmpqvwxyz012'))

# transpose the strings to letters and print out the message
out = ""
for l in lines:
    out += x[l]

print out
</code></pre>

<p>I guessed that the most common string was a space, which indeed yielded word- and sentence-like output:</p>

<pre><code>rtiisq eroa grniitlht oa wtdc tnac oalje oe1 ojk edcolh es bdoet n islh ktaanht as aeneoaeoga boii rtip csf boer ert iteetd mdtxftlgotav ufe ojk lse dtniic hssy ne ernev s0 erneja tlsfhrq nrnrq ojk ol iswt boer aokpit isbtdgnat minha boersfe apngta nly aednlht ackusiav minhziureuhhfwmacleuuxbus2
</code></pre>

<p>I then started to look for THE, THIS, A, AND to guess the first couple of letters:</p>

<pre><code>Heoosq THIS gHnooelre IS wedc enSc ISljT IT1 Ijk TdcIlr Ts bdITe n oslr keSSnre Ss STnTISTIgS bIoo Heop csf bITH THe oeTTed mdexfelgIeSv ufT Ijk lsT denooc rssy nT THnTv s0 THnTjS elsfrHq nHnHq Ijk Il oswe bITH SIkpoe osbedgnSe monrS bITHsfT SpngeS nly STdnlre SckusoSv monrzouHTurrfwmSclTuuxbus2
</code></pre>

<p>Slowly but surely, I translated all the letters, and the words slowly emerged (I love that!):</p>

<pre><code>HEoonq THIS gHAooEldE IS VERY EASY ISljT IT1 Ijk TRYIld Tn WRITE A onld kESSAdE Sn STATISTIgS WIoo HEop Ynf WITH THE oETTER mRExfElgIESb ufT Ijk lnT REAooY dnnc AT THATb n0 THATjS ElnfdHq AHAHq Ijk Il onVE WITH SIkpoE onWERgASE moAdS WITHnfT SpAgES Alc STRAldE SYkunoSb moAdzouHTuddfVmSYlTuuxWun2

HELLoq THIS CHALLENGE IS VERY EASY ISN'T IT? I'k TRYING To WRITE A LoNG kESSAGE So STATISTICS WILL HELp Yof WITH THE LETTER mRExfENCIESb ufT I'k NoT REALLY Good AT THATb oj THAT'S ENofGHq AHAHq I'k IN LoVE WITH SIkpLE LoWERCASE mLAGS WITHofT SpACES ANd STRANGE SYkuoLSb mLAGzLuHTuGGfVmSYNTuuxWuo2

HELLOq THIS CHALLENGE IS VERY EASY ISN'T IT? I'M TRYING TO WRITE A LONG MESSAGE SO STATISTICS WILL HELP YOU WITH THE LETTER kRExUENCIESb uUT I'M NOT REALLY GOOd AT THATb Oj THAT'S ENOUGHq AHAHq I'M IN LOVE WITH SIMPLE LOWERCASE kLAGS WITHOUT SPACES ANd STRANGE SYMuOLSb kLAGzLuHTuGGUVkSYNTuuxWuO2

HELLO! THIS CHALLENGE IS VERY EASY ISN'T IT? I'M TRYING TO WRITE A LONG MESSAGE SO STATISTICS WILL HELP YOU WITH THE LETTER FREQUENCIES, BUT I'M NOT REALLY GOOD AT THAT, OK THAT'S ENOUGH! AHAH! I'M IN LOVE WITH SIMPLE LOWERCASE FLAGS WITHOUT SPACES AND STRANGE SYMBOLS, FLAG{LBHTBGGUVFSYNTBBQWBO}
</code></pre>

<p>The final translation dictionary was: <code>x = dict(zip(sorted(d, key=d.get, reverse=True), " TESILAOHGNRYBWMUC'FP!,VQD{K?}"))</code>
The challenge already said that the flag needed a bit more work. Indeed, <code>flag{lbhtbgguvfsyntbbqwbo}</code> was not accepted. What then? Bitvijays suggested that the flag was another &ldquo;ciphertext&rdquo;, so I thought of Caesar cipher. The easiest is <a href="http://rot13.com">rot13</a> and indeed, the flag was <code>flag{yougotthisflagoodjob}</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PoliCTF 2015 - Exorcise]]></title>
    <link href="http://barrebas.github.io/blog/2015/07/12/polictf-2015-exorcise/"/>
    <updated>2015-07-12T11:39:10+02:00</updated>
    <id>http://barrebas.github.io/blog/2015/07/12/polictf-2015-exorcise</id>
    <content type="html"><![CDATA[<p>Exorcise was a 50 point crypto challenge for PoliCTF.</p>

<!--more-->


<p>We&rsquo;re asked to connect to <code>exorcise.polictf.it:80</code>. Upon connecting, we&rsquo;re presented with a hexadecimal string. I pressed return and got another:</p>

<pre><code class="bash">bas@tritonal:~$ nc exorcise.polictf.it 80
2e0540472c37151c4e007f481c2a0110311204084f

2e0541495b161248101c2a11122d16102d1608091902027f0d071c2c53050a061f05380d410f0a2a531f1e1907053d3310543e5d1c3a512653020c09461809025b341111475310451b3a014736000c4d0404002c1c4f142d164805001f107f094114103110074c190344283a00063b110c26413a00
</code></pre>

<p>Because of the challenge title, I xor&#8217;ed the second string using the first as a key and got gibberish. I decided to reconnect and send a bunch of NULL bytes (Ctrl+Space). When I xor&#8217;ed that string against the first, I got this:</p>

<pre><code>What's your name^i%UX`C=h=pN^xPdaW]j,1ISJC't yru4OBwguHi! What's your name^G
</code></pre>

<p>Hmmmmm. I reconnected again, sent a bunch of A characters and the resulting string was xor&#8217;ed vs 0x41:</p>

<pre><code class="python">e = "2e0541263a1e352928321e70321e32711e32282c312d241e382e341e32292e342d251e292037241e322e2d3724251e1e28351e702f1e741e3224223c272d20263a1e352928321e70321e32711e32282c312d241e382e341e32292e342d251e292037241e322e2d3724251e1e28351e702f1e741e3224223c272d2026557f3d0e490a3044533e01557f010c0c14050b38591b1d36004802101f173e0f04561c30064f1c040a063e3d050d7f50022d503b0a450412124c150f1e7f1f0d105d7f7e07371642281a1a0850180d3a0a0a553e010d4f1f19172b480056072a1d0c04560a027f280c1d2d554e3d4c2b1616"
msg = [e[start:start+2] for start in xrange(0, len(e), 2)]

out = ""
for i in range(len(msg)):
    b = (int(msg[i], 16))
    out += chr(0x41^b)
print out
</code></pre>

<pre><code class="bash">bas@tritonal:~/tmp/polictf/exorcise$ python exorcise.py
oDg{_this_1s_s0_simple_you_should_have_solved__it_1n_5_sec}flag{_this_1s_s0_simple_you_should_have_solved__it_1n_5_sec}flag
</code></pre>

<p>There&rsquo;s the flag: <code>flag{_this_1s_s0_simple_you_should_have_solved__it_1n_5_sec}</code>. Took me a bit longer than 5 seconds&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advent CTF 2014 - Rotate]]></title>
    <link href="http://barrebas.github.io/blog/2014/12/21/advent-ctf-2014-rotate/"/>
    <updated>2014-12-21T16:09:36+01:00</updated>
    <id>http://barrebas.github.io/blog/2014/12/21/advent-ctf-2014-rotate</id>
    <content type="html"><![CDATA[<p>A crypto challenge! We&rsquo;re given a zip-file, containing <code>flag.jpg.enc</code> and <code>rotate.py</code>.</p>

<!-- more -->


<p><code>rotate.py</code> handles the encryption, but only does so one way:</p>

<pre><code class="python">import sys
import math
import struct

p = lambda x: struct.pack('f', x)
u = lambda x: struct.unpack('b', x)[0]

if len(sys.argv) != 3:
    sys.exit(1)

filename = sys.argv[1]
key = math.radians(int(sys.argv[2]))

bs = open(filename, 'rb').read()
enc = open(filename + '.enc', 'wb')

for i in range(0, len(bs), 2):
    x, y = u(bs[i]), u(bs[i+1])
    enc.write(p(x * math.cos(key) - y * math.sin(key)) + p(x * math.sin(key) + y * math.cos(key)))
</code></pre>

<p>The script takes two bytes at a time and transforms them into two floats via some goniometric functions, using a key. These floats are then dumped as DWORDS into the encrypted output file. Our first job is to determine what key was used.</p>

<p>Assuming the flag really <strong>is</strong> a JPEG, we have some prior knowledge. Namely, the first two bytes are <code>0xff,0xd8</code>. I made a small file that contains only these two bytes and I ripped the first 8 bytes from <code>flag.jpg.enc</code>. I encoded the small 2-byte file with all possible keys and then compared the md5sum of each file to the md5sum of the 8-byte encoded file:</p>

<pre><code class="bash">bas@tritonal:~/adventctf/rotate$ for i in `seq 0 360`; do python rotate.py ./header_real2 $i; mv header_real2.enc output$i; done
bas@tritonal:~/adventctf/rotate$ md5sum header_encoded8
ed3f26885ebe2ba3ec0aa61215e4dcf2  header_encoded8
bas@tritonal:~/adventctf/rotate$ md5sum output* |grep ed3f2
ed3f26885ebe2ba3ec0aa61215e4dcf2  output123
</code></pre>

<p>So I now know the key that was used was <code>123</code>. I then started building a decoder. I hit a few snags on the way. It turns out that <code>rotate.py</code> doesn&rsquo;t use the literal value of each byte, but instead uses <code>struct.unpack('b', byte)</code> to generate a <strong>signed</strong> representation. That threw me off for a good while.</p>

<p>The decoder first builds a lookup table of each possible two-byte combination. Then, to decode, it reads eight bytes at a time and looks up the corresponding values from the lookup table. If there are no more floats to be read, it catches the error and outputs the decrypted data:</p>

<pre><code class="python">import sys
import math
import struct

p = lambda x: struct.pack('f', x)
u = lambda x: struct.unpack('b', x)[0]

if len(sys.argv) != 3:
    sys.exit(1)

filename = sys.argv[1]
key = math.radians(int(sys.argv[2]))

enc = open(filename, 'rb')

lookup = {}
for k in xrange(256):
    for l in xrange(256):
        x = struct.unpack('b', chr(k))[0]
        y = struct.unpack('b', chr(l))[0]

        x1 = p(x * math.cos(key) - y * math.sin(key))
        x2 = p(x * math.sin(key) + y * math.cos(key))

        x3 = struct.unpack('&lt;L', x1)[0]
        x4 = struct.unpack('&lt;L', x2)[0]

        lookup[ (x3&lt;&lt;32)+x4 ] = (k, l)

going = 1
decoded = ""
while going:
    try:
        f1 = struct.unpack('&lt;L', enc.read(4))[0]
        f2 = struct.unpack('&lt;L', enc.read(4))[0]

        (x, y) = lookup[ (f1&lt;&lt;32)+f2 ]

        decoded += chr(x)
        decoded += chr(y)
    except:
        going = 0
        print decoded
</code></pre>

<p>It&rsquo;s <em>horrible</em> code, but it got the job done:</p>

<p><img src="/assets/adctf/rotate-flag.jpg" alt="" /></p>

<p>The flag was <code>ADCTF_TR0t4T3_f4C3</code>.</p>
]]></content>
  </entry>
  
</feed>
